<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/js/_std/Array.hx" extern="1">
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.
		
		This operation modifies `this` Array in place.
		
		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.
		
		This operation modifies `this` Array in place.
		
		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].
		
		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.
		
		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies `this` Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.
		
		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.
		
		This operation does not modify `this` Array.
		
		The elements are not copied and retain their identity.
		
		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.
		
		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.
		
		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.
		
		If `this` is the empty Array `[]`, `null` is returned and the length 
		remains 0.</haxe_doc>
		</shift>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the offset
		it was added at.
		
		This operation modifies `this` Array in place.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this.length` will decrease by 1.
		
		If `this` is the empty Array `[]`, null is returned and the length 
		remains 0.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.
		
		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`
		
		If `this` is the empty Array `[]`, the result is the empty String `""`. 
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.
		
		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a `List` which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents a Class.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="38" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="48" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:
		
		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`
		
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<toString public="1" get="inline" set="null" line="34">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
		
		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
	
	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.
	
	There is some extra functions available in the `DateTools` class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is `EnumValue`.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="ImportAll" params="" file="ImportAll.hx"/>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="42" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.
		
		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.
	
	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.
	
	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with `key1 => value1, key2 => value2` syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1"><meta><m n=":keep"/></meta></class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.
		
		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than `v`.
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.
		
		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.
		
		If `f` is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/js/_std/Reflect.hx">
		<field public="1" get="inline" set="null" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.
		
		If `o` is not an object or has no field named `field`, the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.
		
		If `field` is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<getProperty public="1" get="inline" set="null" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="46" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.
		
		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.
		
		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<fields public="1" set="method" line="55" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.
		
		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="66" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.
		
		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<isObject public="1" set="method" line="82" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.
		
		The result is true if `v` is one of the following:
			
		- class instance
		- structure
		- Class<T>
		- Enum<T>
			
		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<makeVarArgs public="1" set="method" line="107" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.
		
		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.
		
		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.
		
		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.
		
		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.
		
		If `startIndex` or `endIndex` are negative, 0 is used instead.
		
		If `startIndex` exceeds `endIndex`, they are swapped.
		
		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.
		
		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.
		
		If `this` String is the empty String "", the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.
		
		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.
		
		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.
		
		If `delimiter` is null, the result is unspecified.
		
		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.
		
		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.
		
		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/js/_std/Std.hx">
		<string public="1" set="method" line="35" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseInt public="1" set="method" line="43" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="53" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a NaN value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.
	
	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.
	
	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.
	
	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.
	
	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<addSub public="1" get="inline" set="null" line="88">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.
		
		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.
		
		If `s` or `pos` are null, the result is unspecified.
		
		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<b><c path="String"/></b>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<startsWith public="1" set="method" line="128" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is null, the result is unspecified.

		If `start` is the empty String "", the result is true.</haxe_doc>
		</startsWith>
		<isSpace public="1" set="method" line="166" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String "", or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<rtrim public="1" set="method" line="205" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls isSpace() to decide which characters to
		remove.

		If `s` is the empty String "" or consists only of space characters, the
		result is the empty String "".</haxe_doc>
		</rtrim>
		<replace public="1" set="method" line="292" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String "", `by` is inserted after each character
		of `s`. If `by` is also the empty String "", `s` remains unchanged.

		This is a convenience function for `s.split(sub).join(by)`.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/js/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/js/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.
		
		If `o` is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getClassName public="1" set="method" line="53" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.
		
		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `c` has no package, the class name is returned.
		
		If `c` is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<resolveClass public="1" set="method" line="63" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.
		
		If `name` is the path of an existing class, that class is returned.
		
		Otherwise null is returned.
		
		If `name` is null or the path to a different type, the result is
		unspecified.
		
		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="71" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.
		
		If `name` is the path of an existing enum, that enum is returned.
		
		Otherwise null is returned.
		
		If `name` is null the result is unspecified.
		
		If `name` is the path to a different type, null is returned.
		
		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="79" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<typeof public="1" set="method" line="151" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.
		
		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="UInt" params="" file="/media/psf/Home/projects/repos/public/openfl/UInt.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/js/_std/Xml.hx" module="Xml"><meta><m n=":flatEnum"/></meta></enum>
	<class path="Xml" params="" file="/usr/lib/haxe/std/js/_std/Xml.hx">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</DocType>
		<ProcessingInstruction public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</ProcessingInstruction>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>A type of Xml node.</haxe_doc>
		</Document>
		<elements public="1" set="method" line="176">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.</haxe_doc>
		</elements>
		<get public="1" set="method" line="132">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.</haxe_doc>
		</get>
		<get_nodeName set="method" line="104"><f a=""><c path="String"/></f></get_nodeName>
		<_children><c path="Array"><c path="Xml"/></c></_children>
		<_attributes><c path="haxe.ds.StringMap"><c path="String"/></c></_attributes>
		<_nodeName><c path="String"/></_nodeName>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.</haxe_doc>
		</nodeType>
		<haxe_doc>The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="flash.Lib" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" get="inline" set="null" line="9" static="1"><f a=""><x path="Int"/></f></getTimer>
		<eval public="1" set="method" line="13" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" set="method" line="33" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<x path="Void"/>
</f></getURL>
		<fscommand public="1" set="method" line="41" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></fscommand>
		<trace public="1" set="method" line="45" static="1"><f a="arg">
	<d/>
	<x path="Void"/>
</f></trace>
		<attach public="1" set="method" line="49" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" get="inline" set="null" line="54" static="1"><f a="v:c">
	<d/>
	<x path="Class"><c path="as.T"/></x>
	<t path="Null"><c path="as.T"/></t>
</f></as>
		<redirectTraces public="1" set="method" line="58" static="1"><f a=""><x path="Void"/></f></redirectTraces>
		<traceToConsole set="method" line="63" static="1"><f a="v:?inf">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></traceToConsole>
	</class>
	<class path="flash.Vector" params="T" file="/media/psf/Home/projects/repos/public/openfl/flash/Vector.hx" extern="1">
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1"><x path="Int"/></length>
		<new public="1"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method">
			<f a="type">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks whether an event listener is registered with this EventDispatcher
	 * object or any of its ancestors for the specified event type. This method
	 * returns <code>true</code> if an event listener is triggered during any
	 * phase of the event flow when an event of the specified type is dispatched
	 * to this EventDispatcher object or any of its descendants.
	 *
	 * <p>The difference between the <code>hasEventListener()</code> and the
	 * <code>willTrigger()</code> methods is that <code>hasEventListener()</code>
	 * examines only the object to which it belongs, whereas the
	 * <code>willTrigger()</code> method examines the entire event flow for the
	 * event specified by the <code>type</code> parameter. </p>
	 *
	 * <p>When <code>willTrigger()</code> is called from a LoaderInfo object,
	 * only the listeners that the caller can access are considered.</p>
	 * 
	 * @param type The type of event.
	 * @return A value of <code>true</code> if a listener of the specified type
	 *         will be triggered; <code>false</code> otherwise.]]></haxe_doc>
		</willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method">
			<f a="type:listener:?useCapture">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Removes a listener from the EventDispatcher object. If there is no
	 * matching listener registered with the EventDispatcher object, a call to
	 * this method has no effect.
	 * 
	 * @param type       The type of event.
	 * @param useCapture Specifies whether the listener was registered for the
	 *                   capture phase or the target and bubbling phases. If the
	 *                   listener was registered for both the capture phase and
	 *                   the target and bubbling phases, two calls to
	 *                   <code>removeEventListener()</code> are required to
	 *                   remove both, one call with <code>useCapture()</code> set
	 *                   to <code>true</code>, and another call with
	 *                   <code>useCapture()</code> set to <code>false</code>.]]></haxe_doc>
		</removeEventListener>
		<hasEventListener public="1" set="method">
			<f a="type">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks whether the EventDispatcher object has any listeners registered for
	 * a specific type of event. This allows you to determine where an
	 * EventDispatcher object has altered handling of an event type in the event
	 * flow hierarchy. To determine whether a specific event type actually
	 * triggers an event listener, use <code>willTrigger()</code>.
	 *
	 * <p>The difference between <code>hasEventListener()</code> and
	 * <code>willTrigger()</code> is that <code>hasEventListener()</code>
	 * examines only the object to which it belongs, whereas
	 * <code>willTrigger()</code> examines the entire event flow for the event
	 * specified by the <code>type</code> parameter. </p>
	 *
	 * <p>When <code>hasEventListener()</code> is called from a LoaderInfo
	 * object, only the listeners that the caller can access are considered.</p>
	 * 
	 * @param type The type of event.
	 * @return A value of <code>true</code> if a listener of the specified type
	 *         is registered; <code>false</code> otherwise.]]></haxe_doc>
		</hasEventListener>
		<dispatchEvent public="1" set="method">
			<f a="event">
				<c path="flash.events.Event"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Dispatches an event into the event flow. The event target is the
	 * EventDispatcher object upon which the <code>dispatchEvent()</code> method
	 * is called.
	 * 
	 * @param event The Event object that is dispatched into the event flow. If
	 *              the event is being redispatched, a clone of the event is
	 *              created automatically. After an event is dispatched, its
	 *              <code>target</code> property cannot be changed, so you must
	 *              create a new copy of the event for redispatching to work.
	 * @return A value of <code>true</code> if the event was successfully
	 *         dispatched. A value of <code>false</code> indicates failure or
	 *         that <code>preventDefault()</code> was called on the event.
	 * @throws Error The event dispatch recursion limit has been reached.]]></haxe_doc>
		</dispatchEvent>
		<addEventListener public="1" set="method">
			<f a="type:listener:?useCapture:?priority:?useWeakReference">
				<c path="String"/>
				<f a="">
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Registers an event listener object with an EventDispatcher object so that
	 * the listener receives notification of an event. You can register event
	 * listeners on all nodes in the display list for a specific type of event,
	 * phase, and priority.
	 *
	 * <p>After you successfully register an event listener, you cannot change
	 * its priority through additional calls to <code>addEventListener()</code>.
	 * To change a listener's priority, you must first call
	 * <code>removeListener()</code>. Then you can register the listener again
	 * with the new priority level. </p>
	 *
	 * <p>Keep in mind that after the listener is registered, subsequent calls to
	 * <code>addEventListener()</code> with a different <code>type</code> or
	 * <code>useCapture</code> value result in the creation of a separate
	 * listener registration. For example, if you first register a listener with
	 * <code>useCapture</code> set to <code>true</code>, it listens only during
	 * the capture phase. If you call <code>addEventListener()</code> again using
	 * the same listener object, but with <code>useCapture</code> set to
	 * <code>false</code>, you have two separate listeners: one that listens
	 * during the capture phase and another that listens during the target and
	 * bubbling phases. </p>
	 *
	 * <p>You cannot register an event listener for only the target phase or the
	 * bubbling phase. Those phases are coupled during registration because
	 * bubbling applies only to the ancestors of the target node.</p>
	 *
	 * <p>If you no longer need an event listener, remove it by calling
	 * <code>removeEventListener()</code>, or memory problems could result. Event
	 * listeners are not automatically removed from memory because the garbage
	 * collector does not remove the listener as long as the dispatching object
	 * exists(unless the <code>useWeakReference</code> parameter is set to
	 * <code>true</code>).</p>
	 *
	 * <p>Copying an EventDispatcher instance does not copy the event listeners
	 * attached to it.(If your newly created node needs an event listener, you
	 * must attach the listener after creating the node.) However, if you move an
	 * EventDispatcher instance, the event listeners attached to it move along
	 * with it.</p>
	 *
	 * <p>If the event listener is being registered on a node while an event is
	 * being processed on this node, the event listener is not triggered during
	 * the current phase but can be triggered during a later phase in the event
	 * flow, such as the bubbling phase.</p>
	 *
	 * <p>If an event listener is removed from a node while an event is being
	 * processed on the node, it is still triggered by the current actions. After
	 * it is removed, the event listener is never invoked again(unless
	 * registered again for future processing). </p>
	 * 
	 * @param type             The type of event.
	 * @param useCapture       Determines whether the listener works in the
	 *                         capture phase or the target and bubbling phases.
	 *                         If <code>useCapture</code> is set to
	 *                         <code>true</code>, the listener processes the
	 *                         event only during the capture phase and not in the
	 *                         target or bubbling phase. If
	 *                         <code>useCapture</code> is <code>false</code>, the
	 *                         listener processes the event only during the
	 *                         target or bubbling phase. To listen for the event
	 *                         in all three phases, call
	 *                         <code>addEventListener</code> twice, once with
	 *                         <code>useCapture</code> set to <code>true</code>,
	 *                         then again with <code>useCapture</code> set to
	 *                         <code>false</code>.
	 * @param priority         The priority level of the event listener. The
	 *                         priority is designated by a signed 32-bit integer.
	 *                         The higher the number, the higher the priority.
	 *                         All listeners with priority <i>n</i> are processed
	 *                         before listeners of priority <i>n</i>-1. If two or
	 *                         more listeners share the same priority, they are
	 *                         processed in the order in which they were added.
	 *                         The default priority is 0.
	 * @param useWeakReference Determines whether the reference to the listener
	 *                         is strong or weak. A strong reference(the
	 *                         default) prevents your listener from being
	 *                         garbage-collected. A weak reference does not.
	 *
	 *                         <p>Class-level member functions are not subject to
	 *                         garbage collection, so you can set
	 *                         <code>useWeakReference</code> to <code>true</code>
	 *                         for class-level member functions without
	 *                         subjecting them to garbage collection. If you set
	 *                         <code>useWeakReference</code> to <code>true</code>
	 *                         for a listener that is a nested inner function,
	 *                         the function will be garbage-collected and no
	 *                         longer persistent. If you create references to the
	 *                         inner function(save it in another variable) then
	 *                         it is not garbage-collected and stays
	 *                         persistent.</p>
	 * @throws ArgumentError The <code>listener</code> specified is not a
	 *                       function.]]></haxe_doc>
		</addEventListener>
		<new public="1" set="method">
			<f a="?target">
				<c path="flash.events.IEventDispatcher"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Aggregates an instance of the EventDispatcher class.
	 *
	 * <p>The EventDispatcher class is generally used as a base class, which
	 * means that most developers do not need to use this constructor function.
	 * However, advanced developers who are implementing the IEventDispatcher
	 * interface need to use this constructor. If you are unable to extend the
	 * EventDispatcher class and must instead implement the IEventDispatcher
	 * interface, use this constructor to aggregate an instance of the
	 * EventDispatcher class.</p>
	 * 
	 * @param target The target object for events dispatched to the
	 *               EventDispatcher object. This parameter is used when the
	 *               EventDispatcher instance is aggregated by a class that
	 *               implements IEventDispatcher; it is necessary so that the
	 *               containing object can be the target for events. Do not use
	 *               this parameter in simple cases in which a class extends
	 *               EventDispatcher.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The EventDispatcher class is the base class for all classes that dispatch
 * events. The EventDispatcher class implements the IEventDispatcher interface
 * and is the base class for the DisplayObject class. The EventDispatcher
 * class allows any object on the display list to be an event target and as
 * such, to use the methods of the IEventDispatcher interface.
 *
 * <p>Event targets are an important part of the Flash<sup>®</sup> Player and
 * Adobe<sup>®</sup> AIR<sup>®</sup> event model. The event target serves as
 * the focal point for how events flow through the display list hierarchy.
 * When an event such as a mouse click or a keypress occurs, Flash Player or
 * the AIR application dispatches an event object into the event flow from the
 * root of the display list. The event object then makes its way through the
 * display list until it reaches the event target, at which point it begins
 * its return trip through the display list. This round-trip journey to the
 * event target is conceptually divided into three phases: the capture phase
 * comprises the journey from the root to the last node before the event
 * target's node, the target phase comprises only the event target node, and
 * the bubbling phase comprises any subsequent nodes encountered on the return
 * trip to the root of the display list.</p>
 *
 * <p>In general, the easiest way for a user-defined class to gain event
 * dispatching capabilities is to extend EventDispatcher. If this is
 * impossible(that is, if the class is already extending another class), you
 * can instead implement the IEventDispatcher interface, create an
 * EventDispatcher member, and write simple hooks to route calls into the
 * aggregated EventDispatcher.</p>
 * 
 * @event activate   [broadcast event] Dispatched when the Flash Player or AIR
 *                   application gains operating system focus and becomes
 *                   active. This event is a broadcast event, which means that
 *                   it is dispatched by all EventDispatcher objects with a
 *                   listener registered for this event. For more information
 *                   about broadcast events, see the DisplayObject class.
 * @event deactivate [broadcast event] Dispatched when the Flash Player or AIR
 *                   application operating loses system focus and is becoming
 *                   inactive. This event is a broadcast event, which means
 *                   that it is dispatched by all EventDispatcher objects with
 *                   a listener registered for this event. For more
 *                   information about broadcast events, see the DisplayObject
 *                   class.]]></haxe_doc>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Converts a three-dimensional point of the three-dimensional display
	 * object's(local) coordinates to a two-dimensional point in the Stage
	 * (global) coordinates.
	 *
	 * <p>For example, you can only use two-dimensional coordinates(x,y) to draw
	 * with the <code>display.Graphics</code> methods. To draw a
	 * three-dimensional object, you need to map the three-dimensional
	 * coordinates of a display object to two-dimensional coordinates. First,
	 * create an instance of the Vector3D class that holds the x-, y-, and z-
	 * coordinates of the three-dimensional display object. Then pass the
	 * Vector3D object to the <code>local3DToGlobal()</code> method as the
	 * <code>point3d</code> parameter. The method returns a two-dimensional Point
	 * object that can be used with the Graphics API to draw the
	 * three-dimensional object.</p>
	 * 
	 * @param point3d A Vector3D object containing either a three-dimensional
	 *                point or the coordinates of the three-dimensional display
	 *                object.
	 * @return A two-dimensional point representing a three-dimensional point in
	 *         two-dimensional space.]]></haxe_doc>
		</localToGlobal>
		<hitTestPoint public="1" set="method">
			<f a="x:y:?shapeFlag">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Evaluates the display object to see if it overlaps or intersects with the
	 * point specified by the <code>x</code> and <code>y</code> parameters. The
	 * <code>x</code> and <code>y</code> parameters specify a point in the
	 * coordinate space of the Stage, not the display object container that
	 * contains the display object(unless that display object container is the
	 * Stage).
	 * 
	 * @param x         The <i>x</i> coordinate to test against this object.
	 * @param y         The <i>y</i> coordinate to test against this object.
	 * @param shapeFlag Whether to check against the actual pixels of the object
	 *                 (<code>true</code>) or the bounding box
	 *                 (<code>false</code>).
	 * @return <code>true</code> if the display object overlaps or intersects
	 *         with the specified point; <code>false</code> otherwise.]]></haxe_doc>
		</hitTestPoint>
		<hitTestObject public="1" set="method">
			<f a="obj">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Converts a two-dimensional point from the Stage(global) coordinates to a
	 * three-dimensional display object's(local) coordinates.
	 *
	 * <p>To use this method, first create an instance of the Point class. The x
	 * and y values that you assign to the Point object represent global
	 * coordinates because they are relative to the origin(0,0) of the main
	 * display area. Then pass the Point object to the
	 * <code>globalToLocal3D()</code> method as the <code>point</code> parameter.
	 * The method returns three-dimensional coordinates as a Vector3D object
	 * containing <code>x</code>, <code>y</code>, and <code>z</code> values that
	 * are relative to the origin of the three-dimensional display object.</p>
	 * 
	 * @param point A two dimensional Point object representing global x and y
	 *              coordinates.
	 * @return A Vector3D object with coordinates relative to the
	 *         three-dimensional display object.]]></haxe_doc>
		</hitTestObject>
		<globalToLocal public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Converts the <code>point</code> object from the Stage(global) coordinates
	 * to the display object's(local) coordinates.
	 *
	 * <p>To use this method, first create an instance of the Point class. The
	 * <i>x</i> and <i>y</i> values that you assign represent global coordinates
	 * because they relate to the origin(0,0) of the main display area. Then
	 * pass the Point instance as the parameter to the
	 * <code>globalToLocal()</code> method. The method returns a new Point object
	 * with <i>x</i> and <i>y</i> values that relate to the origin of the display
	 * object instead of the origin of the Stage.</p>
	 * 
	 * @param point An object created with the Point class. The Point object
	 *              specifies the <i>x</i> and <i>y</i> coordinates as
	 *              properties.
	 * @return A Point object with coordinates relative to the display object.]]></haxe_doc>
		</globalToLocal>
		<getRect public="1" set="method">
			<f a="targetCoordinateSpace">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Returns a rectangle that defines the boundary of the display object, based
	 * on the coordinate system defined by the <code>targetCoordinateSpace</code>
	 * parameter, excluding any strokes on shapes. The values that the
	 * <code>getRect()</code> method returns are the same or smaller than those
	 * returned by the <code>getBounds()</code> method.
	 *
	 * <p><b>Note:</b> Use <code>localToGlobal()</code> and
	 * <code>globalToLocal()</code> methods to convert the display object's local
	 * coordinates to Stage coordinates, or Stage coordinates to local
	 * coordinates, respectively.</p>
	 * 
	 * @param targetCoordinateSpace The display object that defines the
	 *                              coordinate system to use.
	 * @return The rectangle that defines the area of the display object relative
	 *         to the <code>targetCoordinateSpace</code> object's coordinate
	 *         system.]]></haxe_doc>
		</getRect>
		<getBounds public="1" set="method">
			<f a="targetCoordinateSpace">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Indicates the z coordinate position along the z-axis of the DisplayObject
	 * instance relative to the 3D parent container. The z property is used for
	 * 3D coordinates, not screen or pixel coordinates.
	 *
	 * <p>When you set a <code>z</code> property for a display object to
	 * something other than the default value of <code>0</code>, a corresponding
	 * Matrix3D object is automatically created. for adjusting a display object's
	 * position and orientation in three dimensions. When working with the
	 * z-axis, the existing behavior of x and y properties changes from screen or
	 * pixel coordinates to positions relative to the 3D parent container.</p>
	 *
	 * <p>For example, a child of the <code>_root</code> at position x = 100, y =
	 * 100, z = 200 is not drawn at pixel location(100,100). The child is drawn
	 * wherever the 3D projection calculation puts it. The calculation is:</p>
	 *
	 * <p><code>(x~~cameraFocalLength/cameraRelativeZPosition,
	 * y~~cameraFocalLength/cameraRelativeZPosition)</code></p>]]></haxe_doc>
		</getBounds>
		<y public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the <i>y</i> coordinate of the DisplayObject instance relative
	 * to the local coordinates of the parent DisplayObjectContainer. If the
	 * object is inside a DisplayObjectContainer that has transformations, it is
	 * in the local coordinate system of the enclosing DisplayObjectContainer.
	 * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
	 * DisplayObjectContainer's children inherit a coordinate system that is
	 * rotated 90° counterclockwise. The object's coordinates refer to the
	 * registration point position.]]></haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the <i>x</i> coordinate of the DisplayObject instance relative
	 * to the local coordinates of the parent DisplayObjectContainer. If the
	 * object is inside a DisplayObjectContainer that has transformations, it is
	 * in the local coordinate system of the enclosing DisplayObjectContainer.
	 * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
	 * DisplayObjectContainer's children inherit a coordinate system that is
	 * rotated 90° counterclockwise. The object's coordinates refer to the
	 * registration point position.]]></haxe_doc>
		</x>
		<width public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the width of the display object, in pixels. The width is
	 * calculated based on the bounds of the content of the display object. When
	 * you set the <code>width</code> property, the <code>scaleX</code> property
	 * is adjusted accordingly, as shown in the following code:
	 *
	 * <p>Except for TextField and Video objects, a display object with no
	 * content(such as an empty sprite) has a width of 0, even if you try to set
	 * <code>width</code> to a different value.</p>]]></haxe_doc>
		</width>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether or not the display object is visible. Display objects that are not
	 * visible are disabled. For example, if <code>visible=false</code> for an
	 * InteractiveObject instance, it cannot be clicked.]]></haxe_doc>
		</visible>
		<transform public="1">
			<c path="flash.geom.Transform"/>
			<haxe_doc><![CDATA[* An object with properties pertaining to a display object's matrix, color
	 * transform, and pixel bounds. The specific properties  -  matrix,
	 * colorTransform, and three read-only properties
	 * (<code>concatenatedMatrix</code>, <code>concatenatedColorTransform</code>,
	 * and <code>pixelBounds</code>)  -  are described in the entry for the
	 * Transform class.
	 *
	 * <p>Each of the transform object's properties is itself an object. This
	 * concept is important because the only way to set new values for the matrix
	 * or colorTransform objects is to create a new object and copy that object
	 * into the transform.matrix or transform.colorTransform property.</p>
	 *
	 * <p>For example, to increase the <code>tx</code> value of a display
	 * object's matrix, you must make a copy of the entire matrix object, then
	 * copy the new object into the matrix property of the transform object:</p>
	 * <pre xml:space="preserve"><code> var myMatrix:Matrix =
	 * myDisplayObject.transform.matrix; myMatrix.tx += 10;
	 * myDisplayObject.transform.matrix = myMatrix; </code></pre>
	 *
	 * <p>You cannot directly set the <code>tx</code> property. The following
	 * code has no effect on <code>myDisplayObject</code>: </p>
	 * <pre xml:space="preserve"><code> myDisplayObject.transform.matrix.tx +=
	 * 10; </code></pre>
	 *
	 * <p>You can also copy an entire transform object and assign it to another
	 * display object's transform property. For example, the following code
	 * copies the entire transform object from <code>myOldDisplayObj</code> to
	 * <code>myNewDisplayObj</code>:</p>
	 * <code>myNewDisplayObj.transform = myOldDisplayObj.transform;</code>
	 *
	 * <p>The resulting display object, <code>myNewDisplayObj</code>, now has the
	 * same values for its matrix, color transform, and pixel bounds as the old
	 * display object, <code>myOldDisplayObj</code>.</p>
	 *
	 * <p>Note that AIR for TV devices use hardware acceleration, if it is
	 * available, for color transforms.</p>]]></haxe_doc>
		</transform>
		<stage public="1" set="null">
			<c path="flash.display.Stage"/>
			<haxe_doc><![CDATA[* The Stage of the display object. A Flash runtime application has only one
	 * Stage object. For example, you can create and load multiple display
	 * objects into the display list, and the <code>stage</code> property of each
	 * display object refers to the same Stage object(even if the display object
	 * belongs to a loaded SWF file).
	 *
	 * <p>If a display object is not added to the display list, its
	 * <code>stage</code> property is set to <code>null</code>.</p>]]></haxe_doc>
		</stage>
		<scrollRect public="1">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc><![CDATA[* Indicates the depth scale(percentage) of an object as applied from the
	 * registration point of the object. The default registration point is(0,0).
	 * 1.0 is 100% scale.
	 *
	 * <p>Scaling the local coordinate system changes the <code>x</code>,
	 * <code>y</code> and <code>z</code> property values, which are defined in
	 * whole pixels. </p>]]></haxe_doc>
		</scrollRect>
		<scaleY public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the vertical scale(percentage) of an object as applied from the
	 * registration point of the object. The default registration point is(0,0).
	 * 1.0 is 100% scale.
	 *
	 * <p>Scaling the local coordinate system changes the <code>x</code> and
	 * <code>y</code> property values, which are defined in whole pixels. </p>]]></haxe_doc>
		</scaleY>
		<scaleX public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the horizontal scale(percentage) of the object as applied from
	 * the registration point. The default registration point is(0,0). 1.0
	 * equals 100% scale.
	 *
	 * <p>Scaling the local coordinate system changes the <code>x</code> and
	 * <code>y</code> property values, which are defined in whole pixels. </p>]]></haxe_doc>
		</scaleX>
		<scale9Grid public="1">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Indicates the x-axis rotation of the DisplayObject instance, in degrees,
	 * from its original orientation relative to the 3D parent container. Values
	 * from 0 to 180 represent clockwise rotation; values from 0 to -180
	 * represent counterclockwise rotation. Values outside this range are added
	 * to or subtracted from 360 to obtain a value within the range.</haxe_doc>
		</scale9Grid>
		<rotation public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the rotation of the DisplayObject instance, in degrees, from its
	 * original orientation. Values from 0 to 180 represent clockwise rotation;
	 * values from 0 to -180 represent counterclockwise rotation. Values outside
	 * this range are added to or subtracted from 360 to obtain a value within
	 * the range. For example, the statement <code>my_video.rotation = 450</code>
	 * is the same as <code> my_video.rotation = 90</code>.]]></haxe_doc>
		</rotation>
		<root public="1" set="null">
			<c path="flash.display.DisplayObject"/>
			<haxe_doc><![CDATA[* For a display object in a loaded SWF file, the <code>root</code> property
	 * is the top-most display object in the portion of the display list's tree
	 * structure represented by that SWF file. For a Bitmap object representing a
	 * loaded image file, the <code>root</code> property is the Bitmap object
	 * itself. For the instance of the main class of the first SWF file loaded,
	 * the <code>root</code> property is the display object itself. The
	 * <code>root</code> property of the Stage object is the Stage object itself.
	 * The <code>root</code> property is set to <code>null</code> for any display
	 * object that has not been added to the display list, unless it has been
	 * added to a display object container that is off the display list but that
	 * is a child of the top-most display object in a loaded SWF file.
	 *
	 * <p>For example, if you create a new Sprite object by calling the
	 * <code>Sprite()</code> constructor method, its <code>root</code> property
	 * is <code>null</code> until you add it to the display list(or to a display
	 * object container that is off the display list but that is a child of the
	 * top-most display object in a SWF file).</p>
	 *
	 * <p>For a loaded SWF file, even though the Loader object used to load the
	 * file may not be on the display list, the top-most display object in the
	 * SWF file has its <code>root</code> property set to itself. The Loader
	 * object does not have its <code>root</code> property set until it is added
	 * as a child of a display object for which the <code>root</code> property is
	 * set.</p>]]></haxe_doc>
		</root>
		<parent public="1" set="null">
			<c path="flash.display.DisplayObjectContainer"/>
			<haxe_doc><![CDATA[* Indicates the DisplayObjectContainer object that contains this display
	 * object. Use the <code>parent</code> property to specify a relative path to
	 * display objects that are above the current display object in the display
	 * list hierarchy.
	 *
	 * <p>You can use <code>parent</code> to move up multiple levels in the
	 * display list as in the following:</p>
	 * 
	 * @throws SecurityError The parent display object belongs to a security
	 *                       sandbox to which you do not have access. You can
	 *                       avoid this situation by having the parent movie call
	 *                       the <code>Security.allowDomain()</code> method.]]></haxe_doc>
		</parent>
		<opaqueBackground public="1">
			<t path="Null"><x path="Int"/></t>
			<haxe_doc><![CDATA[* Specifies whether the display object is opaque with a certain background
	 * color. A transparent bitmap contains alpha channel data and is drawn
	 * transparently. An opaque bitmap has no alpha channel(and renders faster
	 * than a transparent bitmap). If the bitmap is opaque, you specify its own
	 * background color to use.
	 *
	 * <p>If set to a number value, the surface is opaque(not transparent) with
	 * the RGB background color that the number specifies. If set to
	 * <code>null</code>(the default value), the display object has a
	 * transparent background.</p>
	 *
	 * <p>The <code>opaqueBackground</code> property is intended mainly for use
	 * with the <code>cacheAsBitmap</code> property, for rendering optimization.
	 * For display objects in which the <code>cacheAsBitmap</code> property is
	 * set to true, setting <code>opaqueBackground</code> can improve rendering
	 * performance.</p>
	 *
	 * <p>The opaque background region is <i>not</i> matched when calling the
	 * <code>hitTestPoint()</code> method with the <code>shapeFlag</code>
	 * parameter set to <code>true</code>.</p>
	 *
	 * <p>The opaque background region does not respond to mouse events.</p>]]></haxe_doc>
		</opaqueBackground>
		<name public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Indicates the instance name of the DisplayObject. The object can be
	 * identified in the child list of its parent display object container by
	 * calling the <code>getChildByName()</code> method of the display object
	 * container.
	 * 
	 * @throws IllegalOperationError If you are attempting to set this property
	 *                               on an object that was placed on the timeline
	 *                               in the Flash authoring tool.]]></haxe_doc>
		</name>
		<mouseY public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the y coordinate of the mouse or user input device position, in
	 * pixels.
	 *
	 * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y
	 * coordinate will reflect the non-rotated object.</p>]]></haxe_doc>
		</mouseY>
		<mouseX public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the x coordinate of the mouse or user input device position, in
	 * pixels.
	 *
	 * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x
	 * coordinate will reflect the non-rotated object.</p>]]></haxe_doc>
		</mouseX>
		<mask public="1">
			<c path="flash.display.DisplayObject"/>
			<haxe_doc><![CDATA[* The calling display object is masked by the specified <code>mask</code>
	 * object. To ensure that masking works when the Stage is scaled, the
	 * <code>mask</code> display object must be in an active part of the display
	 * list. The <code>mask</code> object itself is not drawn. Set
	 * <code>mask</code> to <code>null</code> to remove the mask.
	 *
	 * <p>To be able to scale a mask object, it must be on the display list. To
	 * be able to drag a mask Sprite object(by calling its
	 * <code>startDrag()</code> method), it must be on the display list. To call
	 * the <code>startDrag()</code> method for a mask sprite based on a
	 * <code>mouseDown</code> event being dispatched by the sprite, set the
	 * sprite's <code>buttonMode</code> property to <code>true</code>.</p>
	 *
	 * <p>When display objects are cached by setting the
	 * <code>cacheAsBitmap</code> property to <code>true</code> an the
	 * <code>cacheAsBitmapMatrix</code> property to a Matrix object, both the
	 * mask and the display object being masked must be part of the same cached
	 * bitmap. Thus, if the display object is cached, then the mask must be a
	 * child of the display object. If an ancestor of the display object on the
	 * display list is cached, then the mask must be a child of that ancestor or
	 * one of its descendents. If more than one ancestor of the masked object is
	 * cached, then the mask must be a descendent of the cached container closest
	 * to the masked object in the display list.</p>
	 *
	 * <p><b>Note:</b> A single <code>mask</code> object cannot be used to mask
	 * more than one calling display object. When the <code>mask</code> is
	 * assigned to a second display object, it is removed as the mask of the
	 * first object, and that object's <code>mask</code> property becomes
	 * <code>null</code>.</p>]]></haxe_doc>
		</mask>
		<loaderInfo public="1" set="null">
			<c path="flash.display.LoaderInfo"/>
			<haxe_doc><![CDATA[* Returns a LoaderInfo object containing information about loading the file
	 * to which this display object belongs. The <code>loaderInfo</code> property
	 * is defined only for the root display object of a SWF file or for a loaded
	 * Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
	 * <code>loaderInfo</code> object associated with the SWF file that contains
	 * a display object named <code>myDisplayObject</code>, use
	 * <code>myDisplayObject.root.loaderInfo</code>.
	 *
	 * <p>A large SWF file can monitor its download by calling
	 * <code>this.root.loaderInfo.addEventListener(Event.COMPLETE,
	 * func)</code>.</p>]]></haxe_doc>
		</loaderInfo>
		<height public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Indicates the height of the display object, in pixels. The height is
	 * calculated based on the bounds of the content of the display object. When
	 * you set the <code>height</code> property, the <code>scaleY</code> property
	 * is adjusted accordingly, as shown in the following code:
	 *
	 * <p>Except for TextField and Video objects, a display object with no
	 * content(such as an empty sprite) has a height of 0, even if you try to
	 * set <code>height</code> to a different value.</p>]]></haxe_doc>
		</height>
		<filters public="1">
			<c path="Array"><d/></c>
			<haxe_doc><![CDATA[* An indexed array that contains each filter object currently associated
	 * with the display object. The flash.filters package contains several
	 * classes that define specific filters you can use.
	 *
	 * <p>Filters can be applied in Flash Professional at design time, or at run
	 * time by using ActionScript code. To apply a filter by using ActionScript,
	 * you must make a temporary copy of the entire <code>filters</code> array,
	 * modify the temporary array, then assign the value of the temporary array
	 * back to the <code>filters</code> array. You cannot directly add a new
	 * filter object to the <code>filters</code> array.</p>
	 *
	 * <p>To add a filter by using ActionScript, perform the following steps
	 * (assume that the target display object is named
	 * <code>myDisplayObject</code>):</p>
	 *
	 * <ol>
	 *   <li>Create a new filter object by using the constructor method of your
	 * chosen filter class.</li>
	 *   <li>Assign the value of the <code>myDisplayObject.filters</code> array
	 * to a temporary array, such as one named <code>myFilters</code>.</li>
	 *   <li>Add the new filter object to the <code>myFilters</code> temporary
	 * array.</li>
	 *   <li>Assign the value of the temporary array to the
	 * <code>myDisplayObject.filters</code> array.</li>
	 * </ol>
	 *
	 * <p>If the <code>filters</code> array is undefined, you do not need to use
	 * a temporary array. Instead, you can directly assign an array literal that
	 * contains one or more filter objects that you create. The first example in
	 * the Examples section adds a drop shadow filter by using code that handles
	 * both defined and undefined <code>filters</code> arrays.</p>
	 *
	 * <p>To modify an existing filter object, you must use the technique of
	 * modifying a copy of the <code>filters</code> array:</p>
	 *
	 * <ol>
	 *   <li>Assign the value of the <code>filters</code> array to a temporary
	 * array, such as one named <code>myFilters</code>.</li>
	 *   <li>Modify the property by using the temporary array,
	 * <code>myFilters</code>. For example, to set the quality property of the
	 * first filter in the array, you could use the following code:
	 * <code>myFilters[0].quality = 1;</code></li>
	 *   <li>Assign the value of the temporary array to the <code>filters</code>
	 * array.</li>
	 * </ol>
	 *
	 * <p>At load time, if a display object has an associated filter, it is
	 * marked to cache itself as a transparent bitmap. From this point forward,
	 * as long as the display object has a valid filter list, the player caches
	 * the display object as a bitmap. This source bitmap is used as a source
	 * image for the filter effects. Each display object usually has two bitmaps:
	 * one with the original unfiltered source display object and another for the
	 * final image after filtering. The final image is used when rendering. As
	 * long as the display object does not change, the final image does not need
	 * updating.</p>
	 *
	 * <p>The flash.filters package includes classes for filters. For example, to
	 * create a DropShadow filter, you would write:</p>
	 * 
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	 *                       and the shader output type is not compatible with
	 *                       this operation(the shader must specify a
	 *                       <code>pixel4</code> output).
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	 *                       and the shader doesn't specify any image input or
	 *                       the first input is not an <code>image4</code> input.
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	 *                       and the shader specifies an image input that isn't
	 *                       provided.
	 * @throws ArgumentError When <code>filters</code> includes a ShaderFilter, a
	 *                       ByteArray or Vector.<Number> instance as a shader
	 *                       input, and the <code>width</code> and
	 *                       <code>height</code> properties aren't specified for
	 *                       the ShaderInput object, or the specified values
	 *                       don't match the amount of data in the input data.
	 *                       See the <code>ShaderInput.input</code> property for
	 *                       more information.]]></haxe_doc>
		</filters>
		<cacheAsBitmap public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Sets a shader that is used for blending the foreground and background.
	 * When the <code>blendMode</code> property is set to
	 * <code>BlendMode.SHADER</code>, the specified Shader is used to create the
	 * blend mode output for the display object.
	 *
	 * <p>Setting the <code>blendShader</code> property of a display object to a
	 * Shader instance automatically sets the display object's
	 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. If the
	 * <code>blendShader</code> property is set(which sets the
	 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>), then
	 * the value of the <code>blendMode</code> property is changed, the blend
	 * mode can be reset to use the blend shader simply by setting the
	 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. The
	 * <code>blendShader</code> property does not need to be set again except to
	 * change the shader that's used for the blend mode.</p>
	 *
	 * <p>The Shader assigned to the <code>blendShader</code> property must
	 * specify at least two <code>image4</code> inputs. The inputs <b>do not</b>
	 * need to be specified in code using the associated ShaderInput objects'
	 * <code>input</code> properties. The background display object is
	 * automatically used as the first input(the input with <code>index</code>
	 * 0). The foreground display object is used as the second input(the input
	 * with <code>index</code> 1). A shader used as a blend shader can specify
	 * more than two inputs. In that case, any additional input must be specified
	 * by setting its ShaderInput instance's <code>input</code> property.</p>
	 *
	 * <p>When you assign a Shader instance to this property the shader is copied
	 * internally. The blend operation uses that internal copy, not a reference
	 * to the original shader. Any changes made to the shader, such as changing a
	 * parameter value, input, or bytecode, are not applied to the copied shader
	 * that's used for the blend mode.</p>
	 * 
	 * @throws ArgumentError When the shader output type is not compatible with
	 *                       this operation(the shader must specify a
	 *                       <code>pixel4</code> output).
	 * @throws ArgumentError When the shader specifies fewer than two image
	 *                       inputs or the first two inputs are not
	 *                       <code>image4</code> inputs.
	 * @throws ArgumentError When the shader specifies an image input that isn't
	 *                       provided.
	 * @throws ArgumentError When a ByteArray or Vector.<Number> instance is used
	 *                       as an input and the <code>width</code> and
	 *                       <code>height</code> properties aren't specified for
	 *                       the ShaderInput, or the specified values don't match
	 *                       the amount of data in the input object. See the
	 *                       <code>ShaderInput.input</code> property for more
	 *                       information.]]></haxe_doc>
		</cacheAsBitmap>
		<blendMode public="1">
			<e path="flash.display.BlendMode"/>
			<haxe_doc><![CDATA[* A value from the BlendMode class that specifies which blend mode to use. A
	 * bitmap can be drawn internally in two ways. If you have a blend mode
	 * enabled or an external clipping mask, the bitmap is drawn by adding a
	 * bitmap-filled square shape to the vector render. If you attempt to set
	 * this property to an invalid value, Flash runtimes set the value to
	 * <code>BlendMode.NORMAL</code>.
	 *
	 * <p>The <code>blendMode</code> property affects each pixel of the display
	 * object. Each pixel is composed of three constituent colors(red, green,
	 * and blue), and each constituent color has a value between 0x00 and 0xFF.
	 * Flash Player or Adobe AIR compares each constituent color of one pixel in
	 * the movie clip with the corresponding color of the pixel in the
	 * background. For example, if <code>blendMode</code> is set to
	 * <code>BlendMode.LIGHTEN</code>, Flash Player or Adobe AIR compares the red
	 * value of the display object with the red value of the background, and uses
	 * the lighter of the two as the value for the red component of the displayed
	 * color.</p>
	 *
	 * <p>The following table describes the <code>blendMode</code> settings. The
	 * BlendMode class defines string values you can use. The illustrations in
	 * the table show <code>blendMode</code> values applied to a circular display
	 * object(2) superimposed on another display object(1).</p>]]></haxe_doc>
		</blendMode>
		<alpha public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The current accessibility options for this display object. If you modify
	 * the <code>accessibilityProperties</code> property or any of the fields
	 * within <code>accessibilityProperties</code>, you must call the
	 * <code>Accessibility.updateProperties()</code> method to make your changes
	 * take effect.
	 *
	 * <p><b>Note</b>: For an object created in the Flash authoring environment,
	 * the value of <code>accessibilityProperties</code> is prepopulated with any
	 * information you entered in the Accessibility panel for that object.</p>]]></haxe_doc>
		</alpha>
		<haxe_doc><![CDATA[* The DisplayObject class is the base class for all objects that can be
 * placed on the display list. The display list manages all objects displayed
 * in flash. Use the DisplayObjectContainer class to arrange the
 * display objects in the display list. DisplayObjectContainer objects can
 * have child display objects, while other display objects, such as Shape and
 * TextField objects, are "leaf" nodes that have only parents and siblings, no
 * children.
 *
 * <p>The DisplayObject class supports basic functionality like the <i>x</i>
 * and <i>y</i> position of an object, as well as more advanced properties of
 * the object such as its transformation matrix. </p>
 *
 * <p>DisplayObject is an abstract base class; therefore, you cannot call
 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
 * <code>ArgumentError</code> exception. </p>
 *
 * <p>All display objects inherit from the DisplayObject class.</p>
 *
 * <p>The DisplayObject class itself does not include any APIs for rendering
 * content onscreen. For that reason, if you want create a custom subclass of
 * the DisplayObject class, you will want to extend one of its subclasses that
 * do have APIs for rendering content onscreen, such as the Shape, Sprite,
 * Bitmap, SimpleButton, TextField, or MovieClip class.</p>
 *
 * <p>The DisplayObject class contains several broadcast events. Normally, the
 * target of any particular event is a specific DisplayObject instance. For
 * example, the target of an <code>added</code> event is the specific
 * DisplayObject instance that was added to the display list. Having a single
 * target restricts the placement of event listeners to that target and in
 * some cases the target's ancestors on the display list. With broadcast
 * events, however, the target is not a specific DisplayObject instance, but
 * rather all DisplayObject instances, including those that are not on the
 * display list. This means that you can add a listener to any DisplayObject
 * instance to listen for broadcast events. In addition to the broadcast
 * events listed in the DisplayObject class's Events table, the DisplayObject
 * class also inherits two broadcast events from the EventDispatcher class:
 * <code>activate</code> and <code>deactivate</code>.</p>
 *
 * <p>Some properties previously used in the ActionScript 1.0 and 2.0
 * MovieClip, TextField, and Button classes(such as <code>_alpha</code>,
 * <code>_height</code>, <code>_name</code>, <code>_width</code>,
 * <code>_x</code>, <code>_y</code>, and others) have equivalents in the
 * ActionScript 3.0 DisplayObject class that are renamed so that they no
 * longer begin with the underscore(_) character.</p>
 *
 * <p>For more information, see the "Display Programming" chapter of the
 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
 * 
 * @event added            Dispatched when a display object is added to the
 *                         display list. The following methods trigger this
 *                         event:
 *                         <code>DisplayObjectContainer.addChild()</code>,
 *                         <code>DisplayObjectContainer.addChildAt()</code>.
 * @event addedToStage     Dispatched when a display object is added to the on
 *                         stage display list, either directly or through the
 *                         addition of a sub tree in which the display object
 *                         is contained. The following methods trigger this
 *                         event:
 *                         <code>DisplayObjectContainer.addChild()</code>,
 *                         <code>DisplayObjectContainer.addChildAt()</code>.
 * @event enterFrame       [broadcast event] Dispatched when the playhead is
 *                         entering a new frame. If the playhead is not
 *                         moving, or if there is only one frame, this event
 *                         is dispatched continuously in conjunction with the
 *                         frame rate. This event is a broadcast event, which
 *                         means that it is dispatched by all display objects
 *                         with a listener registered for this event.
 * @event exitFrame        [broadcast event] Dispatched when the playhead is
 *                         exiting the current frame. All frame scripts have
 *                         been run. If the playhead is not moving, or if
 *                         there is only one frame, this event is dispatched
 *                         continuously in conjunction with the frame rate.
 *                         This event is a broadcast event, which means that
 *                         it is dispatched by all display objects with a
 *                         listener registered for this event.
 * @event frameConstructed [broadcast event] Dispatched after the constructors
 *                         of frame display objects have run but before frame
 *                         scripts have run. If the playhead is not moving, or
 *                         if there is only one frame, this event is
 *                         dispatched continuously in conjunction with the
 *                         frame rate. This event is a broadcast event, which
 *                         means that it is dispatched by all display objects
 *                         with a listener registered for this event.
 * @event removed          Dispatched when a display object is about to be
 *                         removed from the display list. Two methods of the
 *                         DisplayObjectContainer class generate this event:
 *                         <code>removeChild()</code> and
 *                         <code>removeChildAt()</code>.
 *
 *                         <p>The following methods of a
 *                         DisplayObjectContainer object also generate this
 *                         event if an object must be removed to make room for
 *                         the new object: <code>addChild()</code>,
 *                         <code>addChildAt()</code>, and
 *                         <code>setChildIndex()</code>. </p>
 * @event removedFromStage Dispatched when a display object is about to be
 *                         removed from the display list, either directly or
 *                         through the removal of a sub tree in which the
 *                         display object is contained. Two methods of the
 *                         DisplayObjectContainer class generate this event:
 *                         <code>removeChild()</code> and
 *                         <code>removeChildAt()</code>.
 *
 *                         <p>The following methods of a
 *                         DisplayObjectContainer object also generate this
 *                         event if an object must be removed to make room for
 *                         the new object: <code>addChild()</code>,
 *                         <code>addChildAt()</code>, and
 *                         <code>setChildIndex()</code>. </p>
 * @event render           [broadcast event] Dispatched when the display list
 *                         is about to be updated and rendered. This event
 *                         provides the last opportunity for objects listening
 *                         for this event to make changes before the display
 *                         list is rendered. You must call the
 *                         <code>invalidate()</code> method of the Stage
 *                         object each time you want a <code>render</code>
 *                         event to be dispatched. <code>Render</code> events
 *                         are dispatched to an object only if there is mutual
 *                         trust between it and the object that called
 *                         <code>Stage.invalidate()</code>. This event is a
 *                         broadcast event, which means that it is dispatched
 *                         by all display objects with a listener registered
 *                         for this event.
 *
 *                         <p><b>Note: </b>This event is not dispatched if the
 *                         display is not rendering. This is the case when the
 *                         content is either minimized or obscured. </p>]]></haxe_doc>
	</class>
	<class path="flash.display.Bitmap" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<smoothing public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether or not the bitmap is smoothed when scaled. If
	 * <code>true</code>, the bitmap is smoothed when scaled. If
	 * <code>false</code>, the bitmap is not smoothed when scaled.]]></haxe_doc>
		</smoothing>
		<pixelSnapping public="1">
			<e path="flash.display.PixelSnapping"/>
			<haxe_doc><![CDATA[* Controls whether or not the Bitmap object is snapped to the nearest pixel.
	 * This value is ignored in the native and HTML5 targets.
	 * The PixelSnapping class includes possible values:
	 * <ul>
	 *   <li><code>PixelSnapping.NEVER</code> - No pixel snapping occurs.</li>
	 *   <li><code>PixelSnapping.ALWAYS</code> - The image is always snapped to
	 * the nearest pixel, independent of transformation.</li>
	 *   <li><code>PixelSnapping.AUTO</code> - The image is snapped to the
	 * nearest pixel if it is drawn with no rotation or skew and it is drawn at a
	 * scale factor of 99.9% to 100.1%. If these conditions are satisfied, the
	 * bitmap image is drawn at 100% scale, snapped to the nearest pixel.
	 * When targeting Flash Player, this value allows the image to be drawn as fast 
	 * as possible using the internal vector renderer.</li>
	 * </ul>]]></haxe_doc>
		</pixelSnapping>
		<bitmapData public="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>* The BitmapData object being referenced.</haxe_doc>
		</bitmapData>
		<new public="1" set="method"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Bitmap class represents display objects that represent bitmap images.
 * These can be images that you load with the <code>flash.Assets</code> or 
 * <code>flash.display.Loader</code> classes, or they can be images that you 
 * create with the <code>Bitmap()</code> constructor.
 *
 * <p>The <code>Bitmap()</code> constructor allows you to create a Bitmap
 * object that contains a reference to a BitmapData object. After you create a
 * Bitmap object, use the <code>addChild()</code> or <code>addChildAt()</code>
 * method of the parent DisplayObjectContainer instance to place the bitmap on
 * the display list.</p>
 *
 * <p>A Bitmap object can share its BitmapData reference among several Bitmap
 * objects, independent of translation or rotation properties. Because you can
 * create multiple Bitmap objects that reference the same BitmapData object,
 * multiple display objects can use the same complex BitmapData object without
 * incurring the memory overhead of a BitmapData object for each display
 * object instance.</p>
 *
 * <p>A BitmapData object can be drawn to the screen by a Bitmap object in one
 * of two ways: by using the default hardware renderer with a single hardware surface, 
 * or by using the slower software renderer when 3D acceleration is not available.</p>
 * 
 * <p>If you would prefer to perform a batch rendering command, rather than using a
 * single surface for each Bitmap object, you can also draw to the screen using the
 * <code>drawTiles()</code> or <code>drawTriangles()</code> methods which are
 * available to <code>flash.display.Tilesheet</code> and <code>flash.display.Graphics
 * objects.</code></p>
 *
 * <p><b>Note:</b> The Bitmap class is not a subclass of the InteractiveObject
 * class, so it cannot dispatch mouse events. However, you can use the
 * <code>addEventListener()</code> method of the display object container that
 * contains the Bitmap object.</p>]]></haxe_doc>
	</class>
	<class path="flash.display.BitmapData" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method">
			<f a="?changeRect">
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Unlocks an image so that any objects that reference the BitmapData object,
	 * such as Bitmap objects, are updated when this BitmapData object changes.
	 * To improve performance, use this method along with the <code>lock()</code>
	 * method before and after numerous calls to the <code>setPixel()</code> or
	 * <code>setPixel32()</code> method.
	 * 
	 * @param changeRect The area of the BitmapData object that has changed. If
	 *                   you do not specify a value for this parameter, the
	 *                   entire area of the BitmapData object is considered
	 *                   changed.]]></haxe_doc>
		</unlock>
		<threshold public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="UInt"/>
			</f>
			<haxe_doc><![CDATA[* Tests pixel values in an image against a specified threshold and sets
	 * pixels that pass the test to new color values. Using the
	 * <code>threshold()</code> method, you can isolate and replace color ranges
	 * in an image and perform other logical operations on image pixels.
	 *
	 * <p>The <code>threshold()</code> method's test logic is as follows:</p>
	 *
	 * <ol>
	 *   <li>If <code>((pixelValue & mask) operation(threshold & mask))</code>,
	 * then set the pixel to <code>color</code>;</li>
	 *   <li>Otherwise, if <code>copySource == true</code>, then set the pixel to
	 * corresponding pixel value from <code>sourceBitmap</code>.</li>
	 * </ol>
	 *
	 * <p>The <code>operation</code> parameter specifies the comparison operator
	 * to use for the threshold test. For example, by using "==" as the
	 * <code>operation</code> parameter, you can isolate a specific color value
	 * in an image. Or by using <code>{operation: "<", mask: 0xFF000000,
	 * threshold: 0x7F000000, color: 0x00000000}</code>, you can set all
	 * destination pixels to be fully transparent when the source image pixel's
	 * alpha is less than 0x7F. You can use this technique for animated
	 * transitions and other effects.</p>
	 * 
	 * @param sourceBitmapData The input bitmap image to use. The source image
	 *                         can be a different BitmapData object or it can
	 *                         refer to the current BitmapData instance.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The point within the destination image(the
	 *                         current BitmapData instance) that corresponds to
	 *                         the upper-left corner of the source rectangle.
	 * @param operation        One of the following comparison operators, passed
	 *                         as a String: "<", "<=", ">", ">=", "==", "!="
	 * @param threshold        The value that each pixel is tested against to see
	 *                         if it meets or exceeds the threshhold.
	 * @param color            The color value that a pixel is set to if the
	 *                         threshold test succeeds. The default value is
	 *                         0x00000000.
	 * @param mask             The mask to use to isolate a color component.
	 * @param copySource       If the value is <code>true</code>, pixel values
	 *                         from the source image are copied to the
	 *                         destination when the threshold test fails. If the
	 *                         value is <code>false</code>, the source image is
	 *                         not copied when the threshold test fails.
	 * @return The number of pixels that were changed.
	 * @throws ArgumentError The operation string is not a valid operation
	 * @throws TypeError     The sourceBitmapData, sourceRect destPoint or
	 *                       operation are null.]]></haxe_doc>
		</threshold>
		<setVector public="1" set="method">
			<f a="rect:inputVector">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Converts a Vector into a rectangular region of pixel data. For each pixel,
	 * a Vector element is read and written into the BitmapData pixel. The data
	 * in the Vector is expected to be 32-bit ARGB pixel values.
	 * 
	 * @param rect Specifies the rectangular region of the BitmapData object.
	 * @throws RangeError The vector array is not large enough to read all the
	 *                    pixel data.</haxe_doc>
		</setVector>
		<setPixels public="1" set="method">
			<f a="rect:inputByteArray">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Converts a byte array into a rectangular region of pixel data. For each
	 * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
	 * the return value is written into the pixel. If the byte array ends before
	 * the full rectangle is written, the function returns. The data in the byte
	 * array is expected to be 32-bit ARGB pixel values. No seeking is performed
	 * on the byte array before or after the pixels are read.
	 * 
	 * @param rect           Specifies the rectangular region of the BitmapData
	 *                       object.
	 * @param inputByteArray A ByteArray object that consists of 32-bit
	 *                       unmultiplied pixel values to be used in the
	 *                       rectangular region.
	 * @throws EOFError  The <code>inputByteArray</code> object does not include
	 *                   enough data to fill the area of the <code>rect</code>
	 *                   rectangle. The method fills as many pixels as possible
	 *                   before throwing the exception.
	 * @throws TypeError The rect or inputByteArray are null.]]></haxe_doc>
		</setPixels>
		<setPixel32 public="1" set="method">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sets the color and alpha transparency values of a single pixel of a
	 * BitmapData object. This method is similar to the <code>setPixel()</code>
	 * method; the main difference is that the <code>setPixel32()</code> method
	 * takes an ARGB color value that contains alpha channel information.
	 *
	 * <p>All pixels in a BitmapData object are stored as premultiplied color
	 * values. A premultiplied image pixel has the red, green, and blue color
	 * channel values already multiplied by the alpha data. For example, if the
	 * alpha value is 0, the values for the RGB channels are also 0, independent
	 * of their unmultiplied values. This loss of data can cause some problems
	 * when you perform operations. All BitmapData methods take and return
	 * unmultiplied values. The internal pixel representation is converted from
	 * premultiplied to unmultiplied before it is returned as a value. During a
	 * set operation, the pixel value is premultiplied before the raw image pixel
	 * is set.</p>
	 *
	 * <p><b>Note:</b> To increase performance, when you use the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	 * call the <code>lock()</code> method before you call the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	 * the <code>unlock()</code> method when you have made all pixel changes.
	 * This process prevents objects that reference this BitmapData instance from
	 * updating until you finish making the pixel changes.</p>
	 * 
	 * @param x     The <i>x</i> position of the pixel whose value changes.
	 * @param y     The <i>y</i> position of the pixel whose value changes.
	 * @param color The resulting ARGB color for the pixel. If the bitmap is
	 *              opaque(not transparent), the alpha transparency portion of
	 *              this color value is ignored.]]></haxe_doc>
		</setPixel32>
		<setPixel public="1" set="method">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sets a single pixel of a BitmapData object. The current alpha channel
	 * value of the image pixel is preserved during this operation. The value of
	 * the RGB color parameter is treated as an unmultiplied color value.
	 *
	 * <p><b>Note:</b> To increase performance, when you use the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	 * call the <code>lock()</code> method before you call the
	 * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	 * the <code>unlock()</code> method when you have made all pixel changes.
	 * This process prevents objects that reference this BitmapData instance from
	 * updating until you finish making the pixel changes.</p>
	 * 
	 * @param x     The <i>x</i> position of the pixel whose value changes.
	 * @param y     The <i>y</i> position of the pixel whose value changes.
	 * @param color The resulting RGB color for the pixel.]]></haxe_doc>
		</setPixel>
		<scroll public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Performs a pixel dissolve either from a source image to a destination
	 * image or by using the same image. Flash runtimes use a
	 * <code>randomSeed</code> value to generate a random pixel dissolve. The
	 * return value of the function must be passed in on subsequent calls to
	 * continue the pixel dissolve until it is finished.
	 *
	 * <p>If the source image does not equal the destination image, pixels are
	 * copied from the source to the destination by using all of the properties.
	 * This process allows dissolving from a blank image into a fully populated
	 * image.</p>
	 *
	 * <p>If the source and destination images are equal, pixels are filled with
	 * the <code>color</code> parameter. This process allows dissolving away from
	 * a fully populated image. In this mode, the destination <code>point</code>
	 * parameter is ignored.</p>
	 * 
	 * @param sourceBitmapData The input bitmap image to use. The source image
	 *                         can be a different BitmapData object, or it can
	 *                         refer to the current BitmapData instance.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The point within the destination image(the
	 *                         current BitmapData instance) that corresponds to
	 *                         the upper-left corner of the source rectangle.
	 * @param randomSeed       The random seed to use to start the pixel
	 *                         dissolve.
	 * @param numPixels        The default is 1/30 of the source area(width x
	 *                         height).
	 * @param fillColor        An ARGB color value that you use to fill pixels
	 *                         whose source value equals its destination value.
	 * @return The new random seed value to use for subsequent calls.
	 * @throws TypeError The sourceBitmapData, sourceRect or destPoint are null.
	 * @throws TypeError The numPixels value is negative]]></haxe_doc>
		</scroll>
		<perlinNoise public="1" set="method">
			<f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
				<x path="Float"/>
				<x path="Float"/>
				<x path="UInt"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="Array"><c path="flash.geom.Point"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remaps the color channel values in an image that has up to four arrays of
	 * color palette data, one for each channel.
	 *
	 * <p>Flash runtimes use the following steps to generate the resulting
	 * image:</p>
	 *
	 * <ol>
	 *   <li>After the red, green, blue, and alpha values are computed, they are
	 * added together using standard 32-bit-integer arithmetic. </li>
	 *   <li>The red, green, blue, and alpha channel values of each pixel are
	 * extracted into separate 0 to 255 values. These values are used to look up
	 * new color values in the appropriate array: <code>redArray</code>,
	 * <code>greenArray</code>, <code>blueArray</code>, and
	 * <code>alphaArray</code>. Each of these four arrays should contain 256
	 * values. </li>
	 *   <li>After all four of the new channel values are retrieved, they are
	 * combined into a standard ARGB value that is applied to the pixel.</li>
	 * </ol>
	 *
	 * <p>Cross-channel effects can be supported with this method. Each input
	 * array can contain full 32-bit values, and no shifting occurs when the
	 * values are added together. This routine does not support per-channel
	 * clamping. </p>
	 *
	 * <p>If no array is specified for a channel, the color channel is copied
	 * from the source image to the destination image.</p>
	 *
	 * <p>You can use this method for a variety of effects such as general
	 * palette mapping(taking one channel and converting it to a false color
	 * image). You can also use this method for a variety of advanced color
	 * manipulation algorithms, such as gamma, curves, levels, and
	 * quantizing.</p>
	 * 
	 * @param sourceBitmapData The input bitmap image to use. The source image
	 *                         can be a different BitmapData object, or it can
	 *                         refer to the current BitmapData instance.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The point within the destination image(the
	 *                         current BitmapData object) that corresponds to the
	 *                         upper-left corner of the source rectangle.
	 * @throws TypeError The sourceBitmapData, sourceRect or destPoint are null.]]></haxe_doc>
		</perlinNoise>
		<noise public="1" set="method">
			<f a="randomSeed:?low:?high:?channelOptions:?grayScale">
				<x path="Int"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Performs per-channel blending from a source image to a destination image.
	 * For each channel and each pixel, a new value is computed based on the
	 * channel values of the source and destination pixels. For example, in the
	 * red channel, the new value is computed as follows(where
	 * <code>redSrc</code> is the red channel value for a pixel in the source
	 * image and <code>redDest</code> is the red channel value at the
	 * corresponding pixel of the destination image):
	 *
	 * <p> <code> new redDest = [(redSrc * redMultiplier) + (redDest * (256 -
	 * redMultiplier))] / 256; </code> </p>
	 *
	 * <p>The <code>redMultiplier</code>, <code>greenMultiplier</code>,
	 * <code>blueMultiplier</code>, and <code>alphaMultiplier</code> values are
	 * the multipliers used for each color channel. Use a hexadecimal value
	 * ranging from <code>0</code> to <code>0x100</code>(256) where
	 * <code>0</code> specifies the full value from the destination is used in
	 * the result, <code>0x100</code> specifies the full value from the source is
	 * used, and numbers in between specify a blend is used(such as
	 * <code>0x80</code> for 50%).</p>
	 * 
	 * @param sourceBitmapData The input bitmap image to use. The source image
	 *                         can be a different BitmapData object, or it can
	 *                         refer to the current BitmapData object.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The point within the destination image(the
	 *                         current BitmapData instance) that corresponds to
	 *                         the upper-left corner of the source rectangle.
	 * @param redMultiplier    A hexadecimal uint value by which to multiply the
	 *                         red channel value.
	 * @param greenMultiplier  A hexadecimal uint value by which to multiply the
	 *                         green channel value.
	 * @param blueMultiplier   A hexadecimal uint value by which to multiply the
	 *                         blue channel value.
	 * @param alphaMultiplier  A hexadecimal uint value by which to multiply the
	 *                         alpha transparency value.
	 * @throws TypeError The sourceBitmapData, sourceRect or destPoint are null.]]></haxe_doc>
		</noise>
		<lock public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Computes a 256-value binary number histogram of a BitmapData object. This
	 * method returns a Vector object containing four Vector.<Number> instances
	 * (four Vector objects that contain Number objects). The four Vector
	 * instances represent the red, green, blue and alpha components in order.
	 * Each Vector instance contains 256 values that represent the population
	 * count of an individual component value, from 0 to 255.
	 * 
	 * @param hRect The area of the BitmapData object to use.]]></haxe_doc>
		</lock>
		<getVector public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.Vector"><x path="UInt"/></c>
			</f>
			<haxe_doc>* Generates a vector array from a rectangular region of pixel data. Returns
	 * a Vector object of unsigned integers(a 32-bit unmultiplied pixel value)
	 * for the specified rectangle.
	 * 
	 * @param rect A rectangular area in the current BitmapData object.
	 * @return A Vector representing the given Rectangle.
	 * @throws TypeError The rect is null.</haxe_doc>
		</getVector>
		<getPixels public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<haxe_doc>* Generates a byte array from a rectangular region of pixel data. Writes an
	 * unsigned integer(a 32-bit unmultiplied pixel value) for each pixel into
	 * the byte array.
	 * 
	 * @param rect A rectangular area in the current BitmapData object.
	 * @return A ByteArray representing the pixels in the given Rectangle.
	 * @throws TypeError The rect is null.</haxe_doc>
		</getPixels>
		<getPixel32 public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
			</f>
			<haxe_doc><![CDATA[* Returns an ARGB color value that contains alpha channel data and RGB data.
	 * This method is similar to the <code>getPixel()</code> method, which
	 * returns an RGB color without alpha channel data.
	 *
	 * <p>All pixels in a BitmapData object are stored as premultiplied color
	 * values. A premultiplied image pixel has the red, green, and blue color
	 * channel values already multiplied by the alpha data. For example, if the
	 * alpha value is 0, the values for the RGB channels are also 0, independent
	 * of their unmultiplied values. This loss of data can cause some problems
	 * when you perform operations. All BitmapData methods take and return
	 * unmultiplied values. The internal pixel representation is converted from
	 * premultiplied to unmultiplied before it is returned as a value. During a
	 * set operation, the pixel value is premultiplied before the raw image pixel
	 * is set.</p>
	 * 
	 * @param x The <i>x</i> position of the pixel.
	 * @param y The <i>y</i> position of the pixel.
	 * @return A number representing an ARGB pixel value. If the(<i>x</i>,
	 *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
	 *         returned.]]></haxe_doc>
		</getPixel32>
		<getPixel public="1" set="method">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
			</f>
			<haxe_doc><![CDATA[* Returns an integer that represents an RGB pixel value from a BitmapData
	 * object at a specific point(<i>x</i>, <i>y</i>). The
	 * <code>getPixel()</code> method returns an unmultiplied pixel value. No
	 * alpha information is returned.
	 *
	 * <p>All pixels in a BitmapData object are stored as premultiplied color
	 * values. A premultiplied image pixel has the red, green, and blue color
	 * channel values already multiplied by the alpha data. For example, if the
	 * alpha value is 0, the values for the RGB channels are also 0, independent
	 * of their unmultiplied values. This loss of data can cause some problems
	 * when you perform operations. All BitmapData methods take and return
	 * unmultiplied values. The internal pixel representation is converted from
	 * premultiplied to unmultiplied before it is returned as a value. During a
	 * set operation, the pixel value is premultiplied before the raw image pixel
	 * is set.</p>
	 * 
	 * @param x The <i>x</i> position of the pixel.
	 * @param y The <i>y</i> position of the pixel.
	 * @return A number that represents an RGB pixel value. If the(<i>x</i>,
	 *         <i>y</i>) coordinates are outside the bounds of the image, the
	 *         method returns 0.]]></haxe_doc>
		</getPixel>
		<getColorBoundsRect public="1" set="method">
			<f a="mask:color:?findColor">
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Determines a rectangular region that either fully encloses all pixels of a
	 * specified color within the bitmap image(if the <code>findColor</code>
	 * parameter is set to <code>true</code>) or fully encloses all pixels that
	 * do not include the specified color(if the <code>findColor</code>
	 * parameter is set to <code>false</code>).
	 *
	 * <p>For example, if you have a source image and you want to determine the
	 * rectangle of the image that contains a nonzero alpha channel, pass
	 * <code>{mask: 0xFF000000, color: 0x00000000}</code> as parameters. If the
	 * <code>findColor</code> parameter is set to <code>true</code>, the entire
	 * image is searched for the bounds of pixels for which <code>(value & mask)
	 * == color</code>(where <code>value</code> is the color value of the
	 * pixel). If the <code>findColor</code> parameter is set to
	 * <code>false</code>, the entire image is searched for the bounds of pixels
	 * for which <code>(value & mask) != color</code>(where <code>value</code>
	 * is the color value of the pixel). To determine white space around an
	 * image, pass <code>{mask: 0xFFFFFFFF, color: 0xFFFFFFFF}</code> to find the
	 * bounds of nonwhite pixels.</p>
	 * 
	 * @param mask      A hexadecimal value, specifying the bits of the ARGB
	 *                  color to consider. The color value is combined with this
	 *                  hexadecimal value, by using the <code>&</code>(bitwise
	 *                  AND) operator.
	 * @param color     A hexadecimal value, specifying the ARGB color to match
	 *                 (if <code>findColor</code> is set to <code>true</code>)
	 *                  or <i>not</i> to match(if <code>findColor</code> is set
	 *                  to <code>false</code>).
	 * @param findColor If the value is set to <code>true</code>, returns the
	 *                  bounds of a color value in an image. If the value is set
	 *                  to <code>false</code>, returns the bounds of where this
	 *                  color doesn't exist in an image.
	 * @return The region of the image that is the specified color.]]></haxe_doc>
		</getColorBoundsRect>
		<generateFilterRect public="1" set="method">
			<f a="sourceRect:filter">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.filters.BitmapFilter"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Determines the destination rectangle that the <code>applyFilter()</code>
	 * method call affects, given a BitmapData object, a source rectangle, and a
	 * filter object.
	 *
	 * <p>For example, a blur filter normally affects an area larger than the
	 * size of the original image. A 100 x 200 pixel image that is being filtered
	 * by a default BlurFilter instance, where <code>blurX = blurY = 4</code>
	 * generates a destination rectangle of <code>(-2,-2,104,204)</code>. The
	 * <code>generateFilterRect()</code> method lets you find out the size of
	 * this destination rectangle in advance so that you can size the destination
	 * image appropriately before you perform a filter operation.</p>
	 *
	 * <p>Some filters clip their destination rectangle based on the source image
	 * size. For example, an inner <code>DropShadow</code> does not generate a
	 * larger result than its source image. In this API, the BitmapData object is
	 * used as the source bounds and not the source <code>rect</code>
	 * parameter.</p>
	 * 
	 * @param sourceRect A rectangle defining the area of the source image to use
	 *                   as input.
	 * @param filter     A filter object that you use to calculate the
	 *                   destination rectangle.
	 * @return A destination rectangle computed by using an image, the
	 *         <code>sourceRect</code> parameter, and a filter.
	 * @throws TypeError The sourceRect or filter are null.]]></haxe_doc>
		</generateFilterRect>
		<floodFill public="1" set="method">
			<f a="x:y:color">
				<x path="Int"/>
				<x path="Int"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Performs a flood fill operation on an image starting at an(<i>x</i>,
	 * <i>y</i>) coordinate and filling with a certain color. The
	 * <code>floodFill()</code> method is similar to the paint bucket tool in
	 * various paint programs. The color is an ARGB color that contains alpha
	 * information and color information.
	 * 
	 * @param x     The <i>x</i> coordinate of the image.
	 * @param y     The <i>y</i> coordinate of the image.
	 * @param color The ARGB color to use as a fill.]]></haxe_doc>
		</floodFill>
		<fillRect public="1" set="method">
			<f a="rect:color">
				<c path="flash.geom.Rectangle"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fills a rectangular area of pixels with a specified ARGB color.
	 * 
	 * @param rect  The rectangular area to fill.
	 * @param color The ARGB color value that fills the area. ARGB colors are
	 *              often specified in hexadecimal format; for example,
	 *              0xFF336699.
	 * @throws TypeError The rect is null.</haxe_doc>
		</fillRect>
		<draw public="1" set="method">
			<f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
				<c path="flash.display.IBitmapDrawable"/>
				<c path="flash.geom.Matrix"/>
				<c path="flash.geom.ColorTransform"/>
				<e path="flash.display.BlendMode"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws the <code>source</code> display object onto the bitmap image, using
	 * the NME software renderer. You can specify <code>matrix</code>,
	 * <code>colorTransform</code>, <code>blendMode</code>, and a destination
	 * <code>clipRect</code> parameter to control how the rendering performs.
	 * Optionally, you can specify whether the bitmap should be smoothed when
	 * scaled(this works only if the source object is a BitmapData object).
	 *
	 * <p>The source display object does not use any of its applied
	 * transformations for this call. It is treated as it exists in the library
	 * or file, with no matrix transform, no color transform, and no blend mode.
	 * To draw a display object(such as a movie clip) by using its own transform
	 * properties, you can copy its <code>transform</code> property object to the
	 * <code>transform</code> property of the Bitmap object that uses the
	 * BitmapData object.</p>
	 * 
	 * @param source         The display object or BitmapData object to draw to
	 *                       the BitmapData object.(The DisplayObject and
	 *                       BitmapData classes implement the IBitmapDrawable
	 *                       interface.)
	 * @param matrix         A Matrix object used to scale, rotate, or translate
	 *                       the coordinates of the bitmap. If you do not want to
	 *                       apply a matrix transformation to the image, set this
	 *                       parameter to an identity matrix, created with the
	 *                       default <code>new Matrix()</code> constructor, or
	 *                       pass a <code>null</code> value.
	 * @param colorTransform A ColorTransform object that you use to adjust the
	 *                       color values of the bitmap. If no object is
	 *                       supplied, the bitmap image's colors are not
	 *                       transformed. If you must pass this parameter but you
	 *                       do not want to transform the image, set this
	 *                       parameter to a ColorTransform object created with
	 *                       the default <code>new ColorTransform()</code>
	 *                       constructor.
	 * @param blendMode      A string value, from the flash.display.BlendMode
	 *                       class, specifying the blend mode to be applied to
	 *                       the resulting bitmap.
	 * @param clipRect       A Rectangle object that defines the area of the
	 *                       source object to draw. If you do not supply this
	 *                       value, no clipping occurs and the entire source
	 *                       object is drawn.
	 * @param smoothing      A Boolean value that determines whether a BitmapData
	 *                       object is smoothed when scaled or rotated, due to a
	 *                       scaling or rotation in the <code>matrix</code>
	 *                       parameter. The <code>smoothing</code> parameter only
	 *                       applies if the <code>source</code> parameter is a
	 *                       BitmapData object. With <code>smoothing</code> set
	 *                       to <code>false</code>, the rotated or scaled
	 *                       BitmapData image can appear pixelated or jagged. For
	 *                       example, the following two images use the same
	 *                       BitmapData object for the <code>source</code>
	 *                       parameter, but the <code>smoothing</code> parameter
	 *                       is set to <code>true</code> on the left and
	 *                       <code>false</code> on the right:
	 *
	 *                       <p>Drawing a bitmap with <code>smoothing</code> set
	 *                       to <code>true</code> takes longer than doing so with
	 *                       <code>smoothing</code> set to
	 *                       <code>false</code>.</p>
	 * @throws ArgumentError The <code>source</code> parameter is not a
	 *                       BitmapData or DisplayObject object.
	 * @throws ArgumentError The source is null or not a valid IBitmapDrawable
	 *                       object.
	 * @throws SecurityError The <code>source</code> object and(in the case of a
	 *                       Sprite or MovieClip object) all of its child objects
	 *                       do not come from the same domain as the caller, or
	 *                       are not in a content that is accessible to the
	 *                       caller by having called the
	 *                       <code>Security.allowDomain()</code> method. This
	 *                       restriction does not apply to AIR content in the
	 *                       application security sandbox.]]></haxe_doc>
		</draw>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Frees memory that is used to store the BitmapData object.
	 *
	 * <p>When the <code>dispose()</code> method is called on an image, the width
	 * and height of the image are set to 0. All subsequent calls to methods or
	 * properties of this BitmapData instance fail, and an exception is thrown.
	 * </p>
	 *
	 * <p><code>BitmapData.dispose()</code> releases the memory occupied by the
	 * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	 * memory). After using <code>BitmapData.dispose()</code>, the BitmapData
	 * object is no longer usable and an exception may be thrown if
	 * you call functions on the BitmapData object. However,
	 * <code>BitmapData.dispose()</code> does not garbage collect the BitmapData
	 * object(approximately 128 bytes); the memory occupied by the actual
	 * BitmapData object is released at the time the BitmapData object is
	 * collected by the garbage collector.</p>
	 *]]></haxe_doc>
		</dispose>
		<copyPixels public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Provides a fast routine to perform pixel manipulation between images with
	 * no stretching, rotation, or color effects. This method copies a
	 * rectangular area of a source image to a rectangular area of the same size
	 * at the destination point of the destination BitmapData object.
	 *
	 * <p>If you include the <code>alphaBitmap</code> and <code>alphaPoint</code>
	 * parameters, you can use a secondary image as an alpha source for the
	 * source image. If the source image has alpha data, both sets of alpha data
	 * are used to composite pixels from the source image to the destination
	 * image. The <code>alphaPoint</code> parameter is the point in the alpha
	 * image that corresponds to the upper-left corner of the source rectangle.
	 * Any pixels outside the intersection of the source image and alpha image
	 * are not copied to the destination image.</p>
	 *
	 * <p>The <code>mergeAlpha</code> property controls whether or not the alpha
	 * channel is used when a transparent image is copied onto another
	 * transparent image. To copy pixels with the alpha channel data, set the
	 * <code>mergeAlpha</code> property to <code>true</code>. By default, the
	 * <code>mergeAlpha</code> property is <code>false</code>.</p>
	 * 
	 * @param sourceBitmapData The input bitmap image from which to copy pixels.
	 *                         The source image can be a different BitmapData
	 *                         instance, or it can refer to the current
	 *                         BitmapData instance.
	 * @param sourceRect       A rectangle that defines the area of the source
	 *                         image to use as input.
	 * @param destPoint        The destination point that represents the
	 *                         upper-left corner of the rectangular area where
	 *                         the new pixels are placed.
	 * @param alphaBitmapData  A secondary, alpha BitmapData object source.
	 * @param alphaPoint       The point in the alpha BitmapData object source
	 *                         that corresponds to the upper-left corner of the
	 *                         <code>sourceRect</code> parameter.
	 * @param mergeAlpha       To use the alpha channel, set the value to
	 *                         <code>true</code>. To copy pixels with no alpha
	 *                         channel, set the value to <code>false</code>.
	 * @throws TypeError The sourceBitmapData, sourceRect, destPoint are null.]]></haxe_doc>
		</copyPixels>
		<copyChannel public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="UInt"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Compares two BitmapData objects. If the two BitmapData objects have the
	 * same dimensions(width and height), the method returns a new BitmapData
	 * object, in which each pixel is the "difference" between the pixels in the
	 * two source objects:
	 * <ul>
	 *   <li>If two pixels are equal, the difference pixel is 0x00000000. </li>
	 *   <li>If two pixels have different RGB values(ignoring the alpha value),
	 * the difference pixel is 0xRRGGBB where RR/GG/BB are the individual
	 * difference values between red, green, and blue channels(the pixel value
	 * in the source object minus the pixel value in the
	 * <code>otherBitmapData</code> object). Alpha channel differences are
	 * ignored in this case. </li>
	 *   <li>If only the alpha channel value is different, the pixel value is
	 * 0x<i>ZZ</i>FFFFFF, where <i>ZZ</i> is the difference in the alpha values
	 * (the alpha value in the source object minus the alpha value in the
	 * <code>otherBitmapData</code> object).</li>
	 * </ul>
	 *
	 * <p>For example, consider the following two BitmapData objects:</p>
	 * 
	 * @param otherBitmapData The BitmapData object to compare with the source
	 *                        BitmapData object.
	 * @return If the two BitmapData objects have the same dimensions(width and
	 *         height), the method returns a new BitmapData object that has the
	 *         difference between the two objects(see the main discussion). If
	 *         the BitmapData objects are equivalent, the method returns the
	 *         number 0. If the widths of the BitmapData objects are not equal,
	 *         the method returns the number -3. If the heights of the BitmapData
	 *         objects are not equal, the method returns the number -4.
	 * @throws TypeError The otherBitmapData is null.]]></haxe_doc>
		</copyChannel>
		<colorTransform public="1" set="method">
			<f a="rect:colorTransform">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjusts the color values in a specified area of a bitmap image by using a <code>ColorTransform</code>
	 * object. If the rectangle matches the boundaries of the bitmap image, this method transforms the color 
	 * values of the entire image. 
	 * @param	rect		A Rectangle object that defines the area of the image in which the ColorTransform object is applied.
	 * @param	colorTransform		A ColorTransform object that describes the color transformation values to apply.]]></haxe_doc>
		</colorTransform>
		<clone public="1" set="method">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc>* Returns a new BitmapData object that is a clone of the original instance with an exact copy of the contained bitmap. 
	 * @return		A new BitmapData object that is identical to the original.</haxe_doc>
		</clone>
		<applyFilter public="1" set="method">
			<f a="sourceBitmapData:sourceRect:destPoint:filter">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flash.filters.BitmapFilter"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Takes a source image and a filter object and generates the filtered image. 
	 * 
	 * This method relies on the behavior of built-in filter objects, which determine the 
	 * destination rectangle that is affected by an input source rectangle.
	 * 
	 * After a filter is applied, the resulting image can be larger than the input image. 
	 * For example, if you use a BlurFilter class to blur a source rectangle of(50,50,100,100) 
	 * and a destination point of(10,10), the area that changes in the destination image is 
	 * larger than(10,10,60,60) because of the blurring. This happens internally during the 
	 * applyFilter() call.
	 * 
	 * If the <code>sourceRect</code> parameter of the sourceBitmapData parameter is an 
	 * interior region, such as(50,50,100,100) in a 200 x 200 image, the filter uses the source 
	 * pixels outside the <code>sourceRect</code> parameter to generate the destination rectangle.
	 * 
	 * If the BitmapData object and the object specified as the <code>sourceBitmapData</code> 
	 * parameter are the same object, the application uses a temporary copy of the object to 
	 * perform the filter. For best performance, avoid this situation.
	 * 
	 * @param	sourceBitmapData		The input bitmap image to use. The source image can be a different BitmapData object or it can refer to the current BitmapData instance.
	 * @param	sourceRect		A rectangle that defines the area of the source image to use as input.
	 * @param	destPoint		The point within the destination image(the current BitmapData instance) that corresponds to the upper-left corner of the source rectangle. 
	 * @param	filter		The filter object that you use to perform the filtering operation.]]></haxe_doc>
		</applyFilter>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the bitmap image in pixels.</haxe_doc>
		</width>
		<transparent public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Defines whether the bitmap image supports per-pixel transparency. You can
	 * set this value only when you construct a BitmapData object by passing in
	 * <code>true</code> for the <code>transparent</code> parameter of the
	 * constructor. Then, after you create a BitmapData object, you can check
	 * whether it supports per-pixel transparency by determining if the value of
	 * the <code>transparent</code> property is <code>true</code>.]]></haxe_doc>
		</transparent>
		<rect public="1" set="null">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* The rectangle that defines the size and location of the bitmap image. The
	 * top and left of the rectangle are 0; the width and height are equal to the
	 * width and height in pixels of the BitmapData object.</haxe_doc>
		</rect>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the bitmap image in pixels.</haxe_doc>
		</height>
		<new public="1" set="method">
			<f a="width:height:?transparent:?fillColor">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="UInt"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a BitmapData object with a specified width and height. If you specify a value for 
	 * the <code>fillColor</code> parameter, every pixel in the bitmap is set to that color. 
	 * 
	 * By default, the bitmap is created as transparent, unless you pass the value <code>false</code>
	 * for the transparent parameter. After you create an opaque bitmap, you cannot change it 
	 * to a transparent bitmap. Every pixel in an opaque bitmap uses only 24 bits of color channel 
	 * information. If you define the bitmap as transparent, every pixel uses 32 bits of color 
	 * channel information, including an alpha transparency channel.
	 * 
	 * @param	width		The width of the bitmap image in pixels. 
	 * @param	height		The height of the bitmap image in pixels. 
	 * @param	transparent		Specifies whether the bitmap image supports per-pixel transparency. The default value is <code>true</code>(transparent). To create a fully transparent bitmap, set the value of the <code>transparent</code> parameter to <code>true</code> and the value of the <code>fillColor</code> parameter to 0x00000000(or to 0). Setting the <code>transparent</code> property to <code>false</code> can result in minor improvements in rendering performance.
	 * @param	fillColor		A 32-bit ARGB color value that you use to fill the bitmap image area. The default value is 0xFFFFFFFF(solid white).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The BitmapData class lets you work with the data(pixels) of a Bitmap
 * object. You can use the methods of the BitmapData class to create
 * arbitrarily sized transparent or opaque bitmap images and manipulate them
 * in various ways at runtime. You can also access the BitmapData for a bitmap
 * image that you load with the <code>flash.Assets</code> or 
 * <code>flash.display.Loader</code> classes.
 *
 * <p>This class lets you separate bitmap rendering operations from the
 * internal display updating routines of flash. By manipulating a
 * BitmapData object directly, you can create complex images without incurring
 * the per-frame overhead of constantly redrawing the content from vector
 * data.</p>
 *
 * <p>The methods of the BitmapData class support effects that are not
 * available through the filters available to non-bitmap display objects.</p>
 *
 * <p>A BitmapData object contains an array of pixel data. This data can
 * represent either a fully opaque bitmap or a transparent bitmap that
 * contains alpha channel data. Either type of BitmapData object is stored as
 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
 * of a single pixel in the bitmap.</p>
 *
 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
 * 0 to 255) that describe the alpha transparency and the red, green, and blue
 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
 * represents the alpha channel value, followed by red, green, and blue.)</p>
 *
 * <p>The four channels(alpha, red, green, and blue) are represented as
 * numbers when you use them with the <code>BitmapData.copyChannel()</code>
 * method or the <code>DisplacementMapFilter.componentX</code> and
 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
 * are represented by the following constants in the BitmapDataChannel
 * class:</p>
 *
 * <ul>
 *   <li><code>BitmapDataChannel.ALPHA</code></li>
 *   <li><code>BitmapDataChannel.RED</code></li>
 *   <li><code>BitmapDataChannel.GREEN</code></li>
 *   <li><code>BitmapDataChannel.BLUE</code></li>
 * </ul>
 *
 * <p>You can attach BitmapData objects to a Bitmap object by using the
 * <code>bitmapData</code> property of the Bitmap object.</p>
 *
 * <p>You can use a BitmapData object to fill a Graphics object by using the
 * <code>Graphics.beginBitmapFill()</code> method.</p>
 * 
 * <p>You can also use a BitmapData object to perform batch tile rendering
 * using the <code>flash.display.Tilesheet</code> class.</p>
 *
 * <p>In Flash Player 10, the maximum size for a BitmapData object
 * is 8,191 pixels in width or height, and the total number of pixels cannot
 * exceed 16,777,215 pixels.(So, if a BitmapData object is 8,191 pixels wide,
 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation 
 * is 2,880 pixels in height and 2,880 in width.</p>]]></haxe_doc>
	</class>
	<class path="flash.display.BitmapDataChannel" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/BitmapDataChannel.hx" extern="1">
		<ALPHA public="1" get="inline" set="null" line="31" static="1">
			<x path="Int"/>
			<haxe_doc>* The alpha channel.</haxe_doc>
		</ALPHA>
		<BLUE public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc>* The blue channel.</haxe_doc>
		</BLUE>
		<GREEN public="1" get="inline" set="null" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>* The green channel.</haxe_doc>
		</GREEN>
		<RED public="1" get="inline" set="null" line="46" static="1">
			<x path="Int"/>
			<haxe_doc>* The red channel.</haxe_doc>
		</RED>
		<haxe_doc><![CDATA[* The BitmapDataChannel class is an enumeration of constant values that
 * indicate which channel to use: red, blue, green, or alpha transparency.
 *
 * <p>When you call some methods, you can use the bitwise OR operator
 * (<code>|</code>) to combine BitmapDataChannel constants to indicate
 * multiple color channels.</p>
 *
 * <p>The BitmapDataChannel constants are provided for use as values in the
 * following:</p>
 *
 * <ul>
 *   <li>The <code>sourceChannel</code> and <code>destChannel</code>
 * parameters of the <code>flash.display.BitmapData.copyChannel()</code>
 * method</li>
 *   <li>The <code>channelOptions</code> parameter of the
 * <code>flash.display.BitmapData.noise()</code> method</li>
 *   <li>The <code>flash.filters.DisplacementMapFilter.componentX</code> and
 * <code>flash.filters.DisplacementMapFilter.componentY</code> properties</li>
 * </ul>]]></haxe_doc>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/BlendMode.hx">
		<ADD><haxe_doc><![CDATA[* Adds the values of the constituent colors of the display object to the
	 * colors of its background, applying a ceiling of 0xFF. This setting is
	 * commonly used for animating a lightening dissolve between two objects.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
	 * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
	 * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>]]></haxe_doc></ADD>
		<ALPHA><haxe_doc><![CDATA[* Applies the alpha value of each pixel of the display object to the
	 * background. This requires the <code>blendMode</code> property of the
	 * parent display object be set to
	 * <code>flash.display.BlendMode.LAYER</code>.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></ALPHA>
		<DARKEN><haxe_doc><![CDATA[* Selects the darker of the constituent colors of the display object and the
	 * colors of the background(the colors with the smaller values). This
	 * setting is commonly used for superimposing type.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	 * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
	 * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></DARKEN>
		<DIFFERENCE><haxe_doc><![CDATA[* Compares the constituent colors of the display object with the colors of
	 * its background, and subtracts the darker of the values of the two
	 * constituent colors from the lighter value. This setting is commonly used
	 * for more vibrant colors.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	 * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
	 * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>]]></haxe_doc></DIFFERENCE>
		<ERASE><haxe_doc><![CDATA[* Erases the background based on the alpha value of the display object. This
	 * process requires that the <code>blendMode</code> property of the parent
	 * display object be set to <code>flash.display.BlendMode.LAYER</code>.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></ERASE>
		<HARDLIGHT><haxe_doc><![CDATA[* Adjusts the color of each pixel based on the darkness of the display
	 * object. If the display object is lighter than 50% gray, the display object
	 * and background colors are screened, which results in a lighter color. If
	 * the display object is darker than 50% gray, the colors are multiplied,
	 * which results in a darker color. This setting is commonly used for shading
	 * effects.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></HARDLIGHT>
		<INVERT><haxe_doc>* Inverts the background.</haxe_doc></INVERT>
		<LAYER><haxe_doc><![CDATA[* Forces the creation of a transparency group for the display object. This
	 * means that the display object is precomposed in a temporary buffer before
	 * it is processed further. The precomposition is done automatically if the
	 * display object is precached by means of bitmap caching or if the display
	 * object is a display object container that has at least one child object
	 * with a <code>blendMode</code> setting other than <code>"normal"</code>.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></LAYER>
		<LIGHTEN><haxe_doc><![CDATA[* Selects the lighter of the constituent colors of the display object and
	 * the colors of the background(the colors with the larger values). This
	 * setting is commonly used for superimposing type.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	 * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
	 * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></LIGHTEN>
		<MULTIPLY><haxe_doc><![CDATA[* Multiplies the values of the display object constituent colors by the
	 * constituent colors of the background color, and normalizes by dividing by
	 * 0xFF, resulting in darker colors. This setting is commonly used for
	 * shadows and depth effects.
	 *
	 * <p>For example, if a constituent color(such as red) of one pixel in the
	 * display object and the corresponding color of the pixel in the background
	 * both have the value 0x88, the multiplied result is 0x4840. Dividing by
	 * 0xFF yields a value of 0x48 for that constituent color, which is a darker
	 * shade than the color of the display object or the color of the
	 * background.</p>]]></haxe_doc></MULTIPLY>
		<NORMAL><haxe_doc>* The display object appears in front of the background. Pixel values of the
	 * display object override the pixel values of the background. Where the
	 * display object is transparent, the background is visible.</haxe_doc></NORMAL>
		<OVERLAY><haxe_doc><![CDATA[* Adjusts the color of each pixel based on the darkness of the background.
	 * If the background is lighter than 50% gray, the display object and
	 * background colors are screened, which results in a lighter color. If the
	 * background is darker than 50% gray, the colors are multiplied, which
	 * results in a darker color. This setting is commonly used for shading
	 * effects.
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></OVERLAY>
		<SCREEN><haxe_doc>* Multiplies the complement(inverse) of the display object color by the
	 * complement of the background color, resulting in a bleaching effect. This
	 * setting is commonly used for highlights or to remove black areas of the
	 * display object.</haxe_doc></SCREEN>
		<SHADER><haxe_doc><![CDATA[* Uses a shader to define the blend between objects.
	 *
	 * <p>Setting the <code>blendShader</code> property to a Shader instance
	 * automatically sets the display object's <code>blendMode</code> property to
	 * <code>BlendMode.SHADER</code>. If the <code>blendMode</code> property is
	 * set to <code>BlendMode.SHADER</code> without first setting the
	 * <code>blendShader</code> property, the <code>blendMode</code> property is
	 * set to <code>BlendMode.NORMAL</code> instead. If the
	 * <code>blendShader</code> property is set(which sets the
	 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>), then
	 * later the value of the <code>blendMode</code> property is changed, the
	 * blend mode can be reset to use the blend shader simply by setting the
	 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. The
	 * <code>blendShader</code> property does not need to be set again except to
	 * change the shader that's used to define the blend mode.</p>
	 *
	 * <p>Not supported under GPU rendering.</p>]]></haxe_doc></SHADER>
		<SUBTRACT><haxe_doc><![CDATA[* Subtracts the values of the constituent colors in the display object from
	 * the values of the background color, applying a floor of 0. This setting is
	 * commonly used for animating a darkening dissolve between two objects.
	 *
	 * <p>For example, if the display object has a pixel with an RGB value of
	 * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
	 * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
	 * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).</p>]]></haxe_doc></SUBTRACT>
		<haxe_doc><![CDATA[* A class that provides constant values for visual blend mode effects. These
 * constants are used in the following:
 * <ul>
 *   <li> The <code>blendMode</code> property of the
 * flash.display.DisplayObject class.</li>
 *   <li> The <code>blendMode</code> parameter of the <code>draw()</code>
 * method of the flash.display.BitmapData class</li>
 * </ul>]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/CapsStyle.hx">
		<ROUND><haxe_doc><![CDATA[* Used to specify round caps in the <code>caps</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method.]]></haxe_doc></ROUND>
		<NONE><haxe_doc><![CDATA[* Used to specify no caps in the <code>caps</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method.]]></haxe_doc></NONE>
		<SQUARE><haxe_doc><![CDATA[* Used to specify square caps in the <code>caps</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method.]]></haxe_doc></SQUARE>
		<haxe_doc><![CDATA[* The CapsStyle class is an enumeration of constant values that specify the
 * caps style to use in drawing lines. The constants are provided for use as
 * values in the <code>caps</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method. You can specify the
 * following three types of caps:]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.InteractiveObject" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<tabIndex public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Specifies the tab ordering of objects in a SWF file. The
	 * <code>tabIndex</code> property is -1 by default, meaning no tab index is
	 * set for the object.
	 *
	 * <p>If any currently displayed object in the SWF file contains a
	 * <code>tabIndex</code> property, automatic tab ordering is disabled, and
	 * the tab ordering is calculated from the <code>tabIndex</code> properties
	 * of objects in the SWF file. The custom tab ordering includes only objects
	 * that have <code>tabIndex</code> properties.</p>
	 *
	 * <p>The <code>tabIndex</code> property can be a non-negative integer. The
	 * objects are ordered according to their <code>tabIndex</code> properties,
	 * in ascending order. An object with a <code>tabIndex</code> value of 1
	 * precedes an object with a <code>tabIndex</code> value of 2. Do not use the
	 * same <code>tabIndex</code> value for multiple objects.</p>
	 *
	 * <p>The custom tab ordering that the <code>tabIndex</code> property defines
	 * is <i>flat</i>. This means that no attention is paid to the hierarchical
	 * relationships of objects in the SWF file. All objects in the SWF file with
	 * <code>tabIndex</code> properties are placed in the tab order, and the tab
	 * order is determined by the order of the <code>tabIndex</code> values. </p>
	 *
	 * <p><b>Note:</b> To set the tab order for TLFTextField instances, cast the
	 * display object child of the TLFTextField as an InteractiveObject, then set
	 * the <code>tabIndex</code> property. For example: <pre
	 * xml:space="preserve">
	 * InteractiveObject(tlfInstance.getChildAt(1)).tabIndex = 3; </pre> To
	 * reverse the tab order from the default setting for three instances of a
	 * TLFTextField object(<code>tlfInstance1</code>, <code>tlfInstance2</code>
	 * and <code>tlfInstance3</code>), use: <pre xml:space="preserve">
	 * InteractiveObject(tlfInstance1.getChildAt(1)).tabIndex = 3;
	 * InteractiveObject(tlfInstance2.getChildAt(1)).tabIndex = 2;
	 * InteractiveObject(tlfInstance3.getChildAt(1)).tabIndex = 1; </pre> </p>]]></haxe_doc>
		</tabIndex>
		<tabEnabled public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether this object is in the tab order. If this object is in
	 * the tab order, the value is <code>true</code>; otherwise, the value is
	 * <code>false</code>. By default, the value is <code>false</code>, except
	 * for the following:
	 * <ul>
	 *   <li>For a SimpleButton object, the value is <code>true</code>.</li>
	 *   <li>For a TextField object with <code>type = "input"</code>, the value
	 * is <code>true</code>.</li>
	 *   <li>For a Sprite object or MovieClip object with <code>buttonMode =
	 * true</code>, the value is <code>true</code>.</li>
	 * </ul>]]></haxe_doc>
		</tabEnabled>
		<mouseEnabled public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether this object receives mouse, or other user input,
	 * messages. The default value is <code>true</code>, which means that by
	 * default any InteractiveObject instance that is on the display list
	 * receives mouse events or other user input events. If
	 * <code>mouseEnabled</code> is set to <code>false</code>, the instance does
	 * not receive any mouse events(or other user input events like keyboard
	 * events). Any children of this instance on the display list are not
	 * affected. To change the <code>mouseEnabled</code> behavior for all
	 * children of an object on the display list, use
	 * <code>flash.display.DisplayObjectContainer.mouseChildren</code>.
	 *
	 * <p> No event is dispatched by setting this property. You must use the
	 * <code>addEventListener()</code> method to create interactive
	 * functionality.</p>]]></haxe_doc>
		</mouseEnabled>
		<focusRect public="1">
			<d/>
			<haxe_doc><![CDATA[* Specifies whether this object displays a focus rectangle. It can take one
	 * of three values: <code>true</code>, <code>false</code>, or
	 * <code>null</code>. Values of <code>true</code> and <code>false</code> work
	 * as expected, specifying whether or not the focus rectangle appears. A
	 * value of <code>null</code> indicates that this object obeys the
	 * <code>stageFocusRect</code> property of the Stage.]]></haxe_doc>
		</focusRect>
		<doubleClickEnabled public="1">
			<x path="Bool"/>
			<haxe_doc>* The current accessibility implementation(AccessibilityImplementation) for
	 * this InteractiveObject instance.</haxe_doc>
		</doubleClickEnabled>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Calling the <code>new InteractiveObject()</code> constructor throws an
	 * <code>ArgumentError</code> exception. You can, however, call constructors
	 * for the following subclasses of InteractiveObject:
	 * <ul>
	 *   <li><code>new SimpleButton()</code></li>
	 *   <li><code>new TextField()</code></li>
	 *   <li><code>new Loader()</code></li>
	 *   <li><code>new Sprite()</code></li>
	 *   <li><code>new MovieClip()</code></li>
	 * </ul>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The InteractiveObject class is the abstract base class for all display
 * objects with which the user can interact, using the mouse, keyboard, or
 * other user input device.
 *
 * <p>You cannot instantiate the InteractiveObject class directly. A call to
 * the <code>new InteractiveObject()</code> constructor throws an
 * <code>ArgumentError</code> exception.</p>
 *
 * <p>The InteractiveObject class itself does not include any APIs for
 * rendering content onscreen. To create a custom subclass of the
 * InteractiveObject class, extend one of the subclasses that do have APIs for
 * rendering content onscreen, such as the Sprite, SimpleButton, TextField, or
 * MovieClip classes.</p>
 * 
 * @event clear                  Dispatched when the user selects 'Clear'(or
 *                               'Delete') from the text context menu. This
 *                               event is dispatched to the object that
 *                               currently has focus. If the object that
 *                               currently has focus is a TextField, the
 *                               default behavior of this event is to cause
 *                               any currently selected text in the text field
 *                               to be deleted.
 * @event click                  Dispatched when a user presses and releases
 *                               the main button of the user's pointing device
 *                               over the same InteractiveObject. For a click
 *                               event to occur, it must always follow this
 *                               series of events in the order of occurrence:
 *                               mouseDown event, then mouseUp. The target
 *                               object must be identical for both of these
 *                               events; otherwise the <code>click</code>
 *                               event does not occur. Any number of other
 *                               mouse events can occur at any time between
 *                               the <code>mouseDown</code> or
 *                               <code>mouseUp</code> events; the
 *                               <code>click</code> event still occurs.
 * @event contextMenu            Dispatched when a user gesture triggers the
 *                               context menu associated with this interactive
 *                               object in an AIR application.
 * @event copy                   Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a copy operation or selects 'Copy' from
 *                               the text context menu. This event is
 *                               dispatched to the object that currently has
 *                               focus. If the object that currently has focus
 *                               is a TextField, the default behavior of this
 *                               event is to cause any currently selected text
 *                               in the text field to be copied to the
 *                               clipboard.
 * @event cut                    Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a cut operation or selects 'Cut' from the
 *                               text context menu. This event is dispatched
 *                               to the object that currently has focus. If
 *                               the object that currently has focus is a
 *                               TextField, the default behavior of this event
 *                               is to cause any currently selected text in
 *                               the text field to be cut to the clipboard.
 * @event doubleClick            Dispatched when a user presses and releases
 *                               the main button of a pointing device twice in
 *                               rapid succession over the same
 *                               InteractiveObject when that object's
 *                               <code>doubleClickEnabled</code> flag is set
 *                               to <code>true</code>. For a
 *                               <code>doubleClick</code> event to occur, it
 *                               must immediately follow the following series
 *                               of events: <code>mouseDown</code>,
 *                               <code>mouseUp</code>, <code>click</code>,
 *                               <code>mouseDown</code>, <code>mouseUp</code>.
 *                               All of these events must share the same
 *                               target as the <code>doubleClick</code> event.
 *                               The second click, represented by the second
 *                               <code>mouseDown</code> and
 *                               <code>mouseUp</code> events, must occur
 *                               within a specific period of time after the
 *                               <code>click</code> event. The allowable
 *                               length of this period varies by operating
 *                               system and can often be configured by the
 *                               user. If the target is a selectable text
 *                               field, the word under the pointer is selected
 *                               as the default behavior. If the target
 *                               InteractiveObject does not have its
 *                               <code>doubleClickEnabled</code> flag set to
 *                               <code>true</code> it receives two
 *                               <code>click</code> events.
 *
 *                               <p>The <code>doubleClickEnabled</code>
 *                               property defaults to <code>false</code>. </p>
 *
 *                               <p>The double-click text selection behavior
 *                               of a TextField object is not related to the
 *                               <code>doubleClick</code> event. Use
 *                               <code>TextField.doubleClickEnabled</code> to
 *                               control TextField selections.</p>
 * @event focusIn                Dispatched <i>after</i> a display object
 *                               gains focus. This situation happens when a
 *                               user highlights the object with a pointing
 *                               device or keyboard navigation. The recipient
 *                               of such focus is called the target object of
 *                               this event, while the corresponding
 *                               InteractiveObject instance that lost focus
 *                               because of this change is called the related
 *                               object. A reference to the related object is
 *                               stored in the receiving object's
 *                               <code>relatedObject</code> property. The
 *                               <code>shiftKey</code> property is not used.
 *                               This event follows the dispatch of the
 *                               previous object's <code>focusOut</code>
 *                               event.
 * @event focusOut               Dispatched <i>after</i> a display object
 *                               loses focus. This happens when a user
 *                               highlights a different object with a pointing
 *                               device or keyboard navigation. The object
 *                               that loses focus is called the target object
 *                               of this event, while the corresponding
 *                               InteractiveObject instance that receives
 *                               focus is called the related object. A
 *                               reference to the related object is stored in
 *                               the target object's
 *                               <code>relatedObject</code> property. The
 *                               <code>shiftKey</code> property is not used.
 *                               This event precedes the dispatch of the
 *                               <code>focusIn</code> event by the related
 *                               object.
 * @event gesturePan             Dispatched when the user moves a point of
 *                               contact over the InteractiveObject instance
 *                               on a touch-enabled device(such as moving a
 *                               finger from left to right over a display
 *                               object on a mobile phone or tablet with a
 *                               touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>mouseOver</code> event and as a
 *                               <code>touchOver</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>mouseOver</code> event or a
 *                               <code>touchOver</code> event or a
 *                               <code>gesturePan</code> event, or all if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gesturePan</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event gesturePressAndTap     Dispatched when the user creates a point of
 *                               contact with an InteractiveObject instance,
 *                               then taps on a touch-enabled device(such as
 *                               placing several fingers over a display object
 *                               to open a menu and then taps one finger to
 *                               select a menu item on a mobile phone or
 *                               tablet with a touch screen). Some devices
 *                               might also interpret this contact as a
 *                               combination of several mouse events, as well.
 *
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, and then provides
 *                               a secondary tap, the InteractiveObject
 *                               instance can dispatch a
 *                               <code>mouseOver</code> event and a
 *                               <code>click</code> event(among others) as
 *                               well as the <code>gesturePressAndTap</code>
 *                               event, or all if the current environment
 *                               supports it. Choose how you want to handle
 *                               the user interaction. Use the
 *                               flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gesturePressAndTap</code> event, you
 *                               can design your event handler to respond to
 *                               the specific needs of a touch-enabled
 *                               environment and provide users with a richer
 *                               touch-enabled experience. You can also handle
 *                               both events, separately, to provide a
 *                               different response for a touch event than a
 *                               mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact(the "push"). The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the secondary
 *                               point of contact(the "tap").</p>
 * @event gestureRotate          Dispatched when the user performs a rotation
 *                               gesture at a point of contact with an
 *                               InteractiveObject instance(such as touching
 *                               two fingers and rotating them over a display
 *                               object on a mobile phone or tablet with a
 *                               touch screen). Two-finger rotation is a
 *                               common rotation gesture, but each device and
 *                               operating system can have its own
 *                               requirements to indicate rotation. Some
 *                               devices might also interpret this contact as
 *                               a combination of several mouse events, as
 *                               well.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>mouseOver</code> event and a
 *                               <code>click</code> event(among others), in
 *                               addition to the <code>gestureRotate</code>
 *                               event, or all if the current environment
 *                               supports it. Choose how you want to handle
 *                               the user interaction. Use the
 *                               flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gestureRotate</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact. The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the point of
 *                               contact where the rotation gesture is
 *                               complete.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event gestureSwipe           Dispatched when the user performs a swipe
 *                               gesture at a point of contact with an
 *                               InteractiveObject instance(such as touching
 *                               three fingers to a screen and then moving
 *                               them in parallel over a display object on a
 *                               mobile phone or tablet with a touch screen).
 *                               Moving several fingers in parallel is a
 *                               common swipe gesture, but each device and
 *                               operating system can have its own
 *                               requirements for a swipe. Some devices might
 *                               also interpret this contact as a combination
 *                               of several mouse events, as well.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, and then moves the
 *                               fingers together, the InteractiveObject
 *                               instance can dispatch a <code>rollOver</code>
 *                               event and a <code>rollOut</code> event(among
 *                               others), in addition to the
 *                               <code>gestureSwipe</code> event, or all if
 *                               the current environment supports it. Choose
 *                               how you want to handle the user interaction.
 *                               If you choose to handle the
 *                               <code>rollOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gestureSwipe</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact. The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the point of
 *                               contact where the swipe gesture is
 *                               complete.</p>
 *
 *                               <p><b>Note:</b> While some devices using the
 *                               Mac OS operating system can interpret a
 *                               four-finger swipe, this API only supports a
 *                               three-finger swipe.</p>
 * @event gestureTwoFingerTap    Dispatched when the user presses two points
 *                               of contact over the same InteractiveObject
 *                               instance on a touch-enabled device(such as
 *                               presses and releases two fingers over a
 *                               display object on a mobile phone or tablet
 *                               with a touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>doubleClick</code> event.
 *
 *                               <p>Specifically, if a user taps two fingers
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>doubleClick</code> event or a
 *                               <code>gestureTwoFingerTap</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the flash.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>doubleClick</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>gestureTwoFingerTap</code> event, you
 *                               can design your event handler to respond to
 *                               the specific needs of a touch-enabled
 *                               environment and provide users with a richer
 *                               touch-enabled experience. You can also handle
 *                               both events, separately, to provide a
 *                               different response for a touch event than a
 *                               mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event gestureZoom            Dispatched when the user performs a zoom
 *                               gesture at a point of contact with an
 *                               InteractiveObject instance(such as touching
 *                               two fingers to a screen and then quickly
 *                               spreading the fingers apart over a display
 *                               object on a mobile phone or tablet with a
 *                               touch screen). Moving fingers apart is a
 *                               common zoom gesture, but each device and
 *                               operating system can have its own
 *                               requirements to indicate zoom. Some devices
 *                               might also interpret this contact as a
 *                               combination of several mouse events, as well.
 *
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, and then moves the
 *                               fingers apart, the InteractiveObject instance
 *                               can dispatch a <code>mouseOver</code> event
 *                               and a <code>click</code> event(among
 *                               others), in addition to the
 *                               <code>gestureZoom</code> event, or all if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>gestureZoom</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p>When handling the properties of the event
 *                               object, note that the <code>localX</code> and
 *                               <code>localY</code> properties are set to the
 *                               primary point of contact. The
 *                               <code>offsetX</code> and <code>offsetY</code>
 *                               properties are the distance to the point of
 *                               contact where the zoom gesture is
 *                               complete.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event imeStartComposition    This event is dispatched to any client app
 *                               that supports inline input with an IME
 * @event keyDown                Dispatched when the user presses a key.
 *                               Mappings between keys and specific characters
 *                               vary by device and operating system. This
 *                               event type is generated after such a mapping
 *                               occurs but before the processing of an input
 *                               method editor(IME). IMEs are used to enter
 *                               characters, such as Chinese ideographs, that
 *                               the standard QWERTY keyboard is ill-equipped
 *                               to produce. This event occurs before the
 *                               <code>keyUp</code> event.
 *
 *                               <p>In AIR, canceling this event prevents the
 *                               character from being entered into a text
 *                               field.</p>
 * @event keyFocusChange         Dispatched when the user attempts to change
 *                               focus by using keyboard navigation. The
 *                               default behavior of this event is to change
 *                               the focus and dispatch the corresponding
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events.
 *
 *                               <p>This event is dispatched to the object
 *                               that currently has focus. The related object
 *                               for this event is the InteractiveObject
 *                               instance that receives focus if you do not
 *                               prevent the default behavior. You can prevent
 *                               the change in focus by calling the
 *                               <code>preventDefault()</code> method in an
 *                               event listener that is properly registered
 *                               with the target object. Focus changes and
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events are dispatched
 *                               by default.</p>
 * @event keyUp                  Dispatched when the user releases a key.
 *                               Mappings between keys and specific characters
 *                               vary by device and operating system. This
 *                               event type is generated after such a mapping
 *                               occurs but before the processing of an input
 *                               method editor(IME). IMEs are used to enter
 *                               characters, such as Chinese ideographs, that
 *                               the standard QWERTY keyboard is ill-equipped
 *                               to produce. This event occurs after a
 *                               <code>keyDown</code> event and has the
 *                               following characteristics:
 * @event middleClick            Dispatched when a user presses and releases
 *                               the middle button of the user's pointing
 *                               device over the same InteractiveObject. For a
 *                               <code>middleClick</code> event to occur, it
 *                               must always follow this series of events in
 *                               the order of occurrence:
 *                               <code>middleMouseDown</code> event, then
 *                               <code>middleMouseUp</code>. The target object
 *                               must be identical for both of these events;
 *                               otherwise the <code>middleClick</code> event
 *                               does not occur. Any number of other mouse
 *                               events can occur at any time between the
 *                               <code>middleMouseDown</code> or
 *                               <code>middleMouseUp</code> events; the
 *                               <code>middleClick</code> event still occurs.
 * @event middleMouseDown        Dispatched when a user presses the middle
 *                               pointing device button over an
 *                               InteractiveObject instance.
 * @event middleMouseUp          Dispatched when a user releases the pointing
 *                               device button over an InteractiveObject
 *                               instance.
 * @event mouseDown              Dispatched when a user presses the pointing
 *                               device button over an InteractiveObject
 *                               instance. If the target is a SimpleButton
 *                               instance, the SimpleButton instance displays
 *                               the <code>downState</code> display object as
 *                               the default behavior. If the target is a
 *                               selectable text field, the text field begins
 *                               selection as the default behavior.
 * @event mouseFocusChange       Dispatched when the user attempts to change
 *                               focus by using a pointer device. The default
 *                               behavior of this event is to change the focus
 *                               and dispatch the corresponding
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events.
 *
 *                               <p>This event is dispatched to the object
 *                               that currently has focus. The related object
 *                               for this event is the InteractiveObject
 *                               instance that receives focus if you do not
 *                               prevent the default behavior. You can prevent
 *                               the change in focus by calling
 *                               <code>preventDefault()</code> in an event
 *                               listener that is properly registered with the
 *                               target object. The <code>shiftKey</code>
 *                               property is not used. Focus changes and
 *                               <code>focusIn</code> and
 *                               <code>focusOut</code> events are dispatched
 *                               by default.</p>
 * @event mouseMove              Dispatched when a user moves the pointing
 *                               device while it is over an InteractiveObject.
 *                               If the target is a text field that the user
 *                               is selecting, the selection is updated as the
 *                               default behavior.
 * @event mouseOut               Dispatched when the user moves a pointing
 *                               device away from an InteractiveObject
 *                               instance. The event target is the object
 *                               previously under the pointing device. The
 *                               <code>relatedObject</code> is the object the
 *                               pointing device has moved to. If the target
 *                               is a SimpleButton instance, the button
 *                               displays the <code>upState</code> display
 *                               object as the default behavior.
 *
 *                               <p>The <code>mouseOut</code> event is
 *                               dispatched each time the mouse leaves the
 *                               area of any child object of the display
 *                               object container, even if the mouse remains
 *                               over another child object of the display
 *                               object container. This is different behavior
 *                               than the purpose of the <code>rollOut</code>
 *                               event, which is to simplify the coding of
 *                               rollover behaviors for display object
 *                               containers with children. When the mouse
 *                               leaves the area of a display object or the
 *                               area of any of its children to go to an
 *                               object that is not one of its children, the
 *                               display object dispatches the
 *                               <code>rollOut</code> event.The
 *                               <code>rollOut</code> events are dispatched
 *                               consecutively up the parent chain of the
 *                               object, starting with the object and ending
 *                               with the highest parent that is neither the
 *                               root nor an ancestor of the
 *                               <code>relatedObject</code>.</p>
 * @event mouseOver              Dispatched when the user moves a pointing
 *                               device over an InteractiveObject instance.
 *                               The <code>relatedObject</code> is the object
 *                               that was previously under the pointing
 *                               device. If the target is a SimpleButton
 *                               instance, the object displays the
 *                               <code>overState</code> or
 *                               <code>upState</code> display object,
 *                               depending on whether the mouse button is
 *                               down, as the default behavior.
 *
 *                               <p>The <code>mouseOver</code> event is
 *                               dispatched each time the mouse enters the
 *                               area of any child object of the display
 *                               object container, even if the mouse was
 *                               already over another child object of the
 *                               display object container. This is different
 *                               behavior than the purpose of the
 *                               <code>rollOver</code> event, which is to
 *                               simplify the coding of rollout behaviors for
 *                               display object containers with children. When
 *                               the mouse enters the area of a display object
 *                               or the area of any of its children from an
 *                               object that is not one of its children, the
 *                               display object dispatches the
 *                               <code>rollOver</code> event. The
 *                               <code>rollOver</code> events are dispatched
 *                               consecutively down the parent chain of the
 *                               object, starting with the highest parent that
 *                               is neither the root nor an ancestor of the
 *                               <code>relatedObject</code> and ending with
 *                               the object.</p>
 * @event mouseUp                Dispatched when a user releases the pointing
 *                               device button over an InteractiveObject
 *                               instance. If the target is a SimpleButton
 *                               instance, the object displays the
 *                               <code>upState</code> display object. If the
 *                               target is a selectable text field, the text
 *                               field ends selection as the default behavior.
 * @event mouseWheel             Dispatched when a mouse wheel is spun over an
 *                               InteractiveObject instance. If the target is
 *                               a text field, the text scrolls as the default
 *                               behavior. Only available on Microsoft Windows
 *                               operating systems.
 * @event nativeDragComplete     Dispatched by the drag initiator
 *                               InteractiveObject when the user releases the
 *                               drag gesture.
 *
 *                               <p>The event's dropAction property indicates
 *                               the action set by the drag target object; a
 *                               value of "none"
 *                              (<code>DragActions.NONE</code>) indicates
 *                               that the drop was canceled or was not
 *                               accepted.</p>
 *
 *                               <p>The <code>nativeDragComplete</code> event
 *                               handler is a convenient place to update the
 *                               state of the initiating display object, for
 *                               example, by removing an item from a list(on
 *                               a drag action of "move"), or by changing the
 *                               visual properties.</p>
 * @event nativeDragDrop         Dispatched by the target InteractiveObject
 *                               when a dragged object is dropped on it and
 *                               the drop has been accepted with a call to
 *                               DragManager.acceptDragDrop().
 *
 *                               <p>Access the dropped data using the event
 *                               object <code>clipboard</code> property.</p>
 *
 *                               <p>The handler for this event should set the
 *                               <code>DragManager.dropAction</code> property
 *                               to provide feedback to the initiator object
 *                               about which drag action was taken. If no
 *                               value is set, the DragManager will select a
 *                               default value from the list of allowed
 *                               actions.</p>
 * @event nativeDragEnter        Dispatched by an InteractiveObject when a
 *                               drag gesture enters its boundary.
 *
 *                               <p>Handle either the
 *                               <code>nativeDragEnter</code> or
 *                               <code>nativeDragOver</code> events to allow
 *                               the display object to become the drop
 *                               target.</p>
 *
 *                               <p>To determine whether the dispatching
 *                               display object can accept the drop, check the
 *                               suitability of the data in
 *                               <code>clipboard</code> property of the event
 *                               object, and the allowed drag actions in the
 *                               <code>allowedActions</code> property.</p>
 * @event nativeDragExit         Dispatched by an InteractiveObject when a
 *                               drag gesture leaves its boundary.
 * @event nativeDragOver         Dispatched by an InteractiveObject
 *                               continually while a drag gesture remains
 *                               within its boundary.
 *
 *                               <p><code>nativeDragOver</code> events are
 *                               dispatched whenever the mouse is moved. On
 *                               Windows and Mac, they are also dispatched on
 *                               a short timer interval even when the mouse
 *                               has not moved.</p>
 *
 *                               <p>Handle either the
 *                               <code>nativeDragOver</code> or
 *                               <code>nativeDragEnter</code> events to allow
 *                               the display object to become the drop
 *                               target.</p>
 *
 *                               <p>To determine whether the dispatching
 *                               display object can accept the drop, check the
 *                               suitability of the data in
 *                               <code>clipboard</code> property of the event
 *                               object, and the allowed drag actions in the
 *                               <code>allowedActions</code> property.</p>
 * @event nativeDragStart        Dispatched at the beginning of a drag
 *                               operation by the InteractiveObject that is
 *                               specified as the drag initiator in the
 *                               DragManager.doDrag() call.
 * @event nativeDragUpdate       Dispatched during a drag operation by the
 *                               InteractiveObject that is specified as the
 *                               drag initiator in the DragManager.doDrag()
 *                               call.
 *
 *                               <p><code>nativeDragUpdate</code> events are
 *                               not dispatched on Linux.</p>
 * @event paste                  Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a paste operation or selects 'Paste' from
 *                               the text context menu. This event is
 *                               dispatched to the object that currently has
 *                               focus. If the object that currently has focus
 *                               is a TextField, the default behavior of this
 *                               event is to cause the contents of the
 *                               clipboard to be pasted into the text field at
 *                               the current insertion point replacing any
 *                               currently selected text in the text field.
 * @event rightClick             Dispatched when a user presses and releases
 *                               the right button of the user's pointing
 *                               device over the same InteractiveObject. For a
 *                               <code>rightClick</code> event to occur, it
 *                               must always follow this series of events in
 *                               the order of occurrence:
 *                               <code>rightMouseDown</code> event, then
 *                               <code>rightMouseUp</code>. The target object
 *                               must be identical for both of these events;
 *                               otherwise the <code>rightClick</code> event
 *                               does not occur. Any number of other mouse
 *                               events can occur at any time between the
 *                               <code>rightMouseDown</code> or
 *                               <code>rightMouseUp</code> events; the
 *                               <code>rightClick</code> event still occurs.
 * @event rightMouseDown         Dispatched when a user presses the pointing
 *                               device button over an InteractiveObject
 *                               instance.
 * @event rightMouseUp           Dispatched when a user releases the pointing
 *                               device button over an InteractiveObject
 *                               instance.
 * @event rollOut                Dispatched when the user moves a pointing
 *                               device away from an InteractiveObject
 *                               instance. The event target is the object
 *                               previously under the pointing device or a
 *                               parent of that object. The
 *                               <code>relatedObject</code> is the object that
 *                               the pointing device has moved to. The
 *                               <code>rollOut</code> events are dispatched
 *                               consecutively up the parent chain of the
 *                               object, starting with the object and ending
 *                               with the highest parent that is neither the
 *                               root nor an ancestor of the
 *                               <code>relatedObject</code>.
 *
 *                               <p>The purpose of the <code>rollOut</code>
 *                               event is to simplify the coding of rollover
 *                               behaviors for display object containers with
 *                               children. When the mouse leaves the area of a
 *                               display object or the area of any of its
 *                               children to go to an object that is not one
 *                               of its children, the display object
 *                               dispatches the <code>rollOut</code> event.
 *                               This is different behavior than that of the
 *                               <code>mouseOut</code> event, which is
 *                               dispatched each time the mouse leaves the
 *                               area of any child object of the display
 *                               object container, even if the mouse remains
 *                               over another child object of the display
 *                               object container.</p>
 * @event rollOver               Dispatched when the user moves a pointing
 *                               device over an InteractiveObject instance.
 *                               The event target is the object under the
 *                               pointing device or a parent of that object.
 *                               The <code>relatedObject</code> is the object
 *                               that was previously under the pointing
 *                               device. The <code>rollOver</code> events are
 *                               dispatched consecutively down the parent
 *                               chain of the object, starting with the
 *                               highest parent that is neither the root nor
 *                               an ancestor of the <code>relatedObject</code>
 *                               and ending with the object.
 *
 *                               <p>The purpose of the <code>rollOver</code>
 *                               event is to simplify the coding of rollout
 *                               behaviors for display object containers with
 *                               children. When the mouse enters the area of a
 *                               display object or the area of any of its
 *                               children from an object that is not one of
 *                               its children, the display object dispatches
 *                               the <code>rollOver</code> event. This is
 *                               different behavior than that of the
 *                               <code>mouseOver</code> event, which is
 *                               dispatched each time the mouse enters the
 *                               area of any child object of the display
 *                               object container, even if the mouse was
 *                               already over another child object of the
 *                               display object container. </p>
 * @event selectAll              Dispatched when the user activates the
 *                               platform-specific accelerator key combination
 *                               for a select all operation or selects 'Select
 *                               All' from the text context menu. This event
 *                               is dispatched to the object that currently
 *                               has focus. If the object that currently has
 *                               focus is a TextField, the default behavior of
 *                               this event is to cause all the contents of
 *                               the text field to be selected.
 * @event softKeyboardActivate   Dispatched immediately after the soft
 *                               keyboard is raised.
 * @event softKeyboardActivating Dispatched immediately before the soft
 *                               keyboard is raised.
 * @event softKeyboardDeactivate Dispatched immediately after the soft
 *                               keyboard is lowered.
 * @event tabChildrenChange      Dispatched when the value of the object's
 *                               <code>tabChildren</code> flag changes.
 * @event tabEnabledChange       Dispatched when the object's
 *                               <code>tabEnabled</code> flag changes.
 * @event tabIndexChange         Dispatched when the value of the object's
 *                               <code>tabIndex</code> property changes.
 * @event textInput              Dispatched when a user enters one or more
 *                               characters of text. Various text input
 *                               methods can generate this event, including
 *                               standard keyboards, input method editors
 *                              (IMEs), voice or speech recognition systems,
 *                               and even the act of pasting plain text with
 *                               no formatting or style information.
 * @event touchBegin             Dispatched when the user first contacts a
 *                               touch-enabled device(such as touches a
 *                               finger to a mobile phone or tablet with a
 *                               touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>mouseDown</code> event.
 *
 *                               <p>Specifically, if a user touches a finger
 *                               to a touch screen, the InteractiveObject
 *                               instance can dispatch a
 *                               <code>mouseDown</code> event or a
 *                               <code>touchBegin</code> event, or both if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseDown</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>touchBegin</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchEnd               Dispatched when the user removes contact with
 *                               a touch-enabled device(such as lifts a
 *                               finger off a mobile phone or tablet with a
 *                               touch screen). Some devices might also
 *                               interpret this contact as a
 *                               <code>mouseUp</code> event.
 *
 *                               <p>Specifically, if a user lifts a finger
 *                               from a touch screen, the InteractiveObject
 *                               instance can dispatch a <code>mouseUp</code>
 *                               event or a <code>touchEnd</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the flash.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>mouseUp</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchEnd</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchMove              Dispatched when the user moves the point of
 *                               contact with a touch-enabled device(such as
 *                               drags a finger across a mobile phone or
 *                               tablet with a touch screen). Some devices
 *                               might also interpret this contact as a
 *                               <code>mouseMove</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               across a touch screen, the InteractiveObject
 *                               instance can dispatch a
 *                               <code>mouseMove</code> event or a
 *                               <code>touchMove</code> event, or both if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseMove</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>touchMove</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchOut               Dispatched when the user moves the point of
 *                               contact away from InteractiveObject instance
 *                               on a touch-enabled device(such as drags a
 *                               finger from one display object to another on
 *                               a mobile phone or tablet with a touch
 *                               screen). Some devices might also interpret
 *                               this contact as a <code>mouseOut</code>
 *                               event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               across a touch screen, the InteractiveObject
 *                               instance can dispatch a <code>mouseOut</code>
 *                               event or a <code>touchOut</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the flash.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>mouseOut</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchOut</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchOver              Dispatched when the user moves the point of
 *                               contact over an InteractiveObject instance on
 *                               a touch-enabled device(such as drags a
 *                               finger from a point outside a display object
 *                               to a point over a display object on a mobile
 *                               phone or tablet with a touch screen). Some
 *                               devices might also interpret this contact as
 *                               a <code>mouseOver</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>mouseOver</code> event or a
 *                               <code>touchOver</code> event, or both if the
 *                               current environment supports it. Choose how
 *                               you want to handle the user interaction. Use
 *                               the flash.ui.Multitouch class to manage touch
 *                               event handling(enable touch gesture event
 *                               handling, simple touch point event handling,
 *                               or disable touch events so only mouse events
 *                               are dispatched). If you choose to handle the
 *                               <code>mouseOver</code> event, then the same
 *                               event handler will run on a touch-enabled
 *                               device and a mouse enabled device. However,
 *                               if you choose to handle the
 *                               <code>touchOver</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchRollOut           Dispatched when the user moves the point of
 *                               contact away from an InteractiveObject
 *                               instance on a touch-enabled device(such as
 *                               drags a finger from over a display object to
 *                               a point outside the display object on a
 *                               mobile phone or tablet with a touch screen).
 *                               Some devices might also interpret this
 *                               contact as a <code>rollOut</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>rollOut</code> event or a
 *                               <code>touchRollOut</code> event, or both if
 *                               the current environment supports it. Choose
 *                               how you want to handle the user interaction.
 *                               Use the flash.ui.Multitouch class to manage
 *                               touch event handling(enable touch gesture
 *                               event handling, simple touch point event
 *                               handling, or disable touch events so only
 *                               mouse events are dispatched). If you choose
 *                               to handle the <code>rollOut</code> event,
 *                               then the same event handler will run on a
 *                               touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchRollOut</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchRollOver          Dispatched when the user moves the point of
 *                               contact over an InteractiveObject instance on
 *                               a touch-enabled device(such as drags a
 *                               finger from a point outside a display object
 *                               to a point over a display object on a mobile
 *                               phone or tablet with a touch screen). Some
 *                               devices might also interpret this contact as
 *                               a <code>rollOver</code> event.
 *
 *                               <p>Specifically, if a user moves a finger
 *                               over an InteractiveObject, the
 *                               InteractiveObject instance can dispatch a
 *                               <code>rollOver</code> event or a
 *                               <code>touchRollOver</code> event, or both if
 *                               the current environment supports it. Choose
 *                               how you want to handle the user interaction.
 *                               Use the flash.ui.Multitouch class to manage
 *                               touch event handling(enable touch gesture
 *                               event handling, simple touch point event
 *                               handling, or disable touch events so only
 *                               mouse events are dispatched). If you choose
 *                               to handle the <code>rollOver</code> event,
 *                               then the same event handler will run on a
 *                               touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchRollOver</code> event, you can
 *                               design your event handler to respond to the
 *                               specific needs of a touch-enabled environment
 *                               and provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>
 * @event touchTap               Dispatched when the user lifts the point of
 *                               contact over the same InteractiveObject
 *                               instance on which the contact was initiated
 *                               on a touch-enabled device(such as presses
 *                               and releases a finger from a single point
 *                               over a display object on a mobile phone or
 *                               tablet with a touch screen). Some devices
 *                               might also interpret this contact as a
 *                               <code>click</code> event.
 *
 *                               <p>Specifically, if a user taps a finger over
 *                               an InteractiveObject, the InteractiveObject
 *                               instance can dispatch a <code>click</code>
 *                               event or a <code>touchTap</code> event, or
 *                               both if the current environment supports it.
 *                               Choose how you want to handle the user
 *                               interaction. Use the flash.ui.Multitouch
 *                               class to manage touch event handling(enable
 *                               touch gesture event handling, simple touch
 *                               point event handling, or disable touch events
 *                               so only mouse events are dispatched). If you
 *                               choose to handle the <code>click</code>
 *                               event, then the same event handler will run
 *                               on a touch-enabled device and a mouse enabled
 *                               device. However, if you choose to handle the
 *                               <code>touchTap</code> event, you can design
 *                               your event handler to respond to the specific
 *                               needs of a touch-enabled environment and
 *                               provide users with a richer touch-enabled
 *                               experience. You can also handle both events,
 *                               separately, to provide a different response
 *                               for a touch event than a mouse event.</p>
 *
 *                               <p><b>Note:</b> See the Multitouch class for
 *                               environment compatibility information.</p>]]></haxe_doc>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method">
			<f a="index1:index2">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Swaps the z-order(front-to-back order) of the child objects at the two
	 * specified index positions in the child list. All other child objects in
	 * the display object container remain in the same index positions.
	 * 
	 * @param index1 The index position of the first child object.
	 * @param index2 The index position of the second child object.
	 * @throws RangeError If either index does not exist in the child list.</haxe_doc>
		</swapChildrenAt>
		<swapChildren public="1" set="method">
			<f a="child1:child2">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.display.DisplayObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Swaps the z-order(front-to-back order) of the two specified child
	 * objects. All other child objects in the display object container remain in
	 * the same index positions.
	 * 
	 * @param child1 The first child object.
	 * @param child2 The second child object.
	 * @throws ArgumentError Throws if either child parameter is not a child of
	 *                       this object.</haxe_doc>
		</swapChildren>
		<setChildIndex public="1" set="method">
			<f a="child:index">
				<c path="flash.display.DisplayObject"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Changes the position of an existing child in the display object container.
	 * This affects the layering of child objects. For example, the following
	 * example shows three display objects, labeled a, b, and c, at index
	 * positions 0, 1, and 2, respectively:
	 *
	 * <p>When you use the <code>setChildIndex()</code> method and specify an
	 * index position that is already occupied, the only positions that change
	 * are those in between the display object's former and new position. All
	 * others will stay the same. If a child is moved to an index LOWER than its
	 * current index, all children in between will INCREASE by 1 for their index
	 * reference. If a child is moved to an index HIGHER than its current index,
	 * all children in between will DECREASE by 1 for their index reference. For
	 * example, if the display object container in the previous example is named
	 * <code>container</code>, you can swap the position of the display objects
	 * labeled a and b by calling the following code:</p>
	 *
	 * <p>This code results in the following arrangement of objects:</p>
	 * 
	 * @param child The child DisplayObject instance for which you want to change
	 *              the index number.
	 * @param index The resulting index number for the <code>child</code> display
	 *              object.
	 * @throws ArgumentError Throws if the child parameter is not a child of this
	 *                       object.
	 * @throws RangeError    Throws if the index does not exist in the child
	 *                       list.]]></haxe_doc>
		</setChildIndex>
		<removeChildAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Removes a child DisplayObject from the specified <code>index</code>
	 * position in the child list of the DisplayObjectContainer. The
	 * <code>parent</code> property of the removed child is set to
	 * <code>null</code>, and the object is garbage collected if no other
	 * references to the child exist. The index positions of any display objects
	 * above the child in the DisplayObjectContainer are decreased by 1.
	 *
	 * <p>The garbage collector reallocates unused memory space. When a variable
	 * or object is no longer actively referenced or stored somewhere, the
	 * garbage collector sweeps through and wipes out the memory space it used to
	 * occupy if no other references to it exist.</p>
	 * 
	 * @param index The child index of the DisplayObject to remove.
	 * @return The DisplayObject instance that was removed.
	 * @throws RangeError    Throws if the index does not exist in the child
	 *                       list.
	 * @throws SecurityError This child display object belongs to a sandbox to
	 *                       which the calling object does not have access. You
	 *                       can avoid this situation by having the child movie
	 *                       call the <code>Security.allowDomain()</code> method.]]></haxe_doc>
		</removeChildAt>
		<removeChild public="1" set="method">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Removes the specified <code>child</code> DisplayObject instance from the
	 * child list of the DisplayObjectContainer instance. The <code>parent</code>
	 * property of the removed child is set to <code>null</code> , and the object
	 * is garbage collected if no other references to the child exist. The index
	 * positions of any display objects above the child in the
	 * DisplayObjectContainer are decreased by 1.
	 *
	 * <p>The garbage collector reallocates unused memory space. When a variable
	 * or object is no longer actively referenced or stored somewhere, the
	 * garbage collector sweeps through and wipes out the memory space it used to
	 * occupy if no other references to it exist.</p>
	 * 
	 * @param child The DisplayObject instance to remove.
	 * @return The DisplayObject instance that you pass in the <code>child</code>
	 *         parameter.
	 * @throws ArgumentError Throws if the child parameter is not a child of this
	 *                       object.]]></haxe_doc>
		</removeChild>
		<getObjectsUnderPoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="Array"><c path="flash.display.DisplayObject"/></c>
			</f>
			<haxe_doc><![CDATA[* Returns an array of objects that lie under the specified point and are
	 * children(or grandchildren, and so on) of this DisplayObjectContainer
	 * instance. Any child objects that are inaccessible for security reasons are
	 * omitted from the returned array. To determine whether this security
	 * restriction affects the returned array, call the
	 * <code>areInaccessibleObjectsUnderPoint()</code> method.
	 *
	 * <p>The <code>point</code> parameter is in the coordinate space of the
	 * Stage, which may differ from the coordinate space of the display object
	 * container(unless the display object container is the Stage). You can use
	 * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
	 * methods to convert points between these coordinate spaces.</p>
	 * 
	 * @param point The point under which to look.
	 * @return An array of objects that lie under the specified point and are
	 *         children(or grandchildren, and so on) of this
	 *         DisplayObjectContainer instance.]]></haxe_doc>
		</getObjectsUnderPoint>
		<getChildIndex public="1" set="method">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns the index position of a <code>child</code> DisplayObject instance.
	 * 
	 * @param child The DisplayObject instance to identify.
	 * @return The index position of the child display object to identify.
	 * @throws ArgumentError Throws if the child parameter is not a child of this
	 *                       object.]]></haxe_doc>
		</getChildIndex>
		<getChildByName public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns the child display object that exists with the specified name. If
	 * more that one child display object has the specified name, the method
	 * returns the first object in the child list.
	 *
	 * <p>The <code>getChildAt()</code> method is faster than the
	 * <code>getChildByName()</code> method. The <code>getChildAt()</code> method
	 * accesses a child from a cached array, whereas the
	 * <code>getChildByName()</code> method has to traverse a linked list to
	 * access a child.</p>
	 * 
	 * @param name The name of the child to return.
	 * @return The child display object with the specified name.
	 * @throws SecurityError This child display object belongs to a sandbox to
	 *                       which you do not have access. You can avoid this
	 *                       situation by having the child movie call the
	 *                       <code>Security.allowDomain()</code> method.]]></haxe_doc>
		</getChildByName>
		<getChildAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns the child display object instance that exists at the specified
	 * index.
	 * 
	 * @param index The index position of the child object.
	 * @return The child display object at the specified index position.
	 * @throws RangeError    Throws if the index does not exist in the child
	 *                       list.
	 * @throws SecurityError This child display object belongs to a sandbox to
	 *                       which you do not have access. You can avoid this
	 *                       situation by having the child movie call
	 *                       <code>Security.allowDomain()</code>.]]></haxe_doc>
		</getChildAt>
		<contains public="1" set="method">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the specified display object is a child of the
	 * DisplayObjectContainer instance or the instance itself. The search
	 * includes the entire display list including this DisplayObjectContainer
	 * instance. Grandchildren, great-grandchildren, and so on each return
	 * <code>true</code>.
	 * 
	 * @param child The child object to test.
	 * @return <code>true</code> if the <code>child</code> object is a child of
	 *         the DisplayObjectContainer or the container itself; otherwise
	 *         <code>false</code>.]]></haxe_doc>
		</contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Indicates whether the security restrictions would cause any display
	 * objects to be omitted from the list returned by calling the
	 * <code>DisplayObjectContainer.getObjectsUnderPoint()</code> method with the
	 * specified <code>point</code> point. By default, content from one domain
	 * cannot access objects from another domain unless they are permitted to do
	 * so with a call to the <code>Security.allowDomain()</code> method. For more
	 * information, related to security, see the Flash Player Developer Center
	 * Topic: <a href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.
	 *
	 * <p>The <code>point</code> parameter is in the coordinate space of the
	 * Stage, which may differ from the coordinate space of the display object
	 * container(unless the display object container is the Stage). You can use
	 * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
	 * methods to convert points between these coordinate spaces.</p>
	 * 
	 * @param point The point under which to look.
	 * @return <code>true</code> if the point contains child display objects with
	 *         security restrictions.]]></haxe_doc>
		</areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method">
			<f a="child:index">
				<c path="flash.display.DisplayObject"/>
				<x path="Int"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Adds a child DisplayObject instance to this DisplayObjectContainer
	 * instance. The child is added at the index position specified. An index of
	 * 0 represents the back(bottom) of the display list for this
	 * DisplayObjectContainer object.
	 *
	 * <p>For example, the following example shows three display objects, labeled
	 * a, b, and c, at index positions 0, 2, and 1, respectively:</p>
	 *
	 * <p>If you add a child object that already has a different display object
	 * container as a parent, the object is removed from the child list of the
	 * other display object container. </p>
	 * 
	 * @param child The DisplayObject instance to add as a child of this
	 *              DisplayObjectContainer instance.
	 * @param index The index position to which the child is added. If you
	 *              specify a currently occupied index position, the child object
	 *              that exists at that position and all higher positions are
	 *              moved up one position in the child list.
	 * @return The DisplayObject instance that you pass in the <code>child</code>
	 *         parameter.
	 * @throws ArgumentError Throws if the child is the same as the parent. Also
	 *                       throws if the caller is a child(or grandchild etc.)
	 *                       of the child being added.
	 * @throws RangeError    Throws if the index position does not exist in the
	 *                       child list.
	 * @event added Dispatched when a display object is added to the display
	 *              list.]]></haxe_doc>
		</addChildAt>
		<addChild public="1" set="method">
			<f a="child">
				<c path="flash.display.DisplayObject"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Adds a child DisplayObject instance to this DisplayObjectContainer
	 * instance. The child is added to the front(top) of all other children in
	 * this DisplayObjectContainer instance.(To add a child to a specific index
	 * position, use the <code>addChildAt()</code> method.)
	 *
	 * <p>If you add a child object that already has a different display object
	 * container as a parent, the object is removed from the child list of the
	 * other display object container. </p>
	 *
	 * <p><b>Note:</b> The command <code>stage.addChild()</code> can cause
	 * problems with a published SWF file, including security problems and
	 * conflicts with other loaded SWF files. There is only one Stage within a
	 * Flash runtime instance, no matter how many SWF files you load into the
	 * runtime. So, generally, objects should not be added to the Stage,
	 * directly, at all. The only object the Stage should contain is the root
	 * object. Create a DisplayObjectContainer to contain all of the items on the
	 * display list. Then, if necessary, add that DisplayObjectContainer instance
	 * to the Stage.</p>
	 * 
	 * @param child The DisplayObject instance to add as a child of this
	 *              DisplayObjectContainer instance.
	 * @return The DisplayObject instance that you pass in the <code>child</code>
	 *         parameter.
	 * @throws ArgumentError Throws if the child is the same as the parent. Also
	 *                       throws if the caller is a child(or grandchild etc.)
	 *                       of the child being added.
	 * @event added Dispatched when a display object is added to the display
	 *              list.]]></haxe_doc>
		</addChild>
		<tabChildren public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Determines whether the children of the object are tab enabled. Enables or
	 * disables tabbing for the children of the object. The default is
	 * <code>true</code>.
	 *
	 * <p><b>Note:</b> Do not use the <code>tabChildren</code> property with
	 * Flex. Instead, use the
	 * <code>mx.core.UIComponent.hasFocusableChildren</code> property.</p>
	 * 
	 * @throws IllegalOperationError Calling this property of the Stage object
	 *                               throws an exception. The Stage object does
	 *                               not implement this property.]]></haxe_doc>
		</tabChildren>
		<numChildren public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns the number of children of this object.</haxe_doc>
		</numChildren>
		<mouseChildren public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Determines whether or not the children of the object are mouse, or user
	 * input device, enabled. If an object is enabled, a user can interact with
	 * it by using a mouse or user input device. The default is
	 * <code>true</code>.
	 *
	 * <p>This property is useful when you create a button with an instance of
	 * the Sprite class(instead of using the SimpleButton class). When you use a
	 * Sprite instance to create a button, you can choose to decorate the button
	 * by using the <code>addChild()</code> method to add additional Sprite
	 * instances. This process can cause unexpected behavior with mouse events
	 * because the Sprite instances you add as children can become the target
	 * object of a mouse event when you expect the parent instance to be the
	 * target object. To ensure that the parent instance serves as the target
	 * objects for mouse events, you can set the <code>mouseChildren</code>
	 * property of the parent instance to <code>false</code>.</p>
	 *
	 * <p> No event is dispatched by setting this property. You must use the
	 * <code>addEventListener()</code> method to create interactive
	 * functionality.</p>]]></haxe_doc>
		</mouseChildren>
		<new set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Returns a TextSnapshot object for this DisplayObjectContainer instance.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The DisplayObjectContainer class is the base class for all objects that can
 * serve as display object containers on the display list. The display list
 * manages all objects displayed in the Flash runtimes. Use the
 * DisplayObjectContainer class to arrange the display objects in the display
 * list. Each DisplayObjectContainer object has its own child list for
 * organizing the z-order of the objects. The z-order is the front-to-back
 * order that determines which object is drawn in front, which is behind, and
 * so on.
 *
 * <p>DisplayObject is an abstract base class; therefore, you cannot call
 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
 * <code>ArgumentError</code> exception.</p>
 * The DisplayObjectContainer class is an abstract base class for all objects
 * that can contain child objects. It cannot be instantiated directly; calling
 * the <code>new DisplayObjectContainer()</code> constructor throws an
 * <code>ArgumentError</code> exception.
 *
 * <p>For more information, see the "Display Programming" chapter of the
 * <i>ActionScript 3.0 Developer's Guide</i>.</p>]]></haxe_doc>
	</class>
	<enum path="flash.display.GradientType" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/GradientType.hx">
		<LINEAR><haxe_doc>* Value used to specify a linear gradient fill.</haxe_doc></LINEAR>
		<RADIAL><haxe_doc>* Value used to specify a radial gradient fill.</haxe_doc></RADIAL>
		<haxe_doc><![CDATA[* The GradientType class provides values for the <code>type</code> parameter
 * in the <code>beginGradientFill()</code> and
 * <code>lineGradientStyle()</code> methods of the flash.display.Graphics
 * class.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/Graphics.hx" extern="1">
		<moveTo public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Moves the current drawing position to(<code>x</code>, <code>y</code>). If
	 * any of the parameters are missing, this method fails and the current
	 * drawing position is not changed.
	 * 
	 * @param x A number that indicates the horizontal position relative to the
	 *          registration point of the parent display object(in pixels).
	 * @param y A number that indicates the vertical position relative to the
	 *          registration point of the parent display object(in pixels).]]></haxe_doc>
		</moveTo>
		<lineTo public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a line using the current line style from the current drawing
	 * position to(<code>x</code>, <code>y</code>); the current drawing position
	 * is then set to(<code>x</code>, <code>y</code>). If the display object in
	 * which you are drawing contains content that was created with the Flash
	 * drawing tools, calls to the <code>lineTo()</code> method are drawn
	 * underneath the content. If you call <code>lineTo()</code> before any calls
	 * to the <code>moveTo()</code> method, the default position for the current
	 * drawing is(<i>0, 0</i>). If any of the parameters are missing, this
	 * method fails and the current drawing position is not changed.
	 * 
	 * @param x A number that indicates the horizontal position relative to the
	 *          registration point of the parent display object(in pixels).
	 * @param y A number that indicates the vertical position relative to the
	 *          registration point of the parent display object(in pixels).]]></haxe_doc>
		</lineTo>
		<lineStyle public="1" set="method">
			<f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<e path="flash.display.LineScaleMode"/>
				<e path="flash.display.CapsStyle"/>
				<e path="flash.display.JointStyle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a shader to use for the line stroke when drawing lines.
	 *
	 * <p>The shader line style is used for subsequent calls to Graphics methods
	 * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	 * method. The line style remains in effect until you call the
	 * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
	 * the <code>lineBitmapStyle()</code> method again with different parameters.
	 * </p>
	 *
	 * <p>You can call the <code>lineShaderStyle()</code> method in the middle of
	 * drawing a path to specify different styles for different line segments
	 * within a path. </p>
	 *
	 * <p>Call the <code>lineStyle()</code> method before you call the
	 * <code>lineShaderStyle()</code> method to enable a stroke, or else the
	 * value of the line style is <code>undefined</code>.</p>
	 *
	 * <p>Calls to the <code>clear()</code> method set the line style back to
	 * <code>undefined</code>. </p>
	 * 
	 * @param shader The shader to use for the line stroke.
	 * @param matrix An optional transformation matrix as defined by the
	 *               flash.geom.Matrix class. The matrix can be used to scale or
	 *               otherwise manipulate the bitmap before applying it to the
	 *               line style.]]></haxe_doc>
		</lineStyle>
		<lineGradientStyle public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
				<e path="flash.display.GradientType"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<e path="flash.display.SpreadMethod"/>
				<e path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a gradient to use for the stroke when drawing lines.
	 *
	 * <p>The gradient line style is used for subsequent calls to Graphics
	 * methods such as the <code>lineTo()</code> methods or the
	 * <code>drawCircle()</code> method. The line style remains in effect until
	 * you call the <code>lineStyle()</code> or <code>lineBitmapStyle()</code>
	 * methods, or the <code>lineGradientStyle()</code> method again with
	 * different parameters. </p>
	 *
	 * <p>You can call the <code>lineGradientStyle()</code> method in the middle
	 * of drawing a path to specify different styles for different line segments
	 * within a path. </p>
	 *
	 * <p>Call the <code>lineStyle()</code> method before you call the
	 * <code>lineGradientStyle()</code> method to enable a stroke, or else the
	 * value of the line style is <code>undefined</code>.</p>
	 *
	 * <p>Calls to the <code>clear()</code> method set the line style back to
	 * <code>undefined</code>. </p>
	 * 
	 * @param type                A value from the GradientType class that
	 *                            specifies which gradient type to use, either
	 *                            GradientType.LINEAR or GradientType.RADIAL.
	 * @param matrix              A transformation matrix as defined by the
	 *                            flash.geom.Matrix class. The flash.geom.Matrix
	 *                            class includes a
	 *                            <code>createGradientBox()</code> method, which
	 *                            lets you conveniently set up the matrix for use
	 *                            with the <code>lineGradientStyle()</code>
	 *                            method.
	 * @param spreadMethod        A value from the SpreadMethod class that
	 *                            specifies which spread method to use:
	 * @param interpolationMethod A value from the InterpolationMethod class that
	 *                            specifies which value to use. For example,
	 *                            consider a simple linear gradient between two
	 *                            colors(with the <code>spreadMethod</code>
	 *                            parameter set to
	 *                            <code>SpreadMethod.REFLECT</code>). The
	 *                            different interpolation methods affect the
	 *                            appearance as follows:
	 * @param focalPointRatio     A number that controls the location of the
	 *                            focal point of the gradient. The value 0 means
	 *                            the focal point is in the center. The value 1
	 *                            means the focal point is at one border of the
	 *                            gradient circle. The value -1 means that the
	 *                            focal point is at the other border of the
	 *                            gradient circle. Values less than -1 or greater
	 *                            than 1 are rounded to -1 or 1. The following
	 *                            image shows a gradient with a
	 *                            <code>focalPointRatio</code> of -0.75:]]></haxe_doc>
		</lineGradientStyle>
		<lineBitmapStyle public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a bitmap to use for the line stroke when drawing lines.
	 *
	 * <p>The bitmap line style is used for subsequent calls to Graphics methods
	 * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	 * method. The line style remains in effect until you call the
	 * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
	 * the <code>lineBitmapStyle()</code> method again with different parameters.
	 * </p>
	 *
	 * <p>You can call the <code>lineBitmapStyle()</code> method in the middle of
	 * drawing a path to specify different styles for different line segments
	 * within a path. </p>
	 *
	 * <p>Call the <code>lineStyle()</code> method before you call the
	 * <code>lineBitmapStyle()</code> method to enable a stroke, or else the
	 * value of the line style is <code>undefined</code>.</p>
	 *
	 * <p>Calls to the <code>clear()</code> method set the line style back to
	 * <code>undefined</code>. </p>
	 * 
	 * @param bitmap The bitmap to use for the line stroke.
	 * @param matrix An optional transformation matrix as defined by the
	 *               flash.geom.Matrix class. The matrix can be used to scale or
	 *               otherwise manipulate the bitmap before applying it to the
	 *               line style.
	 * @param repeat Whether to repeat the bitmap in a tiled fashion.
	 * @param smooth Whether smoothing should be applied to the bitmap.]]></haxe_doc>
		</lineBitmapStyle>
		<endFill public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Applies a fill to the lines and curves that were added since the last call
	 * to the <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	 * <code>beginBitmapFill()</code> method. Flash uses the fill that was
	 * specified in the previous call to the <code>beginFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	 * method. If the current drawing position does not equal the previous
	 * position specified in a <code>moveTo()</code> method and a fill is
	 * defined, the path is closed with a line and then filled.
	 *]]></haxe_doc>
		</endFill>
		<drawTriangles public="1" set="method">
			<f a="vertices:?indices:?uvtData:?culling">
				<c path="flash.Vector"><x path="Float"/></c>
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.TriangleCulling"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Renders a set of triangles, typically to distort bitmaps and give them a
	 * three-dimensional appearance. The <code>drawTriangles()</code> method maps
	 * either the current fill, or a bitmap fill, to the triangle faces using a
	 * set of(u,v) coordinates.
	 *
	 * <p> Any type of fill can be used, but if the fill has a transform matrix
	 * that transform matrix is ignored. </p>
	 *
	 * <p> A <code>uvtData</code> parameter improves texture mapping when a
	 * bitmap fill is used. </p>
	 * 
	 * @param culling Specifies whether to render triangles that face in a
	 *                specified direction. This parameter prevents the rendering
	 *                of triangles that cannot be seen in the current view. This
	 *                parameter can be set to any value defined by the
	 *                TriangleCulling class.]]></haxe_doc>
		</drawTriangles>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method">
			<f a="x:y:width:height:ellipseWidth:?ellipseHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a rounded rectangle. Set the line style, fill, or both before you
	 * call the <code>drawRoundRect()</code> method, by calling the
	 * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
	 * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	 * <code>beginBitmapFill()</code> method.
	 * 
	 * @param x             A number indicating the horizontal position relative
	 *                      to the registration point of the parent display
	 *                      object(in pixels).
	 * @param y             A number indicating the vertical position relative to
	 *                      the registration point of the parent display object
	 *                     (in pixels).
	 * @param width         The width of the round rectangle(in pixels).
	 * @param height        The height of the round rectangle(in pixels).
	 * @param ellipseWidth  The width of the ellipse used to draw the rounded
	 *                      corners(in pixels).
	 * @param ellipseHeight The height of the ellipse used to draw the rounded
	 *                      corners(in pixels). Optional; if no value is
	 *                      specified, the default value matches that provided
	 *                      for the <code>ellipseWidth</code> parameter.
	 * @throws ArgumentError If the <code>width</code>, <code>height</code>,
	 *                       <code>ellipseWidth</code> or
	 *                       <code>ellipseHeight</code> parameters are not a
	 *                       number(<code>Number.NaN</code>).]]></haxe_doc>
		</drawRoundRect>
		<drawRect public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a rectangle. Set the line style, fill, or both before you call the
	 * <code>drawRect()</code> method, by calling the <code>linestyle()</code>,
	 * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	 * method.
	 * 
	 * @param x      A number indicating the horizontal position relative to the
	 *               registration point of the parent display object(in pixels).
	 * @param y      A number indicating the vertical position relative to the
	 *               registration point of the parent display object(in pixels).
	 * @param width  The width of the rectangle(in pixels).
	 * @param height The height of the rectangle(in pixels).
	 * @throws ArgumentError If the <code>width</code> or <code>height</code>
	 *                       parameters are not a number
	 *                      (<code>Number.NaN</code>).]]></haxe_doc>
		</drawRect>
		<drawPath public="1" set="method">
			<f a="commands:data:?winding">
				<c path="flash.Vector"><x path="Int"/></c>
				<c path="flash.Vector"><x path="Float"/></c>
				<e path="flash.display.GraphicsPathWinding"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Submits a series of commands for drawing. The <code>drawPath()</code>
	 * method uses vector arrays to consolidate individual <code>moveTo()</code>,
	 * <code>lineTo()</code>, and <code>curveTo()</code> drawing commands into a
	 * single call. The <code>drawPath()</code> method parameters combine drawing
	 * commands with x- and y-coordinate value pairs and a drawing direction. The
	 * drawing commands are values from the GraphicsPathCommand class. The x- and
	 * y-coordinate value pairs are Numbers in an array where each pair defines a
	 * coordinate location. The drawing direction is a value from the
	 * GraphicsPathWinding class.
	 *
	 * <p> Generally, drawings render faster with <code>drawPath()</code> than
	 * with a series of individual <code>lineTo()</code> and
	 * <code>curveTo()</code> methods. </p>
	 *
	 * <p> The <code>drawPath()</code> method uses a uses a floating computation
	 * so rotation and scaling of shapes is more accurate and gives better
	 * results. However, curves submitted using the <code>drawPath()</code>
	 * method can have small sub-pixel alignment errors when used in conjunction
	 * with the <code>lineTo()</code> and <code>curveTo()</code> methods. </p>
	 *
	 * <p> The <code>drawPath()</code> method also uses slightly different rules
	 * for filling and drawing lines. They are: </p>
	 *
	 * <ul>
	 *   <li>When a fill is applied to rendering a path:
	 * <ul>
	 *   <li>A sub-path of less than 3 points is not rendered.(But note that the
	 * stroke rendering will still occur, consistent with the rules for strokes
	 * below.)</li>
	 *   <li>A sub-path that isn't closed(the end point is not equal to the
	 * begin point) is implicitly closed.</li>
	 * </ul>
	 * </li>
	 *   <li>When a stroke is applied to rendering a path:
	 * <ul>
	 *   <li>The sub-paths can be composed of any number of points.</li>
	 *   <li>The sub-path is never implicitly closed.</li>
	 * </ul>
	 * </li>
	 * </ul>
	 * 
	 * @param winding Specifies the winding rule using a value defined in the
	 *                GraphicsPathWinding class.]]></haxe_doc>
		</drawPath>
		<drawGraphicsData public="1" set="method">
			<f a="graphicsData">
				<c path="flash.Vector"><c path="flash.display.IGraphicsData"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Submits a series of IGraphicsData instances for drawing. This method
	 * accepts a Vector containing objects including paths, fills, and strokes
	 * that implement the IGraphicsData interface. A Vector of IGraphicsData
	 * instances can refer to a part of a shape, or a complex fully defined set
	 * of data for rendering a complete shape.
	 *
	 * <p> Graphics paths can contain other graphics paths. If the
	 * <code>graphicsData</code> Vector includes a path, that path and all its
	 * sub-paths are rendered during this operation. </p>
	 *]]></haxe_doc>
		</drawGraphicsData>
		<drawEllipse public="1" set="method">
			<f a="x:y:width:height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws an ellipse. Set the line style, fill, or both before you call the
	 * <code>drawEllipse()</code> method, by calling the
	 * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
	 * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	 * <code>beginBitmapFill()</code> method.
	 * 
	 * @param x      The <i>x</i> location of the top-left of the bounding-box of
	 *               the ellipse relative to the registration point of the parent
	 *               display object(in pixels).
	 * @param y      The <i>y</i> location of the top left of the bounding-box of
	 *               the ellipse relative to the registration point of the parent
	 *               display object(in pixels).
	 * @param width  The width of the ellipse(in pixels).
	 * @param height The height of the ellipse(in pixels).]]></haxe_doc>
		</drawEllipse>
		<drawCircle public="1" set="method">
			<f a="x:y:radius">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Draws a circle. Set the line style, fill, or both before you call the
	 * <code>drawCircle()</code> method, by calling the <code>linestyle()</code>,
	 * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	 * method.
	 * 
	 * @param x      The <i>x</i> location of the center of the circle relative
	 *               to the registration point of the parent display object(in
	 *               pixels).
	 * @param y      The <i>y</i> location of the center of the circle relative
	 *               to the registration point of the parent display object(in
	 *               pixels).
	 * @param radius The radius of the circle(in pixels).]]></haxe_doc>
		</drawCircle>
		<curveTo public="1" set="method">
			<f a="controlX:controlY:anchorX:anchorY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Copies all of drawing commands from the source Graphics object into the
	 * calling Graphics object.
	 * 
	 * @param sourceGraphics The Graphics object from which to copy the drawing
	 *                       commands.</haxe_doc>
		</curveTo>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Specifies a shader fill used by subsequent calls to other Graphics methods
	 * (such as <code>lineTo()</code> or <code>drawCircle()</code>) for the
	 * object. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called.</p>
	 *
	 * <p>Shader fills are not supported under GPU rendering; filled areas will
	 * be colored cyan.</p>
	 * 
	 * @param shader The shader to use for the fill. This Shader instance is not
	 *               required to specify an image input. However, if an image
	 *               input is specified in the shader, the input must be provided
	 *               manually. To specify the input, set the <code>input</code>
	 *               property of the corresponding ShaderInput property of the
	 *               <code>Shader.data</code> property.
	 *
	 *               <p>When you pass a Shader instance as an argument the shader
	 *               is copied internally. The drawing fill operation uses that
	 *               internal copy, not a reference to the original shader. Any
	 *               changes made to the shader, such as changing a parameter
	 *               value, input, or bytecode, are not applied to the copied
	 *               shader that's used for the fill.</p>
	 * @param matrix A matrix object(of the flash.geom.Matrix class), which you
	 *               can use to define transformations on the shader. For
	 *               example, you can use the following matrix to rotate a shader
	 *               by 45 degrees(pi/4 radians):
	 *
	 *               <p>The coordinates received in the shader are based on the
	 *               matrix that is specified for the <code>matrix</code>
	 *               parameter. For a default(<code>null</code>) matrix, the
	 *               coordinates in the shader are local pixel coordinates which
	 *               can be used to sample an input.</p>
	 * @throws ArgumentError When the shader output type is not compatible with
	 *                       this operation(the shader must specify a
	 *                       <code>pixel3</code> or <code>pixel4</code> output).
	 * @throws ArgumentError When the shader specifies an image input that isn't
	 *                       provided.
	 * @throws ArgumentError When a ByteArray or Vector.<Number> instance is used
	 *                       as an input and the <code>width</code> and
	 *                       <code>height</code> properties aren't specified for
	 *                       the ShaderInput, or the specified values don't match
	 *                       the amount of data in the input object. See the
	 *                       <code>ShaderInput.input</code> property for more
	 *                       information.]]></haxe_doc>
		</clear>
		<beginGradientFill public="1" set="method">
			<f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
				<e path="flash.display.GradientType"/>
				<c path="Array"><x path="Int"/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="flash.geom.Matrix"/>
				<e path="flash.display.SpreadMethod"/>
				<e path="flash.display.InterpolationMethod"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a gradient fill used by subsequent calls to other Graphics
	 * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) for
	 * the object. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called. </p>
	 * 
	 * @param type                A value from the GradientType class that
	 *                            specifies which gradient type to use:
	 *                            <code>GradientType.LINEAR</code> or
	 *                            <code>GradientType.RADIAL</code>.
	 * @param matrix              A transformation matrix as defined by the
	 *                            flash.geom.Matrix class. The flash.geom.Matrix
	 *                            class includes a
	 *                            <code>createGradientBox()</code> method, which
	 *                            lets you conveniently set up the matrix for use
	 *                            with the <code>beginGradientFill()</code>
	 *                            method.
	 * @param spreadMethod        A value from the SpreadMethod class that
	 *                            specifies which spread method to use, either:
	 *                            <code>SpreadMethod.PAD</code>,
	 *                            <code>SpreadMethod.REFLECT</code>, or
	 *                            <code>SpreadMethod.REPEAT</code>.
	 *
	 *                            <p>For example, consider a simple linear
	 *                            gradient between two colors:</p>
	 *
	 *                            <p>This example uses
	 *                            <code>SpreadMethod.PAD</code> for the spread
	 *                            method, and the gradient fill looks like the
	 *                            following:</p>
	 *
	 *                            <p>If you use <code>SpreadMethod.REFLECT</code>
	 *                            for the spread method, the gradient fill looks
	 *                            like the following:</p>
	 *
	 *                            <p>If you use <code>SpreadMethod.REPEAT</code>
	 *                            for the spread method, the gradient fill looks
	 *                            like the following:</p>
	 * @param interpolationMethod A value from the InterpolationMethod class that
	 *                            specifies which value to use:
	 *                            <code>InterpolationMethod.LINEAR_RGB</code> or
	 *                            <code>InterpolationMethod.RGB</code>
	 *
	 *                            <p>For example, consider a simple linear
	 *                            gradient between two colors(with the
	 *                            <code>spreadMethod</code> parameter set to
	 *                            <code>SpreadMethod.REFLECT</code>). The
	 *                            different interpolation methods affect the
	 *                            appearance as follows: </p>
	 * @param focalPointRatio     A number that controls the location of the
	 *                            focal point of the gradient. 0 means that the
	 *                            focal point is in the center. 1 means that the
	 *                            focal point is at one border of the gradient
	 *                            circle. -1 means that the focal point is at the
	 *                            other border of the gradient circle. A value
	 *                            less than -1 or greater than 1 is rounded to -1
	 *                            or 1. For example, the following example shows
	 *                            a <code>focalPointRatio</code> set to 0.75:
	 * @throws ArgumentError If the <code>type</code> parameter is not valid.]]></haxe_doc>
		</beginGradientFill>
		<beginFill public="1" set="method">
			<f a="color:?alpha">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Specifies a simple one-color fill that subsequent calls to other Graphics
	 * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) use
	 * when drawing. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called.</p>
	 * 
	 * @param color The color of the fill(0xRRGGBB).
	 * @param alpha The alpha value of the fill(0.0 to 1.0).]]></haxe_doc>
		</beginFill>
		<beginBitmapFill public="1" set="method">
			<f a="bitmap:?matrix:?repeat:?smooth">
				<c path="flash.display.BitmapData"/>
				<c path="flash.geom.Matrix"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills a drawing area with a bitmap image. The bitmap can be repeated or
	 * tiled to fill the area. The fill remains in effect until you call the
	 * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	 * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	 * method. Calling the <code>clear()</code> method clears the fill.
	 *
	 * <p>The application renders the fill whenever three or more points are
	 * drawn, or when the <code>endFill()</code> method is called. </p>
	 * 
	 * @param bitmap A transparent or opaque bitmap image that contains the bits
	 *               to be displayed.
	 * @param matrix A matrix object(of the flash.geom.Matrix class), which you
	 *               can use to define transformations on the bitmap. For
	 *               example, you can use the following matrix to rotate a bitmap
	 *               by 45 degrees(pi/4 radians):
	 * @param repeat If <code>true</code>, the bitmap image repeats in a tiled
	 *               pattern. If <code>false</code>, the bitmap image does not
	 *               repeat, and the edges of the bitmap are used for any fill
	 *               area that extends beyond the bitmap.
	 *
	 *               <p>For example, consider the following bitmap(a 20 x
	 *               20-pixel checkerboard pattern):</p>
	 *
	 *               <p>When <code>repeat</code> is set to <code>true</code>(as
	 *               in the following example), the bitmap fill repeats the
	 *               bitmap:</p>
	 *
	 *               <p>When <code>repeat</code> is set to <code>false</code>,
	 *               the bitmap fill uses the edge pixels for the fill area
	 *               outside the bitmap:</p>
	 * @param smooth If <code>false</code>, upscaled bitmap images are rendered
	 *               by using a nearest-neighbor algorithm and look pixelated. If
	 *               <code>true</code>, upscaled bitmap images are rendered by
	 *               using a bilinear algorithm. Rendering by using the nearest
	 *               neighbor algorithm is faster.]]></haxe_doc>
		</beginBitmapFill>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The Graphics class contains a set of methods that you can use to create a
 * vector shape. Display objects that support drawing include Sprite and Shape
 * objects. Each of these classes includes a <code>graphics</code> property
 * that is a Graphics object. The following are among those helper functions
 * provided for ease of use: <code>drawRect()</code>,
 * <code>drawRoundRect()</code>, <code>drawCircle()</code>, and
 * <code>drawEllipse()</code>.
 *
 * <p>You cannot create a Graphics object directly from ActionScript code. If
 * you call <code>new Graphics()</code>, an exception is thrown.</p>
 *
 * <p>The Graphics class is final; it cannot be subclassed.</p>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/GraphicsPathWinding.hx">
		<EVEN_ODD/>
		<NON_ZERO/>
		<haxe_doc><![CDATA[* The GraphicsPathWinding class provides values for the
 * <code>flash.display.GraphicsPath.winding</code> property and the
 * <code>flash.display.Graphics.drawPath()</code> method to determine the
 * direction to draw a path. A clockwise path is positively wound, and a
 * counter-clockwise path is negatively wound:
 *
 * <p> When paths intersect or overlap, the winding direction determines the
 * rules for filling the areas created by the intersection or overlap:</p>]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/InterpolationMethod.hx">
		<LINEAR_RGB><haxe_doc><![CDATA[* Specifies that the RGB interpolation method should be used. This means
	 * that the gradient is rendered with exponential sRGB(standard RGB) space.
	 * The sRGB space is a W3C-endorsed standard that defines a non-linear
	 * conversion between red, green, and blue component values and the actual
	 * intensity of the visible component color.
	 *
	 * <p>For example, consider a simple linear gradient between two colors(with
	 * the <code>spreadMethod</code> parameter set to
	 * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
	 * affect the appearance as follows: </p>]]></haxe_doc></LINEAR_RGB>
		<RGB><haxe_doc><![CDATA[* Specifies that the RGB interpolation method should be used. This means
	 * that the gradient is rendered with exponential sRGB(standard RGB) space.
	 * The sRGB space is a W3C-endorsed standard that defines a non-linear
	 * conversion between red, green, and blue component values and the actual
	 * intensity of the visible component color.
	 *
	 * <p>For example, consider a simple linear gradient between two colors(with
	 * the <code>spreadMethod</code> parameter set to
	 * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
	 * affect the appearance as follows: </p>]]></haxe_doc></RGB>
		<haxe_doc><![CDATA[* The InterpolationMethod class provides values for the
 * <code>interpolationMethod</code> parameter in the
 * <code>Graphics.beginGradientFill()</code> and
 * <code>Graphics.lineGradientStyle()</code> methods. This parameter
 * determines the RGB space to use when rendering the gradient.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/JointStyle.hx">
		<BEVEL><haxe_doc><![CDATA[* Specifies beveled joints in the <code>joints</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method.]]></haxe_doc></BEVEL>
		<MITER><haxe_doc><![CDATA[* Specifies mitered joints in the <code>joints</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method.]]></haxe_doc></MITER>
		<ROUND><haxe_doc><![CDATA[* Specifies round joints in the <code>joints</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method.]]></haxe_doc></ROUND>
		<haxe_doc><![CDATA[* The JointStyle class is an enumeration of constant values that specify the
 * joint style to use in drawing lines. These constants are provided for use
 * as values in the <code>joints</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method. The method supports
 * three types of joints: miter, round, and bevel, as the following example
 * shows:]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/LineScaleMode.hx">
		<HORIZONTAL><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line scales
	 * <i>only</i> vertically. For example, consider the following circles, drawn
	 * with a one-pixel line, and each with the <code>scaleMode</code> parameter
	 * set to <code>LineScaleMode.VERTICAL</code>. The circle on the left is
	 * scaled only vertically, and the circle on the right is scaled both
	 * vertically and horizontally.]]></haxe_doc></HORIZONTAL>
		<NONE><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line never scales.]]></haxe_doc></NONE>
		<NORMAL><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line always scales
	 * when the object is scaled(the default).]]></haxe_doc></NORMAL>
		<VERTICAL><haxe_doc><![CDATA[* With this setting used as the <code>scaleMode</code> parameter of the
	 * <code>lineStyle()</code> method, the thickness of the line scales
	 * <i>only</i> horizontally. For example, consider the following circles,
	 * drawn with a one-pixel line, and each with the <code>scaleMode</code>
	 * parameter set to <code>LineScaleMode.HORIZONTAL</code>. The circle on the
	 * left is scaled only horizontally, and the circle on the right is scaled
	 * both vertically and horizontally.]]></haxe_doc></VERTICAL>
		<haxe_doc><![CDATA[* The LineScaleMode class provides values for the <code>scaleMode</code>
 * parameter in the <code>Graphics.lineStyle()</code> method.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unload public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Removes a child of this Loader object that was loaded by using the
	 * <code>load()</code> method. The <code>property</code> of the associated
	 * LoaderInfo object is reset to <code>null</code>. The child is not
	 * necessarily destroyed because other objects might have references to it;
	 * however, it is no longer a child of the Loader object.
	 *
	 * <p>As a best practice, before you unload a child SWF file, you should
	 * explicitly close any streams in the child SWF file's objects, such as
	 * LocalConnection, NetConnection, NetStream, and Sound objects. Otherwise,
	 * audio in the child SWF file might continue to play, even though the child
	 * SWF file was unloaded. To close streams in the child SWF file, add an
	 * event listener to the child that listens for the <code>unload</code>
	 * event. When the parent calls <code>Loader.unload()</code>, the
	 * <code>unload</code> event is dispatched to the child. The following code
	 * shows how you might do this:</p>
	 * <pre xml:space="preserve"> function closeAllStreams(evt:Event) {
	 * myNetStream.close(); mySound.close(); myNetConnection.close();
	 * myLocalConnection.close(); }
	 * myMovieClip.loaderInfo.addEventListener(Event.UNLOAD,
	 * closeAllStreams);</pre>
	 *]]></haxe_doc>
		</unload>
		<loadBytes public="1" set="method">
			<f a="bytes:?context">
				<c path="flash.utils.ByteArray"/>
				<c path="flash.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Loads from binary data stored in a ByteArray object.
	 *
	 * <p>The <code>loadBytes()</code> method is asynchronous. You must wait for
	 * the "init" event before accessing the properties of a loaded object.</p>
	 *
	 * <p>When you use this method, consider the Flash Player security model,
	 * which is described in the Loader class description. </p>
	 * 
	 * @param bytes   A ByteArray object. The contents of the ByteArray can be
	 *                any of the file formats supported by the Loader class: SWF,
	 *                GIF, JPEG, or PNG.
	 * @param context A LoaderContext object. Only the
	 *                <code>applicationDomain</code> property of the
	 *                LoaderContext object applies; the
	 *                <code>checkPolicyFile</code> and
	 *                <code>securityDomain</code> properties of the LoaderContext
	 *                object do not apply.
	 *
	 *                <p>If the <code>context</code> parameter is not specified
	 *                or refers to a null object, the content is loaded into the
	 *                current security domain -  a process referred to as "import
	 *                loading" in Flash Player security documentation.
	 *                Specifically, if the loading SWF file trusts the remote SWF
	 *                by incorporating the remote SWF into its code, then the
	 *                loading SWF can import it directly into its own security
	 *                domain.</p>
	 *
	 *                <p>For more information related to security, see the Flash
	 *                Player Developer Center Topic: <a
	 *                href="http://www.adobe.com/go/devnet_security_en"
	 *                scope="external">Security</a>.</p>
	 * @throws ArgumentError         If the <code>length</code> property of the
	 *                               ByteArray object is not greater than 0.
	 * @throws IllegalOperationError If the <code>checkPolicyFile</code> or
	 *                               <code>securityDomain</code> property of the
	 *                               <code>context</code> parameter are non-null.
	 * @throws IllegalOperationError If the <code>requestedContentParent</code>
	 *                               property of the <code>context</code>
	 *                               parameter is a <code>Loader</code>.
	 * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
	 *                               parameter is set to non-null and has some
	 *                               values which are not Strings.
	 * @throws SecurityError         If the provided
	 *                               <code>applicationDomain</code> property of
	 *                               the <code>context</code> property is from a
	 *                               disallowed domain.
	 * @throws SecurityError         You cannot connect to commonly reserved
	 *                               ports. For a complete list of blocked ports,
	 *                               see "Restricting Networking APIs" in the
	 *                               <i>ActionScript 3.0 Developer's Guide</i>.
	 * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and it is not possible to
	 *                      add the loaded content as a child to the specified
	 *                      DisplayObjectContainer. This could happen if the
	 *                      loaded content is a
	 *                      <code>flash.display.AVM1Movie</code> or if the
	 *                      <code>addChild()</code> call to the
	 *                      requestedContentParent throws an error.
	 * @event complete      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the operation is complete. The
	 *                      <code>complete</code> event is always dispatched
	 *                      after the <code>init</code> event.
	 * @event init          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the properties and methods of the loaded
	 *                      data are accessible. The <code>init</code> event
	 *                      always precedes the <code>complete</code> event.
	 * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the runtime cannot parse the data in the
	 *                      byte array.
	 * @event open          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the operation starts.
	 * @event progress      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object as data is transfered in memory.
	 * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and the security sandbox
	 *                      of the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      does not have access to the loaded SWF.
	 * @event unload        Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when a loaded object is removed.]]></haxe_doc>
		</loadBytes>
		<load public="1" set="method">
			<f a="request:?context">
				<c path="flash.net.URLRequest"/>
				<c path="flash.system.LoaderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an
	 * object that is a child of this Loader object. If you load an animated GIF
	 * file, only the first frame is displayed. As the Loader object can contain
	 * only a single child, issuing a subsequent <code>load()</code> request
	 * terminates the previous request, if still pending, and commences a new
	 * load.
	 *
	 * <p><b>Note</b>: In AIR 1.5 and Flash Player 10, the maximum size for a
	 * loaded image is 8,191 pixels in width or height, and the total number of
	 * pixels cannot exceed 16,777,215 pixels.(So, if an loaded image is 8,191
	 * pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and
	 * earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height
	 * and 2,880 pixels in width.</p>
	 *
	 * <p>A SWF file or image loaded into a Loader object inherits the position,
	 * rotation, and scale properties of the parent display objects of the Loader
	 * object. </p>
	 *
	 * <p>Use the <code>unload()</code> method to remove movies or images loaded
	 * with this method, or to cancel a load operation that is in progress.</p>
	 *
	 * <p>You can prevent a SWF file from using this method by setting the
	 * <code>allowNetworking</code> parameter of the the <code>object</code> and
	 * <code>embed</code> tags in the HTML page that contains the SWF
	 * content.</p>
	 *
	 * <p>When you use this method, consider the Flash Player security model,
	 * which is described in the Loader class description. </p>
	 *
	 * <p> In Flash Player 10 and later, if you use a multipart Content-Type(for
	 * example "multipart/form-data") that contains an upload(indicated by a
	 * "filename" parameter in a "content-disposition" header within the POST
	 * body), the POST operation is subject to the security rules applied to
	 * uploads:</p>
	 *
	 * <ul>
	 *   <li>The POST operation must be performed in response to a user-initiated
	 * action, such as a mouse click or key press.</li>
	 *   <li>If the POST operation is cross-domain(the POST target is not on the
	 * same server as the SWF file that is sending the POST request), the target
	 * server must provide a URL policy file that permits cross-domain
	 * access.</li>
	 * </ul>
	 *
	 * <p>Also, for any multipart Content-Type, the syntax must be valid
	 * (according to the RFC2046 standard). If the syntax appears to be invalid,
	 * the POST operation is subject to the security rules applied to
	 * uploads.</p>
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @param request The absolute or relative URL of the SWF, JPEG, GIF, or PNG
	 *                file to be loaded. A relative path must be relative to the
	 *                main SWF file. Absolute URLs must include the protocol
	 *                reference, such as http:// or file:///. Filenames cannot
	 *                include disk drive specifications.
	 * @param context A LoaderContext object, which has properties that define
	 *                the following:
	 *                <ul>
	 *                  <li>Whether or not to check for the existence of a policy
	 *                file upon loading the object</li>
	 *                  <li>The ApplicationDomain for the loaded object</li>
	 *                  <li>The SecurityDomain for the loaded object</li>
	 *                  <li>The ImageDecodingPolicy for the loaded image
	 *                object</li>
	 *                </ul>
	 *
	 *                <p>If the <code>context</code> parameter is not specified
	 *                or refers to a null object, the loaded content remains in
	 *                its own security domain.</p>
	 *
	 *                <p>For complete details, see the description of the
	 *                properties in the <a
	 *                href="../system/LoaderContext.html">LoaderContext</a>
	 *                class.</p>
	 * @throws IOError               The <code>digest</code> property of the
	 *                               <code>request</code> object is not
	 *                               <code>null</code>. You should only set the
	 *                               <code>digest</code> property of a URLRequest
	 *                               object when calling the
	 *                               <code>URLLoader.load()</code> method when
	 *                               loading a SWZ file(an Adobe platform
	 *                               component).
	 * @throws IllegalOperationError If the <code>requestedContentParent</code>
	 *                               property of the <code>context</code>
	 *                               parameter is a <code>Loader</code>.
	 * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
	 *                               parameter is set to non-null and has some
	 *                               values which are not Strings.
	 * @throws SecurityError         The value of
	 *                               <code>LoaderContext.securityDomain</code>
	 *                               must be either <code>null</code> or
	 *                               <code>SecurityDomain.currentDomain</code>.
	 *                               This reflects the fact that you can only
	 *                               place the loaded media in its natural
	 *                               security sandbox or your own(the latter
	 *                               requires a policy file).
	 * @throws SecurityError         Local SWF files may not set
	 *                               LoaderContext.securityDomain to anything
	 *                               other than <code>null</code>. It is not
	 *                               permitted to import non-local media into a
	 *                               local sandbox, or to place other local media
	 *                               in anything other than its natural sandbox.
	 * @throws SecurityError         You cannot connect to commonly reserved
	 *                               ports. For a complete list of blocked ports,
	 *                               see "Restricting Networking APIs" in the
	 *                               <i>ActionScript 3.0 Developer's Guide</i>.
	 * @throws SecurityError         If the <code>applicationDomain</code> or
	 *                               <code>securityDomain</code> properties of
	 *                               the <code>context</code> parameter are from
	 *                               a disallowed domain.
	 * @throws SecurityError         If a local SWF file is attempting to use the
	 *                               <code>securityDomain</code> property of the
	 *                               <code>context</code> parameter.
	 * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and it is not possible to
	 *                      add the loaded content as a child to the specified
	 *                      DisplayObjectContainer. This could happen if the
	 *                      loaded content is a
	 *                      <code>flash.display.AVM1Movie</code> or if the
	 *                      <code>addChild()</code> call to the
	 *                      requestedContentParent throws an error.
	 * @event complete      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the file has completed loading. The
	 *                      <code>complete</code> event is always dispatched
	 *                      after the <code>init</code> event.
	 * @event httpStatus    Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when a network request is made over HTTP and
	 *                      Flash Player can detect the HTTP status code.
	 * @event init          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the properties and methods of the loaded
	 *                      SWF file are accessible. The <code>init</code> event
	 *                      always precedes the <code>complete</code> event.
	 * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when an input or output error occurs that
	 *                      causes a load operation to fail.
	 * @event open          Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when the loading operation starts.
	 * @event progress      Dispatched by the <code>contentLoaderInfo</code>
	 *                      object as data is received while load operation
	 *                      progresses.
	 * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if a SWF file in the local-with-filesystem
	 *                      sandbox attempts to load content in the
	 *                      local-with-networking sandbox, or vice versa.
	 * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	 *                      object if the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      property has been specified and the security sandbox
	 *                      of the
	 *                      <code>LoaderContext.requestedContentParent</code>
	 *                      does not have access to the loaded SWF.
	 * @event unload        Dispatched by the <code>contentLoaderInfo</code>
	 *                      object when a loaded object is removed.]]></haxe_doc>
		</load>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Cancels a <code>load()</code> method operation that is currently in
	 * progress for the Loader instance.
	 *]]></haxe_doc>
		</close>
		<contentLoaderInfo public="1" set="null">
			<c path="flash.display.LoaderInfo"/>
			<haxe_doc><![CDATA[* Returns a LoaderInfo object corresponding to the object being loaded.
	 * LoaderInfo objects are shared between the Loader object and the loaded
	 * content object. The LoaderInfo object supplies loading progress
	 * information and statistics about the loaded file.
	 *
	 * <p>Events related to the load are dispatched by the LoaderInfo object
	 * referenced by the <code>contentLoaderInfo</code> property of the Loader
	 * object. The <code>contentLoaderInfo</code> property is set to a valid
	 * LoaderInfo object, even before the content is loaded, so that you can add
	 * event listeners to the object prior to the load.</p>
	 *
	 * <p>To detect uncaught errors that happen in a loaded SWF, use the
	 * <code>Loader.uncaughtErrorEvents</code> property, not the
	 * <code>Loader.contentLoaderInfo.uncaughtErrorEvents</code> property.</p>]]></haxe_doc>
		</contentLoaderInfo>
		<content public="1" set="null">
			<c path="flash.display.DisplayObject"/>
			<haxe_doc><![CDATA[* Contains the root display object of the SWF file or image(JPG, PNG, or
	 * GIF) file that was loaded by using the <code>load()</code> or
	 * <code>loadBytes()</code> methods.
	 * 
	 * @throws SecurityError The loaded SWF file or image file belongs to a
	 *                       security sandbox to which you do not have access.
	 *                       For a loaded SWF file, you can avoid this situation
	 *                       by having the file call the
	 *                       <code>Security.allowDomain()</code> method or by
	 *                       having the loading file specify a
	 *                       <code>loaderContext</code> parameter with its
	 *                       <code>securityDomain</code> property set to
	 *                       <code>SecurityDomain.currentDomain</code> when you
	 *                       call the <code>load()</code> or
	 *                       <code>loadBytes()</code> method.]]></haxe_doc>
		</content>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* An object that dispatches an <code>uncaughtError</code> event when an
	 * unhandled error occurs in the SWF that's loaded by this Loader object. An
	 * uncaught error happens when an error is thrown outside of any
	 * <code>try..catch</code> blocks or when an ErrorEvent object is dispatched
	 * with no registered listeners.
	 *
	 * <p>Note that a Loader object's <code>uncaughtErrorEvents</code> property
	 * dispatches events that bubble through it, not events that it dispatches
	 * directly. It never dispatches an <code>uncaughtErrorEvent</code> in the
	 * target phase. It only dispatches the event in the capture and bubbling
	 * phases. To detect an uncaught error in the current SWF(the SWF in which
	 * the Loader object is defined) use the
	 * <code>LoaderInfo.uncaughtErrorEvents</code> property instead.</p>
	 *
	 * <p>If the content loaded by the Loader object is an AVM1(ActionScript 2)
	 * SWF file, uncaught errors in the AVM1 SWF file do not result in an
	 * <code>uncaughtError</code> event.</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Loader class is used to load SWF files or image(JPG, PNG, or GIF)
 * files. Use the <code>load()</code> method to initiate loading. The loaded
 * display object is added as a child of the Loader object.
 *
 * <p>Use the URLLoader class to load text or binary data.</p>
 *
 * <p>The Loader class overrides the following methods that it inherits,
 * because a Loader object can only have one child display object - the
 * display object that it loads. Calling the following methods throws an
 * exception: <code>addChild()</code>, <code>addChildAt()</code>,
 * <code>removeChild()</code>, <code>removeChildAt()</code>, and
 * <code>setChildIndex()</code>. To remove a loaded display object, you must
 * remove the <i>Loader</i> object from its parent DisplayObjectContainer
 * child array. </p>
 *
 * <p><b>Note:</b> The ActionScript 2.0 MovieClipLoader and LoadVars classes
 * are not used in ActionScript 3.0. The Loader and URLLoader classes replace
 * them.</p>
 *
 * <p>When you use the Loader class, consider the Flash Player and Adobe AIR
 * security model: </p>
 *
 * <ul>
 *   <li>You can load content from any accessible source. </li>
 *   <li>Loading is not allowed if the calling SWF file is in a network
 * sandbox and the file to be loaded is local. </li>
 *   <li>If the loaded content is a SWF file written with ActionScript 3.0, it
 * cannot be cross-scripted by a SWF file in another security sandbox unless
 * that cross-scripting arrangement was approved through a call to the
 * <code>System.allowDomain()</code> or the
 * <code>System.allowInsecureDomain()</code> method in the loaded content
 * file.</li>
 *   <li>If the loaded content is an AVM1 SWF file(written using ActionScript
 * 1.0 or 2.0), it cannot be cross-scripted by an AVM2 SWF file(written using
 * ActionScript 3.0). However, you can communicate between the two SWF files
 * by using the LocalConnection class.</li>
 *   <li>If the loaded content is an image, its data cannot be accessed by a
 * SWF file outside of the security sandbox, unless the domain of that SWF
 * file was included in a URL policy file at the origin domain of the
 * image.</li>
 *   <li>Movie clips in the local-with-file-system sandbox cannot script movie
 * clips in the local-with-networking sandbox, and the reverse is also
 * prevented. </li>
 *   <li>You cannot connect to commonly reserved ports. For a complete list of
 * blocked ports, see "Restricting Networking APIs" in the <i>ActionScript 3.0
 * Developer's Guide</i>. </li>
 * </ul>
 *
 * <p>However, in AIR, content in the <code>application</code> security
 * sandbox(content installed with the AIR application) are not restricted by
 * these security limitations.</p>
 *
 * <p>For more information related to security, see the Flash Player Developer
 * Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
 * scope="external">Security</a>.</p>
 *
 * <p>When loading a SWF file from an untrusted source(such as a domain other
 * than that of the Loader object's root SWF file), you may want to define a
 * mask for the Loader object, to prevent the loaded content(which is a child
 * of the Loader object) from drawing to portions of the Stage outside of that
 * mask, as shown in the following code:</p>]]></haxe_doc>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<width public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The nominal width of the loaded content. This value might differ from the
	 * actual width at which the content is displayed, since the loaded content
	 * or its parent display objects might be scaled.
	 * 
	 * @throws Error If the file is not downloaded sufficiently to retrieve the
	 *               requested information.</haxe_doc>
		</width>
		<url public="1" set="null">
			<c path="String"/>
			<haxe_doc><![CDATA[* The file format version of the loaded SWF file. The file format is
	 * specified using the enumerations in the SWFVersion class, such as
	 * <code>SWFVersion.FLASH7</code> and <code>SWFVersion.FLASH9</code>.
	 * 
	 * @throws Error If the file is not downloaded sufficiently to retrieve the
	 *               requested information.
	 * @throws Error If the file is not a SWF file.]]></haxe_doc>
		</url>
		<sharedEvents public="1" set="null">
			<c path="flash.events.EventDispatcher"/>
			<haxe_doc><![CDATA[* An EventDispatcher instance that can be used to exchange events across
	 * security boundaries. Even when the Loader object and the loaded content
	 * originate from security domains that do not trust one another, both can
	 * access <code>sharedEvents</code> and send and receive events via this
	 * object.]]></haxe_doc>
		</sharedEvents>
		<sameDomain public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Expresses the domain relationship between the loader and the content:
	 * <code>true</code> if they have the same origin domain; <code>false</code>
	 * otherwise.
	 * 
	 * @throws Error Thrown if the file is not downloaded sufficiently to
	 *               retrieve the requested information.]]></haxe_doc>
		</sameDomain>
		<parentAllowsChild public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Expresses the trust relationship from Loader(parent) to the content
	 * (child). If the parent has allowed the child access, <code>true</code>;
	 * otherwise, <code>false</code>. This property is set to <code>true</code>
	 * if the parent object called the <code>allowDomain()</code> method to grant
	 * permission to the child domain or if a URL policy file is loaded at the
	 * parent domain granting permission to the child domain. If child and parent
	 * are in the same domain, this property is set to <code>true</code>.
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @throws Error Thrown if the file is not downloaded sufficiently to
	 *               retrieve the requested information.]]></haxe_doc>
		</parentAllowsChild>
		<parameters public="1" set="null">
			<d><c path="String"/></d>
			<haxe_doc><![CDATA[* An object that contains name-value pairs that represent the parameters
	 * provided to the loaded SWF file.
	 *
	 * <p>You can use a <code>for-in</code> loop to extract all the names and
	 * values from the <code>parameters</code> object.</p>
	 *
	 * <p>The two sources of parameters are: the query string in the URL of the
	 * main SWF file, and the value of the <code>FlashVars</code> HTML parameter
	 * (this affects only the main SWF file).</p>
	 *
	 * <p>The <code>parameters</code> property replaces the ActionScript 1.0 and
	 * 2.0 technique of providing SWF file parameters as properties of the main
	 * timeline.</p>
	 *
	 * <p>The value of the <code>parameters</code> property is null for Loader
	 * objects that contain SWF files that use ActionScript 1.0 or 2.0. It is
	 * only non-null for Loader objects that contain SWF files that use
	 * ActionScript 3.0.</p>]]></haxe_doc>
		</parameters>
		<loaderURL public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The URL of the SWF file that initiated the loading of the media described
	 * by this LoaderInfo object. For the instance of the main class of the SWF
	 * file, this URL is the same as the SWF file's own URL.</haxe_doc>
		</loaderURL>
		<loader public="1" set="null">
			<c path="flash.display.Loader"/>
			<haxe_doc><![CDATA[* Indicates if the <code>LoaderInfo.url</code> property has been truncated.
	 * When the <code>isURLInaccessible</code> value is <code>true</code> the
	 * <code>LoaderInfo.url</code> value is only the domain of the final URL from
	 * which the content loaded. For example, the property is truncated if the
	 * content is loaded from <code>http://www.adobe.com/assets/hello.swf</code>,
	 * and the <code>LoaderInfo.url</code> property has the value
	 * <code>http://www.adobe.com</code>. The <code>isURLInaccessible</code>
	 * value is <code>true</code> only when all of the following are also true:
	 * <ul>
	 *   <li>An HTTP redirect occurred while loading the content.</li>
	 *   <li>The SWF file calling <code>Loader.load()</code> is from a different
	 * domain than the content's final URL.</li>
	 *   <li>The SWF file calling <code>Loader.load()</code> does not have
	 * permission to access the content. Permission is granted to access the
	 * content the same way permission is granted for
	 * <code>BitmapData.draw()</code>: call <code>Security.allowDomain()</code>
	 * to access a SWF file(or for non-SWF file content, establish a policy file
	 * and use the <code>LoaderContext.checkPolicyFile</code> property).</li>
	 * </ul>
	 *
	 * <p><b>Note:</b> The <code>isURLInaccessible</code> property was added for
	 * Flash Player 10.1 and AIR 2.0. However, this property is made available to
	 * SWF files of all versions when the Flash runtime supports it. So, using
	 * some authoring tools in "strict mode" causes a compilation error. To work
	 * around the error use the indirect syntax
	 * <code>myLoaderInfo["isURLInaccessible"]</code>, or disable strict mode. If
	 * you are using Flash Professional CS5 or Flex SDK 4.1, you can use and
	 * compile this API for runtimes released before Flash Player 10.1 and AIR
	 * 2.</p>
	 *
	 * <p>For application content in AIR, the value of this property is always
	 * <code>false</code>.</p>]]></haxe_doc>
		</loader>
		<height public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The nominal height of the loaded file. This value might differ from the
	 * actual height at which the content is displayed, since the loaded content
	 * or its parent display objects might be scaled.
	 * 
	 * @throws Error If the file is not downloaded sufficiently to retrieve the
	 *               requested information.</haxe_doc>
		</height>
		<frameRate public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The nominal frame rate, in frames per second, of the loaded SWF file. This
	 * number is often an integer, but need not be.
	 *
	 * <p>This value may differ from the actual frame rate in use. Flash Player
	 * or Adobe AIR only uses a single frame rate for all loaded SWF files at any
	 * one time, and this frame rate is determined by the nominal frame rate of
	 * the main SWF file. Also, the main frame rate may not be able to be
	 * achieved, depending on hardware, sound synchronization, and other
	 * factors.</p>
	 * 
	 * @throws Error If the file is not downloaded sufficiently to retrieve the
	 *               requested information.
	 * @throws Error If the file is not a SWF file.]]></haxe_doc>
		</frameRate>
		<contentType public="1" set="null">
			<c path="String"/>
			<haxe_doc><![CDATA[* The MIME type of the loaded file. The value is <code>null</code> if not
	 * enough of the file has loaded in order to determine the type. The
	 * following list gives the possible values:
	 * <ul>
	 *   <li><code>"application/x-shockwave-flash"</code></li>
	 *   <li><code>"image/jpeg"</code></li>
	 *   <li><code>"image/gif"</code></li>
	 *   <li><code>"image/png"</code></li>
	 * </ul>]]></haxe_doc>
		</contentType>
		<content public="1" set="null">
			<c path="flash.display.DisplayObject"/>
			<haxe_doc><![CDATA[* Expresses the trust relationship from content(child) to the Loader
	 * (parent). If the child has allowed the parent access, <code>true</code>;
	 * otherwise, <code>false</code>. This property is set to <code>true</code>
	 * if the child object has called the <code>allowDomain()</code> method to
	 * grant permission to the parent domain or if a URL policy is loaded at the
	 * child domain that grants permission to the parent domain. If child and
	 * parent are in the same domain, this property is set to <code>true</code>.
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @throws Error Thrown if the file is not downloaded sufficiently to
	 *               retrieve the requested information.]]></haxe_doc>
		</content>
		<bytesTotal public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The number of compressed bytes in the entire media file.
	 *
	 * <p>Before the first <code>progress</code> event is dispatched by this
	 * LoaderInfo object's corresponding Loader object, <code>bytesTotal</code>
	 * is 0. After the first <code>progress</code> event from the Loader object,
	 * <code>bytesTotal</code> reflects the actual number of bytes to be
	 * downloaded.</p>]]></haxe_doc>
		</bytesTotal>
		<bytesLoaded public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The number of bytes that are loaded for the media. When this number equals
	 * the value of <code>bytesTotal</code>, all of the bytes are loaded.]]></haxe_doc>
		</bytesLoaded>
		<bytes public="1" set="null">
			<c path="flash.utils.ByteArray"/>
			<haxe_doc><![CDATA[* The bytes associated with a LoaderInfo object.
	 * 
	 * @throws SecurityError If the object accessing this API is prevented from
	 *                       accessing the loaded object due to security
	 *                       restrictions. This situation can occur, for
	 *                       instance, when a Loader object attempts to access
	 *                       the <code>contentLoaderInfo.content</code> property
	 *                       and it is not granted security permission to access
	 *                       the loaded content.
	 *
	 *                       <p>For more information related to security, see the
	 *                       Flash Player Developer Center Topic: <a
	 *                       href="http://www.adobe.com/go/devnet_security_en"
	 *                       scope="external">Security</a>.</p>]]></haxe_doc>
		</bytes>
		<applicationDomain public="1" set="null">
			<c path="flash.system.ApplicationDomain"/>
			<haxe_doc><![CDATA[* The ActionScript version of the loaded SWF file. The language version is
	 * specified by using the enumerations in the ActionScriptVersion class, such
	 * as <code>ActionScriptVersion.ACTIONSCRIPT2</code> and
	 * <code>ActionScriptVersion.ACTIONSCRIPT3</code>.
	 *
	 * <p><b>Note:</b> This property always has a value of either
	 * <code>ActionScriptVersion.ACTIONSCRIPT2</code> or
	 * <code>ActionScriptVersion.ACTIONSCRIPT3</code>. ActionScript 1.0 and 2.0
	 * are both reported as <code>ActionScriptVersion.ACTIONSCRIPT2</code>
	 * (version 2.0). This property only distinguishes ActionScript 1.0 and 2.0
	 * from ActionScript 3.0.</p>
	 * 
	 * @throws Error If the file is not downloaded sufficiently to retrieve the
	 *               requested information.
	 * @throws Error If the file is not a SWF file.]]></haxe_doc>
		</applicationDomain>
		<haxe_doc><![CDATA[* The LoaderInfo class provides information about a loaded SWF file or a
 * loaded image file(JPEG, GIF, or PNG). LoaderInfo objects are available for
 * any display object. The information provided includes load progress, the
 * URLs of the loader and loaded content, the number of bytes total for the
 * media, and the nominal height and width of the media.
 *
 * <p>You can access LoaderInfo objects in two ways: </p>
 *
 * <ul>
 *   <li>The <code>contentLoaderInfo</code> property of a flash.display.Loader
 * object -  The <code>contentLoaderInfo</code> property is always available
 * for any Loader object. For a Loader object that has not called the
 * <code>load()</code> or <code>loadBytes()</code> method, or that has not
 * sufficiently loaded, attempting to access many of the properties of the
 * <code>contentLoaderInfo</code> property throws an error.</li>
 *   <li>The <code>loaderInfo</code> property of a display object. </li>
 * </ul>
 *
 * <p>The <code>contentLoaderInfo</code> property of a Loader object provides
 * information about the content that the Loader object is loading, whereas
 * the <code>loaderInfo</code> property of a DisplayObject provides
 * information about the root SWF file for that display object. </p>
 *
 * <p>When you use a Loader object to load a display object(such as a SWF
 * file or a bitmap), the <code>loaderInfo</code> property of the display
 * object is the same as the <code>contentLoaderInfo</code> property of the
 * Loader object(<code>DisplayObject.loaderInfo =
 * Loader.contentLoaderInfo</code>). Because the instance of the main class of
 * the SWF file has no Loader object, the <code>loaderInfo</code> property is
 * the only way to access the LoaderInfo for the instance of the main class of
 * the SWF file.</p>
 *
 * <p>The following diagram shows the different uses of the LoaderInfo
 * object - for the instance of the main class of the SWF file, for the
 * <code>contentLoaderInfo</code> property of a Loader object, and for the
 * <code>loaderInfo</code> property of a loaded object:</p>
 *
 * <p>When a loading operation is not complete, some properties of the
 * <code>contentLoaderInfo</code> property of a Loader object are not
 * available. You can obtain some properties, such as
 * <code>bytesLoaded</code>, <code>bytesTotal</code>, <code>url</code>,
 * <code>loaderURL</code>, and <code>applicationDomain</code>. When the
 * <code>loaderInfo</code> object dispatches the <code>init</code> event, you
 * can access all properties of the <code>loaderInfo</code> object and the
 * loaded image or SWF file.</p>
 *
 * <p><b>Note:</b> All properties of LoaderInfo objects are read-only.</p>
 *
 * <p>The <code>EventDispatcher.dispatchEvent()</code> method is not
 * applicable to LoaderInfo objects. If you call <code>dispatchEvent()</code>
 * on a LoaderInfo object, an IllegalOperationError exception is thrown.</p>
 * 
 * @event complete   Dispatched when data has loaded successfully. In other
 *                   words, it is dispatched when all the content has been
 *                   downloaded and the loading has finished. The
 *                   <code>complete</code> event is always dispatched after
 *                   the <code>init</code> event. The <code>init</code> event
 *                   is dispatched when the object is ready to access, though
 *                   the content may still be downloading.
 * @event httpStatus Dispatched when a network request is made over HTTP and
 *                   an HTTP status code can be detected.
 * @event init       Dispatched when the properties and methods of a loaded
 *                   SWF file are accessible and ready for use. The content,
 *                   however, can still be downloading. A LoaderInfo object
 *                   dispatches the <code>init</code> event when the following
 *                   conditions exist:
 *                   <ul>
 *                     <li>All properties and methods associated with the
 *                   loaded object and those associated with the LoaderInfo
 *                   object are accessible.</li>
 *                     <li>The constructors for all child objects have
 *                   completed.</li>
 *                     <li>All ActionScript code in the first frame of the
 *                   loaded SWF's main timeline has been executed.</li>
 *                   </ul>
 *
 *                   <p>For example, an <code>Event.INIT</code> is dispatched
 *                   when the first frame of a movie or animation is loaded.
 *                   The movie is then accessible and can be added to the
 *                   display list. The complete movie, however, can take
 *                   longer to download. The <code>Event.COMPLETE</code> is
 *                   only dispatched once the full movie is loaded.</p>
 *
 *                   <p>The <code>init</code> event always precedes the
 *                   <code>complete</code> event.</p>
 * @event ioError    Dispatched when an input or output error occurs that
 *                   causes a load operation to fail.
 * @event open       Dispatched when a load operation starts.
 * @event progress   Dispatched when data is received as the download
 *                   operation progresses.
 * @event unload     Dispatched by a LoaderInfo object whenever a loaded
 *                   object is removed by using the <code>unload()</code>
 *                   method of the Loader object, or when a second load is
 *                   performed by the same Loader object and the original
 *                   content is removed prior to the load beginning.]]></haxe_doc>
	</class>
	<class path="flash.display.Sprite" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopDrag public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Ends the <code>startDrag()</code> method. A sprite that was made draggable
	 * with the <code>startDrag()</code> method remains draggable until a
	 * <code>stopDrag()</code> method is added, or until another sprite becomes
	 * draggable. Only one sprite is draggable at a time.
	 *]]></haxe_doc>
		</stopDrag>
		<startDrag public="1" set="method">
			<f a="?lockCenter:?bounds">
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Lets the user drag the specified sprite. The sprite remains draggable
	 * until explicitly stopped through a call to the
	 * <code>Sprite.stopDrag()</code> method, or until another sprite is made
	 * draggable. Only one sprite is draggable at a time.
	 *
	 * <p>Three-dimensional display objects follow the pointer and
	 * <code>Sprite.startDrag()</code> moves the object within the
	 * three-dimensional plane defined by the display object. Or, if the display
	 * object is a two-dimensional object and the child of a three-dimensional
	 * object, the two-dimensional object moves within the three dimensional
	 * plane defined by the three-dimensional parent object.</p>
	 * 
	 * @param lockCenter Specifies whether the draggable sprite is locked to the
	 *                   center of the pointer position(<code>true</code>), or
	 *                   locked to the point where the user first clicked the
	 *                   sprite(<code>false</code>).
	 * @param bounds     Value relative to the coordinates of the Sprite's parent
	 *                   that specify a constraint rectangle for the Sprite.]]></haxe_doc>
		</startDrag>
		<useHandCursor public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* A Boolean value that indicates whether the pointing hand(hand cursor)
	 * appears when the pointer rolls over a sprite in which the
	 * <code>buttonMode</code> property is set to <code>true</code>. The default
	 * value of the <code>useHandCursor</code> property is <code>true</code>. If
	 * <code>useHandCursor</code> is set to <code>true</code>, the pointing hand
	 * used for buttons appears when the pointer rolls over a button sprite. If
	 * <code>useHandCursor</code> is <code>false</code>, the arrow pointer is
	 * used instead.
	 *
	 * <p>You can change the <code>useHandCursor</code> property at any time; the
	 * modified sprite immediately takes on the new cursor appearance. </p>
	 *
	 * <p><b>Note:</b> In Flex or Flash Builder, if your sprite has child
	 * sprites, you might want to set the <code>mouseChildren</code> property to
	 * <code>false</code>. For example, if you want a hand cursor to appear over
	 * a Flex <mx:Label> control, set the <code>useHandCursor</code> and
	 * <code>buttonMode</code> properties to <code>true</code>, and the
	 * <code>mouseChildren</code> property to <code>false</code>.</p>]]></haxe_doc>
		</useHandCursor>
		<soundTransform public="1">
			<c path="flash.media.SoundTransform"/>
			<haxe_doc><![CDATA[* Controls sound within this sprite.
	 *
	 * <p><b>Note:</b> This property does not affect HTML content in an
	 * HTMLControl object(in Adobe AIR).</p>]]></haxe_doc>
		</soundTransform>
		<hitArea public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc><![CDATA[* Designates another sprite to serve as the hit area for a sprite. If the
	 * <code>hitArea</code> property does not exist or the value is
	 * <code>null</code> or <code>undefined</code>, the sprite itself is used as
	 * the hit area. The value of the <code>hitArea</code> property can be a
	 * reference to a Sprite object.
	 *
	 * <p>You can change the <code>hitArea</code> property at any time; the
	 * modified sprite immediately uses the new hit area behavior. The sprite
	 * designated as the hit area does not need to be visible; its graphical
	 * shape, although not visible, is still detected as the hit area.</p>
	 *
	 * <p><b>Note:</b> You must set to <code>false</code> the
	 * <code>mouseEnabled</code> property of the sprite designated as the hit
	 * area. Otherwise, your sprite button might not work because the sprite
	 * designated as the hit area receives the user input events instead of your
	 * sprite button.</p>]]></haxe_doc>
		</hitArea>
		<graphics public="1" set="null">
			<c path="flash.display.Graphics"/>
			<haxe_doc>* Specifies the Graphics object that belongs to this sprite where vector
	 * drawing commands can occur.</haxe_doc>
		</graphics>
		<dropTarget public="1" set="null">
			<c path="flash.display.DisplayObject"/>
			<haxe_doc>* Specifies the display object over which the sprite is being dragged, or on
	 * which the sprite was dropped.</haxe_doc>
		</dropTarget>
		<buttonMode public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies the button mode of this sprite. If <code>true</code>, this
	 * sprite behaves as a button, which means that it triggers the display of
	 * the hand cursor when the pointer passes over the sprite and can receive a
	 * <code>click</code> event if the enter or space keys are pressed when the
	 * sprite has focus. You can suppress the display of the hand cursor by
	 * setting the <code>useHandCursor</code> property to <code>false</code>, in
	 * which case the pointer is displayed.
	 *
	 * <p>Although it is better to use the SimpleButton class to create buttons,
	 * you can use the <code>buttonMode</code> property to give a sprite some
	 * button-like functionality. To include a sprite in the tab order, set the
	 * <code>tabEnabled</code> property(inherited from the InteractiveObject
	 * class and <code>false</code> by default) to <code>true</code>.
	 * Additionally, consider whether you want the children of your sprite to be
	 * user input enabled. Most buttons do not enable user input interactivity
	 * for their child objects because it confuses the event flow. To disable
	 * user input interactivity for all child objects, you must set the
	 * <code>mouseChildren</code> property(inherited from the
	 * DisplayObjectContainer class) to <code>false</code>.</p>
	 *
	 * <p>If you use the <code>buttonMode</code> property with the MovieClip
	 * class(which is a subclass of the Sprite class), your button might have
	 * some added functionality. If you include frames labeled _up, _over, and
	 * _down, Flash Player provides automatic state changes(functionality
	 * similar to that provided in previous versions of ActionScript for movie
	 * clips used as buttons). These automatic state changes are not available
	 * for sprites, which have no timeline, and thus no frames to label. </p>]]></haxe_doc>
		</buttonMode>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Creates a new Sprite instance. After you create the Sprite instance, call
	 * the <code>DisplayObjectContainer.addChild()</code> or
	 * <code>DisplayObjectContainer.addChildAt()</code> method to add the Sprite
	 * to a parent DisplayObjectContainer.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Sprite class is a basic display list building block: a display list
 * node that can display graphics and can also contain children.
 *
 * <p>A Sprite object is similar to a movie clip, but does not have a
 * timeline. Sprite is an appropriate base class for objects that do not
 * require timelines. For example, Sprite would be a logical base class for
 * user interface(UI) components that typically do not use the timeline.</p>
 *
 * <p>The Sprite class is new in ActionScript 3.0. It provides an alternative
 * to the functionality of the MovieClip class, which retains all the
 * functionality of previous ActionScript releases to provide backward
 * compatibility.</p>]]></haxe_doc>
	</class>
	<class path="flash.display.MovieClip" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the playhead in the movie clip.
	 *</haxe_doc>
		</stop>
		<prevScene public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Moves the playhead to the previous scene of the MovieClip instance. This
	 * happens after all remaining actions in the frame have finished executing.
	 *</haxe_doc>
		</prevScene>
		<prevFrame public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sends the playhead to the previous frame and stops it. This happens after
	 * all remaining actions in the frame have finished executing.
	 *</haxe_doc>
		</prevFrame>
		<play public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Moves the playhead in the timeline of the movie clip.
	 *</haxe_doc>
		</play>
		<nextScene public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Moves the playhead to the next scene of the MovieClip instance. This
	 * happens after all remaining actions in the frame have finished executing.
	 *</haxe_doc>
		</nextScene>
		<nextFrame public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sends the playhead to the next frame and stops it. This happens after all
	 * remaining actions in the frame have finished executing.
	 *</haxe_doc>
		</nextFrame>
		<gotoAndStop public="1" set="method">
			<f a="frame:?scene">
				<t path="flash.utils.Object"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Brings the playhead to the specified frame of the movie clip and stops it
	 * there. This happens after all remaining actions in the frame have finished
	 * executing. If you want to specify a scene in addition to a frame, specify
	 * a <code>scene</code> parameter.
	 * 
	 * @param frame A number representing the frame number, or a string
	 *              representing the label of the frame, to which the playhead is
	 *              sent. If you specify a number, it is relative to the scene
	 *              you specify. If you do not specify a scene, the current scene
	 *              determines the global frame number at which to go to and
	 *              stop. If you do specify a scene, the playhead goes to the
	 *              frame number in the specified scene and stops.
	 * @param scene The name of the scene. This parameter is optional.
	 * @throws ArgumentError If the <code>scene</code> or <code>frame</code>
	 *                       specified are not found in this movie clip.]]></haxe_doc>
		</gotoAndStop>
		<gotoAndPlay public="1" set="method">
			<f a="frame:?scene">
				<t path="flash.utils.Object"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Starts playing the SWF file at the specified frame. This happens after all
	 * remaining actions in the frame have finished executing. To specify a scene
	 * as well as a frame, specify a value for the <code>scene</code> parameter.
	 * 
	 * @param frame A number representing the frame number, or a string
	 *              representing the label of the frame, to which the playhead is
	 *              sent. If you specify a number, it is relative to the scene
	 *              you specify. If you do not specify a scene, the current scene
	 *              determines the global frame number to play. If you do specify
	 *              a scene, the playhead jumps to the frame number in the
	 *              specified scene.
	 * @param scene The name of the scene to play. This parameter is optional.]]></haxe_doc>
		</gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether other display objects that are SimpleButton or MovieClip
	 * objects can receive mouse release events or other user input release
	 * events. The <code>trackAsMenu</code> property lets you create menus. You
	 * can set the <code>trackAsMenu</code> property on any SimpleButton or
	 * MovieClip object. The default value of the <code>trackAsMenu</code>
	 * property is <code>false</code>.
	 *
	 * <p>You can change the <code>trackAsMenu</code> property at any time; the
	 * modified movie clip immediately uses the new behavior.</p>]]></haxe_doc>
		</trackAsMenu>
		<totalFrames public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* An array of Scene objects, each listing the name, the number of frames,
	 * and the frame labels for a scene in the MovieClip instance.</haxe_doc>
		</totalFrames>
		<framesLoaded public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The number of frames that are loaded from a streaming SWF file. You can
	 * use the <code>framesLoaded</code> property to determine whether the
	 * contents of a specific frame and all the frames before it loaded and are
	 * available locally in the browser. You can also use it to monitor the
	 * downloading of large SWF files. For example, you might want to display a
	 * message to users indicating that the SWF file is loading until a specified
	 * frame in the SWF file finishes loading.
	 *
	 * <p>If the movie clip contains multiple scenes, the
	 * <code>framesLoaded</code> property returns the number of frames loaded for
	 * <i>all</i> scenes in the movie clip.</p>]]></haxe_doc>
		</framesLoaded>
		<enabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Returns an array of FrameLabel objects from the current scene. If the
	 * MovieClip instance does not use scenes, the array includes all frame
	 * labels from the entire MovieClip instance.</haxe_doc>
		</enabled>
		<currentLabel public="1" set="null">
			<c path="String"/>
			<haxe_doc><![CDATA[* The current label in which the playhead is located in the timeline of the
	 * MovieClip instance. If the current frame has no label,
	 * <code>currentLabel</code> is set to the name of the previous frame that
	 * includes a label. If the current frame and previous frames do not include
	 * a label, <code>currentLabel</code> returns <code>null</code>.]]></haxe_doc>
		</currentLabel>
		<currentFrame public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Specifies the number of the frame in which the playhead is located in the
	 * timeline of the MovieClip instance. If the movie clip has multiple scenes,
	 * this value is the frame number in the current scene.</haxe_doc>
		</currentFrame>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Creates a new MovieClip instance. After creating the MovieClip, call the
	 * <code>addChild()</code> or <code>addChildAt()</code> method of a display
	 * object container that is onstage.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The MovieClip class inherits from the following classes: Sprite,
 * DisplayObjectContainer, InteractiveObject, DisplayObject, and
 * EventDispatcher.
 *
 * <p>Unlike the Sprite object, a MovieClip object has a timeline.</p>
 *
 * <p>>In Flash Professional, the methods for the MovieClip class provide the
 * same functionality as actions that target movie clips. Some additional
 * methods do not have equivalent actions in the Actions toolbox in the
 * Actions panel in the Flash authoring tool. </p>
 *
 * <p>Children instances placed on the Stage in Flash Professional cannot be
 * accessed by code from within the constructor of a parent instance since
 * they have not been created at that point in code execution. Before
 * accessing the child, the parent must instead either create the child
 * instance by code or delay access to a callback function that listens for
 * the child to dispatch its <code>Event.ADDED_TO_STAGE</code> event.</p>
 *
 * <p>If you modify any of the following properties of a MovieClip object that
 * contains a motion tween, the playhead is stopped in that MovieClip object:
 * <code>alpha</code>, <code>blendMode</code>, <code>filters</code>,
 * <code>height</code>, <code>opaqueBackground</code>, <code>rotation</code>,
 * <code>scaleX</code>, <code>scaleY</code>, <code>scale9Grid</code>,
 * <code>scrollRect</code>, <code>transform</code>, <code>visible</code>,
 * <code>width</code>, <code>x</code>, or <code>y</code>. However, it does not
 * stop the playhead in any child MovieClip objects of that MovieClip
 * object.</p>
 *
 * <p><b>Note:</b>Flash Lite 4 supports the MovieClip.opaqueBackground
 * property only if FEATURE_BITMAPCACHE is defined. The default configuration
 * of Flash Lite 4 does not define FEATURE_BITMAPCACHE. To enable the
 * MovieClip.opaqueBackground property for a suitable device, define
 * FEATURE_BITMAPCACHE in your project.</p>]]></haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.PixelSnapping" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/PixelSnapping.hx">
		<ALWAYS><haxe_doc><![CDATA[* A constant value used in the <code>pixelSnapping</code> property of a
	 * Bitmap object to specify that the bitmap image is always snapped to the
	 * nearest pixel, independent of any transformation.]]></haxe_doc></ALWAYS>
		<AUTO><haxe_doc><![CDATA[* A constant value used in the <code>pixelSnapping</code> property of a
	 * Bitmap object to specify that the bitmap image is snapped to the nearest
	 * pixel if it is drawn with no rotation or skew and it is drawn at a scale
	 * factor of 99.9% to 100.1%. If these conditions are satisfied, the image is
	 * drawn at 100% scale, snapped to the nearest pixel. Internally, this
	 * setting allows the image to be drawn as fast as possible by using the
	 * vector renderer.]]></haxe_doc></AUTO>
		<NEVER><haxe_doc><![CDATA[* A constant value used in the <code>pixelSnapping</code> property of a
	 * Bitmap object to specify that no pixel snapping occurs.]]></haxe_doc></NEVER>
		<haxe_doc><![CDATA[* The PixelSnapping class is an enumeration of constant values for setting
 * the pixel snapping options by using the <code>pixelSnapping</code> property
 * of a Bitmap object.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/SpreadMethod.hx">
		<PAD><haxe_doc><![CDATA[* Specifies that the gradient use the <i>pad</i> spread method.]]></haxe_doc></PAD>
		<REFLECT><haxe_doc><![CDATA[* Specifies that the gradient use the <i>reflect</i> spread method.]]></haxe_doc></REFLECT>
		<REPEAT><haxe_doc><![CDATA[* Specifies that the gradient use the <i>repeat</i> spread method.]]></haxe_doc></REPEAT>
		<haxe_doc><![CDATA[* The SpreadMethod class provides values for the <code>spreadMethod</code>
 * parameter in the <code>beginGradientFill()</code> and
 * <code>lineGradientStyle()</code> methods of the Graphics class.
 *
 * <p>The following example shows the same gradient fill using various spread
 * methods:</p>]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determines whether the <code>Stage.focus</code> property returns
	 * <code>null</code> for security reasons. In other words,
	 * <code>isFocusInaccessible</code> returns <code>true</code> if the object
	 * that has focus belongs to a security sandbox to which the SWF file does
	 * not have access.
	 * 
	 * @return <code>true</code> if the object that has focus belongs to a
	 *         security sandbox to which the SWF file does not have access.]]></haxe_doc>
		</isFocusInaccessible>
		<invalidate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Calling the <code>invalidate()</code> method signals Flash runtimes to
	 * alert display objects on the next opportunity it has to render the display
	 * list(for example, when the playhead advances to a new frame). After you
	 * call the <code>invalidate()</code> method, when the display list is next
	 * rendered, the Flash runtime sends a <code>render</code> event to each
	 * display object that has registered to listen for the <code>render</code>
	 * event. You must call the <code>invalidate()</code> method each time you
	 * want the Flash runtime to send <code>render</code> events.
	 *
	 * <p>The <code>render</code> event gives you an opportunity to make changes
	 * to the display list immediately before it is actually rendered. This lets
	 * you defer updates to the display list until the latest opportunity. This
	 * can increase performance by eliminating unnecessary screen updates.</p>
	 *
	 * <p>The <code>render</code> event is dispatched only to display objects
	 * that are in the same security domain as the code that calls the
	 * <code>stage.invalidate()</code> method, or to display objects from a
	 * security domain that has been granted permission via the
	 * <code>Security.allowDomain()</code> method.</p>
	 *]]></haxe_doc>
		</invalidate>
		<stageWidth public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* A list of StageVideo objects available for playing external videos.
	 *
	 * <p>You can use only a limited number of StageVideo objects at a time. When
	 * a SWF begins to run, the number of available StageVideo objects depends on
	 * the platform and on available hardware. </p>
	 *
	 * <p>To use a StageVideo object, assign a member of the
	 * <code>stageVideos</code> Vector object to a StageVideo variable. </p>
	 *
	 * <p>All StageVideo objects are displayed on the stage behind any display
	 * objects. The StageVideo objects are displayed on the stage in the order
	 * they appear in the <code>stageVideos</code> Vector object. For example, if
	 * the <code>stageVideos</code> Vector object contains three entries:</p>
	 *
	 * <ol>
	 *   <li>The StageVideo object in the 0 index of the <code>stageVideos</code>
	 * Vector object is displayed behind all StageVideo objects.</li>
	 *   <li>The StageVideo object at index 1 is displayed in front of the
	 * StageVideo object at index 0.</li>
	 *   <li>The StageVideo object at index 2 is displayed in front of the
	 * StageVideo object at index 1.</li>
	 * </ol>
	 *
	 * <p>Use the <code>StageVideo.depth</code> property to change this
	 * ordering.</p>
	 *
	 * <p><b>Note:</b> AIR for TV devices support only one StageVideo object.</p>]]></haxe_doc>
		</stageWidth>
		<stageHeight public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The current height, in pixels, of the Stage.
	 *
	 * <p>If the value of the <code>Stage.scaleMode</code> property is set to
	 * <code>StageScaleMode.NO_SCALE</code> when the user resizes the window, the
	 * Stage content maintains its size while the <code>stageHeight</code>
	 * property changes to reflect the new height size of the screen area
	 * occupied by the SWF file.(In the other scale modes, the
	 * <code>stageHeight</code> property always reflects the original height of
	 * the SWF file.) You can add an event listener for the <code>resize</code>
	 * event and then use the <code>stageHeight</code> property of the Stage
	 * class to determine the actual pixel dimension of the resized Flash runtime
	 * window. The event listener allows you to control how the screen content
	 * adjusts when the user resizes the window.</p>
	 *
	 * <p>Air for TV devices have slightly different behavior than desktop
	 * devices when you set the <code>stageHeight</code> property. If the
	 * <code>Stage.scaleMode</code> property is set to
	 * <code>StageScaleMode.NO_SCALE</code> and you set the
	 * <code>stageHeight</code> property, the stage height does not change until
	 * the next frame of the SWF.</p>
	 *
	 * <p><b>Note:</b> In an HTML page hosting the SWF file, both the
	 * <code>object</code> and <code>embed</code> tags' <code>height</code>
	 * attributes must be set to a percentage(such as <code>100%</code>), not
	 * pixels. If the settings are generated by JavaScript code, the
	 * <code>height</code> parameter of the <code>AC_FL_RunContent() </code>
	 * method must be set to a percentage, too. This percentage is applied to the
	 * <code>stageHeight</code> value.</p>
	 * 
	 * @throws SecurityError Calling the <code>stageHeight</code> property of a
	 *                       Stage object throws an exception for any caller that
	 *                       is not in the same security sandbox as the Stage
	 *                       owner(the main SWF file). To avoid this, the Stage
	 *                       owner can grant permission to the domain of the
	 *                       caller by calling the
	 *                       <code>Security.allowDomain()</code> method or the
	 *                       <code>Security.allowInsecureDomain()</code> method.
	 *                       For more information, see the "Security" chapter in
	 *                       the <i>ActionScript 3.0 Developer's Guide</i>.]]></haxe_doc>
		</stageHeight>
		<stageFocusRect public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether or not objects display a glowing border when they have
	 * focus.
	 * 
	 * @throws SecurityError Calling the <code>stageFocusRect</code> property of
	 *                       a Stage object throws an exception for any caller
	 *                       that is not in the same security sandbox as the
	 *                       Stage owner(the main SWF file). To avoid this, the
	 *                       Stage owner can grant permission to the domain of
	 *                       the caller by calling the
	 *                       <code>Security.allowDomain()</code> method or the
	 *                       <code>Security.allowInsecureDomain()</code> method.
	 *                       For more information, see the "Security" chapter in
	 *                       the <i>ActionScript 3.0 Developer's Guide</i>.]]></haxe_doc>
		</stageFocusRect>
		<showDefaultContextMenu public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether to show or hide the default items in the Flash runtime
	 * context menu.
	 *
	 * <p>If the <code>showDefaultContextMenu</code> property is set to
	 * <code>true</code>(the default), all context menu items appear. If the
	 * <code>showDefaultContextMenu</code> property is set to <code>false</code>,
	 * only the Settings and About... menu items appear.</p>
	 * 
	 * @throws SecurityError Calling the <code>showDefaultContextMenu</code>
	 *                       property of a Stage object throws an exception for
	 *                       any caller that is not in the same security sandbox
	 *                       as the Stage owner(the main SWF file). To avoid
	 *                       this, the Stage owner can grant permission to the
	 *                       domain of the caller by calling the
	 *                       <code>Security.allowDomain()</code> method or the
	 *                       <code>Security.allowInsecureDomain()</code> method.
	 *                       For more information, see the "Security" chapter in
	 *                       the <i>ActionScript 3.0 Developer's Guide</i>.]]></haxe_doc>
		</showDefaultContextMenu>
		<scaleMode public="1">
			<e path="flash.display.StageScaleMode"/>
			<haxe_doc><![CDATA[* A value from the StageScaleMode class that specifies which scale mode to
	 * use. The following are valid values:
	 * <ul>
	 *   <li><code>StageScaleMode.EXACT_FIT</code> - The entire application is
	 * visible in the specified area without trying to preserve the original
	 * aspect ratio. Distortion can occur, and the application may appear
	 * stretched or compressed. </li>
	 *   <li><code>StageScaleMode.SHOW_ALL</code> - The entire application is
	 * visible in the specified area without distortion while maintaining the
	 * original aspect ratio of the application. Borders can appear on two sides
	 * of the application. </li>
	 *   <li><code>StageScaleMode.NO_BORDER</code> - The entire application fills
	 * the specified area, without distortion but possibly with some cropping,
	 * while maintaining the original aspect ratio of the application. </li>
	 *   <li><code>StageScaleMode.NO_SCALE</code> - The entire application is
	 * fixed, so that it remains unchanged even as the size of the player window
	 * changes. Cropping might occur if the player window is smaller than the
	 * content. </li>
	 * </ul>
	 * 
	 * @throws SecurityError Calling the <code>scaleMode</code> property of a
	 *                       Stage object throws an exception for any caller that
	 *                       is not in the same security sandbox as the Stage
	 *                       owner(the main SWF file). To avoid this, the Stage
	 *                       owner can grant permission to the domain of the
	 *                       caller by calling the
	 *                       <code>Security.allowDomain()</code> method or the
	 *                       <code>Security.allowInsecureDomain()</code> method.
	 *                       For more information, see the "Security" chapter in
	 *                       the <i>ActionScript 3.0 Developer's Guide</i>.]]></haxe_doc>
		</scaleMode>
		<quality public="1">
			<e path="flash.display.StageQuality"/>
			<haxe_doc><![CDATA[* A value from the StageQuality class that specifies which rendering quality
	 * is used. The following are valid values:
	 * <ul>
	 *   <li><code>StageQuality.LOW</code> - Low rendering quality. Graphics are
	 * not anti-aliased, and bitmaps are not smoothed, but runtimes still use
	 * mip-mapping.</li>
	 *   <li><code>StageQuality.MEDIUM</code> - Medium rendering quality.
	 * Graphics are anti-aliased using a 2 x 2 pixel grid, bitmap smoothing is
	 * dependent on the <code>Bitmap.smoothing</code> setting. Runtimes use
	 * mip-mapping. This setting is suitable for movies that do not contain
	 * text.</li>
	 *   <li><code>StageQuality.HIGH</code> - High rendering quality. Graphics
	 * are anti-aliased using a 4 x 4 pixel grid, and bitmap smoothing is
	 * dependent on the <code>Bitmap.smoothing</code> setting. Runtimes use
	 * mip-mapping. This is the default rendering quality setting that Flash
	 * Player uses.</li>
	 *   <li><code>StageQuality.BEST</code> - Very high rendering quality.
	 * Graphics are anti-aliased using a 4 x 4 pixel grid. If
	 * <code>Bitmap.smoothing</code> is <code>true</code> the runtime uses a high
	 * quality downscale algorithm that produces fewer artifacts(however, using
	 * <code>StageQuality.BEST</code> with <code>Bitmap.smoothing</code> set to
	 * <code>true</code> slows performance significantly and is not a recommended
	 * setting).</li>
	 * </ul>
	 *
	 * <p>Higher quality settings produce better rendering of scaled bitmaps.
	 * However, higher quality settings are computationally more expensive. In
	 * particular, when rendering scaled video, using higher quality settings can
	 * reduce the frame rate. </p>
	 *
	 * <p>In the desktop profile of Adobe AIR, <code>quality</code> can be set to
	 * <code>StageQuality.BEST</code> or <code>StageQuality.HIGH</code>(and the
	 * default value is <code>StageQuality.HIGH</code>). Attempting to set it to
	 * another value has no effect(and the property remains unchanged). In the
	 * moble profile of AIR, all four quality settings are available. The default
	 * value on mobile devices is <code>StageQuality.MEDIUM</code>.</p>
	 *
	 * <p>For content running in Adobe AIR, setting the <code>quality</code>
	 * property of one Stage object changes the rendering quality for all Stage
	 * objects(used by different NativeWindow objects). </p>
	 * <b><i>Note:</i></b> The operating system draws the device fonts, which are
	 * therefore unaffected by the <code>quality</code> property.
	 * 
	 * @throws SecurityError Calling the <code>quality</code> property of a Stage
	 *                       object throws an exception for any caller that is
	 *                       not in the same security sandbox as the Stage owner
	 *                      (the main SWF file). To avoid this, the Stage owner
	 *                       can grant permission to the domain of the caller by
	 *                       calling the <code>Security.allowDomain()</code>
	 *                       method or the
	 *                       <code>Security.allowInsecureDomain()</code> method.
	 *                       For more information, see the "Security" chapter in
	 *                       the <i>ActionScript 3.0 Developer's Guide</i>.]]></haxe_doc>
		</quality>
		<fullScreenWidth public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Returns the width of the monitor that will be used when going to full
	 * screen size, if that state is entered immediately. If the user has
	 * multiple monitors, the monitor that's used is the monitor that most of the
	 * stage is on at the time.
	 *
	 * <p><b>Note</b>: If the user has the opportunity to move the browser from
	 * one monitor to another between retrieving the value and going to full
	 * screen size, the value could be incorrect. If you retrieve the value in an
	 * event handler that sets <code>Stage.displayState</code> to
	 * <code>StageDisplayState.FULL_SCREEN</code>, the value will be correct.</p>
	 *
	 * <p>This is the pixel width of the monitor and is the same as the stage
	 * width would be if <code>Stage.align</code> is set to
	 * <code>StageAlign.TOP_LEFT</code> and <code>Stage.scaleMode</code> is set
	 * to <code>StageScaleMode.NO_SCALE</code>.</p>]]></haxe_doc>
		</fullScreenWidth>
		<fullScreenSourceRect public="1">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc><![CDATA[* Sets the Flash runtime to scale a specific region of the stage to
	 * full-screen mode. If available, the Flash runtime scales in hardware,
	 * which uses the graphics and video card on a user's computer, and generally
	 * displays content more quickly than software scaling.
	 *
	 * <p>When this property is set to a valid rectangle and the
	 * <code>displayState</code> property is set to full-screen mode, the Flash
	 * runtime scales the specified area. The actual Stage size in pixels within
	 * ActionScript does not change. The Flash runtime enforces a minimum limit
	 * for the size of the rectangle to accommodate the standard "Press Esc to
	 * exit full-screen mode" message. This limit is usually around 260 by 30
	 * pixels but can vary on platform and Flash runtime version.</p>
	 *
	 * <p>This property can only be set when the Flash runtime is not in
	 * full-screen mode. To use this property correctly, set this property first,
	 * then set the <code>displayState</code> property to full-screen mode, as
	 * shown in the code examples.</p>
	 *
	 * <p>To enable scaling, set the <code>fullScreenSourceRect</code> property
	 * to a rectangle object:</p>
	 *
	 * <p>The end user also can select within Flash Player Display Settings to
	 * turn off hardware scaling, which is enabled by default. For more
	 * information, see <a href="http://www.adobe.com/go/display_settings"
	 * scope="external">www.adobe.com/go/display_settings</a>.</p>]]></haxe_doc>
		</fullScreenSourceRect>
		<fullScreenHeight public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Returns the height of the monitor that will be used when going to full
	 * screen size, if that state is entered immediately. If the user has
	 * multiple monitors, the monitor that's used is the monitor that most of the
	 * stage is on at the time.
	 *
	 * <p><b>Note</b>: If the user has the opportunity to move the browser from
	 * one monitor to another between retrieving the value and going to full
	 * screen size, the value could be incorrect. If you retrieve the value in an
	 * event handler that sets <code>Stage.displayState</code> to
	 * <code>StageDisplayState.FULL_SCREEN</code>, the value will be correct.</p>
	 *
	 * <p>This is the pixel height of the monitor and is the same as the stage
	 * height would be if <code>Stage.align</code> is set to
	 * <code>StageAlign.TOP_LEFT</code> and <code>Stage.scaleMode</code> is set
	 * to <code>StageScaleMode.NO_SCALE</code>.</p>]]></haxe_doc>
		</fullScreenHeight>
		<frameRate public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Gets and sets the frame rate of the stage. The frame rate is defined as
	 * frames per second. By default the rate is set to the frame rate of the
	 * first SWF file loaded. Valid range for the frame rate is from 0.01 to 1000
	 * frames per second.
	 *
	 * <p><b>Note:</b> An application might not be able to follow high frame rate
	 * settings, either because the target platform is not fast enough or the
	 * player is synchronized to the vertical blank timing of the display device
	 * (usually 60 Hz on LCD devices). In some cases, a target platform might
	 * also choose to lower the maximum frame rate if it anticipates high CPU
	 * usage.</p>
	 *
	 * <p>For content running in Adobe AIR, setting the <code>frameRate</code>
	 * property of one Stage object changes the frame rate for all Stage objects
	 * (used by different NativeWindow objects). </p>
	 * 
	 * @throws SecurityError Calling the <code>frameRate</code> property of a
	 *                       Stage object throws an exception for any caller that
	 *                       is not in the same security sandbox as the Stage
	 *                       owner(the main SWF file). To avoid this, the Stage
	 *                       owner can grant permission to the domain of the
	 *                       caller by calling the
	 *                       <code>Security.allowDomain()</code> method or the
	 *                       <code>Security.allowInsecureDomain()</code> method.
	 *                       For more information, see the "Security" chapter in
	 *                       the <i>ActionScript 3.0 Developer's Guide</i>.]]></haxe_doc>
		</frameRate>
		<focus public="1">
			<c path="flash.display.InteractiveObject"/>
			<haxe_doc><![CDATA[* The interactive object with keyboard focus; or <code>null</code> if focus
	 * is not set or if the focused object belongs to a security sandbox to which
	 * the calling object does not have access.
	 * 
	 * @throws Error Throws an error if focus cannot be set to the target.]]></haxe_doc>
		</focus>
		<displayState public="1">
			<e path="flash.display.StageDisplayState"/>
			<haxe_doc><![CDATA[* Controls Flash runtime color correction for displays. Color correction
	 * works only if the main monitor is assigned a valid ICC color profile,
	 * which specifies the device's particular color attributes. By default, the
	 * Flash runtime tries to match the color correction of its host(usually a
	 * browser).
	 *
	 * <p>Use the <code>Stage.colorCorrectionSupport</code> property to determine
	 * if color correction is available on the current system and the default
	 * state. . If color correction is available, all colors on the stage are
	 * assumed to be in the sRGB color space, which is the most standard color
	 * space. Source profiles of input devices are not considered during color
	 * correction. No input color correction is applied; only the stage output is
	 * mapped to the main monitor's ICC color profile.</p>
	 *
	 * <p>In general, the benefits of activating color management include
	 * predictable and consistent color, better conversion, accurate proofing and
	 * more efficient cross-media output. Be aware, though, that color management
	 * does not provide perfect conversions due to devices having a different
	 * gamut from each other or original images. Nor does color management
	 * eliminate the need for custom or edited profiles. Color profiles are
	 * dependent on browsers, operating systems(OS), OS extensions, output
	 * devices, and application support.</p>
	 *
	 * <p>Applying color correction degrades the Flash runtime performance. A
	 * Flash runtime's color correction is document style color correction
	 * because all SWF movies are considered documents with implicit sRGB
	 * profiles. Use the <code>Stage.colorCorrectionSupport</code> property to
	 * tell the Flash runtime to correct colors when displaying the SWF file
	 * (document) to the display color space. Flash runtimes only compensates for
	 * differences between monitors, not for differences between input devices
	 * (camera/scanner/etc.). </p>
	 *
	 * <p>The three possible values are strings with corresponding constants in
	 * the flash.display.ColorCorrection class:</p>
	 *
	 * <ul>
	 *   <li><code>"default"</code>: Use the same color correction as the host
	 * system.</li>
	 *   <li><code>"on"</code>: Always perform color correction.</li>
	 *   <li><code>"off"</code>: Never perform color correction.</li>
	 * </ul>]]></haxe_doc>
		</displayState>
		<align public="1">
			<e path="flash.display.StageAlign"/>
			<haxe_doc><![CDATA[* A value from the StageAlign class that specifies the alignment of the
	 * stage in Flash Player or the browser. The following are valid values:
	 *
	 * <p>The <code>align</code> property is only available to an object that is
	 * in the same security sandbox as the Stage owner(the main SWF file). To
	 * avoid this, the Stage owner can grant permission to the domain of the
	 * calling object by calling the <code>Security.allowDomain()</code> method
	 * or the <code>Security.alowInsecureDomain()</code> method. For more
	 * information, see the "Security" chapter in the <i>ActionScript 3.0
	 * Developer's Guide</i>.</p>]]></haxe_doc>
		</align>
		<haxe_doc><![CDATA[* The Stage class represents the main drawing area.
 *
 * <p>For SWF content running in the browser(in Flash<sup>®</sup> Player),
 * the Stage represents the entire area where Flash content is shown. For
 * content running in AIR on desktop operating systems, each NativeWindow
 * object has a corresponding Stage object.</p>
 *
 * <p>The Stage object is not globally accessible. You need to access it
 * through the <code>stage</code> property of a DisplayObject instance.</p>
 *
 * <p>The Stage class has several ancestor classes  -  DisplayObjectContainer,
 * InteractiveObject, DisplayObject, and EventDispatcher  -  from which it
 * inherits properties and methods. Many of these properties and methods are
 * either inapplicable to Stage objects, or require security checks when
 * called on a Stage object. The properties and methods that require security
 * checks are documented as part of the Stage class.</p>
 *
 * <p>In addition, the following inherited properties are inapplicable to
 * Stage objects. If you try to set them, an IllegalOperationError is thrown.
 * These properties may always be read, but since they cannot be set, they
 * will always contain default values.</p>
 *
 * <ul>
 *   <li><code>accessibilityProperties</code></li>
 *   <li><code>alpha</code></li>
 *   <li><code>blendMode</code></li>
 *   <li><code>cacheAsBitmap</code></li>
 *   <li><code>contextMenu</code></li>
 *   <li><code>filters</code></li>
 *   <li><code>focusRect</code></li>
 *   <li><code>loaderInfo</code></li>
 *   <li><code>mask</code></li>
 *   <li><code>mouseEnabled</code></li>
 *   <li><code>name</code></li>
 *   <li><code>opaqueBackground</code></li>
 *   <li><code>rotation</code></li>
 *   <li><code>scale9Grid</code></li>
 *   <li><code>scaleX</code></li>
 *   <li><code>scaleY</code></li>
 *   <li><code>scrollRect</code></li>
 *   <li><code>tabEnabled</code></li>
 *   <li><code>tabIndex</code></li>
 *   <li><code>transform</code></li>
 *   <li><code>visible</code></li>
 *   <li><code>x</code></li>
 *   <li><code>y</code></li>
 * </ul>
 *
 * <p>Some events that you might expect to be a part of the Stage class, such
 * as <code>enterFrame</code>, <code>exitFrame</code>,
 * <code>frameConstructed</code>, and <code>render</code>, cannot be Stage
 * events because a reference to the Stage object cannot be guaranteed to
 * exist in every situation where these events are used. Because these events
 * cannot be dispatched by the Stage object, they are instead dispatched by
 * every DisplayObject instance, which means that you can add an event
 * listener to any DisplayObject instance to listen for these events. These
 * events, which are part of the DisplayObject class, are called broadcast
 * events to differentiate them from events that target a specific
 * DisplayObject instance. Two other broadcast events, <code>activate</code>
 * and <code>deactivate</code>, belong to DisplayObject's superclass,
 * EventDispatcher. The <code>activate</code> and <code>deactivate</code>
 * events behave similarly to the DisplayObject broadcast events, except that
 * these two events are dispatched not only by all DisplayObject instances,
 * but also by all EventDispatcher instances and instances of other
 * EventDispatcher subclasses. For more information on broadcast events, see
 * the DisplayObject class.</p>
 * 
 * @event fullScreen             Dispatched when the Stage object enters, or
 *                               leaves, full-screen mode. A change in
 *                               full-screen mode can be initiated through
 *                               ActionScript, or the user invoking a keyboard
 *                               shortcut, or if the current focus leaves the
 *                               full-screen window.
 * @event mouseLeave             Dispatched by the Stage object when the
 *                               pointer moves out of the stage area. If the
 *                               mouse button is pressed, the event is not
 *                               dispatched.
 * @event orientationChange      Dispatched by the Stage object when the stage
 *                               orientation changes.
 *
 *                               <p>Orientation changes can occur when the
 *                               user rotates the device, opens a slide-out
 *                               keyboard, or when the
 *                               <code>setAspectRatio()</code> is called.</p>
 *
 *                               <p><b>Note:</b> If the
 *                               <code>autoOrients</code> property is
 *                               <code>false</code>, then the stage
 *                               orientation does not change when a device is
 *                               rotated. Thus, StageOrientationEvents are
 *                               only dispatched for device rotation when
 *                               <code>autoOrients</code> is
 *                               <code>true</code>.</p>
 * @event orientationChanging    Dispatched by the Stage object when the stage
 *                               orientation begins changing.
 *
 *                               <p><b>Important:</b> orientationChanging
 *                               events are not dispatched on Android
 *                               devices.</p>
 *
 *                               <p><b>Note:</b> If the
 *                               <code>autoOrients</code> property is
 *                               <code>false</code>, then the stage
 *                               orientation does not change when a device is
 *                               rotated. Thus, StageOrientationEvents are
 *                               only dispatched for device rotation when
 *                               <code>autoOrients</code> is
 *                               <code>true</code>.</p>
 * @event resize                 Dispatched when the <code>scaleMode</code>
 *                               property of the Stage object is set to
 *                               <code>StageScaleMode.NO_SCALE</code> and the
 *                               SWF file is resized.
 * @event stageVideoAvailability Dispatched by the Stage object when the state
 *                               of the stageVideos property changes.]]></haxe_doc>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/StageAlign.hx">
		<BOTTOM><haxe_doc>* Specifies that the Stage is aligned at the bottom.</haxe_doc></BOTTOM>
		<BOTTOM_LEFT><haxe_doc>* Specifies that the Stage is aligned on the left.</haxe_doc></BOTTOM_LEFT>
		<BOTTOM_RIGHT><haxe_doc>* Specifies that the Stage is aligned to the right.</haxe_doc></BOTTOM_RIGHT>
		<LEFT><haxe_doc>* Specifies that the Stage is aligned on the left.</haxe_doc></LEFT>
		<RIGHT><haxe_doc>* Specifies that the Stage is aligned to the right.</haxe_doc></RIGHT>
		<TOP><haxe_doc>* Specifies that the Stage is aligned at the top.</haxe_doc></TOP>
		<TOP_LEFT><haxe_doc>* Specifies that the Stage is aligned on the left.</haxe_doc></TOP_LEFT>
		<TOP_RIGHT><haxe_doc>* Specifies that the Stage is aligned to the right.</haxe_doc></TOP_RIGHT>
		<haxe_doc><![CDATA[* The StageAlign class provides constant values to use for the
 * <code>Stage.align</code> property.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/StageDisplayState.hx">
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<NORMAL><haxe_doc>* Specifies that the Stage is in normal mode.</haxe_doc></NORMAL>
		<haxe_doc><![CDATA[* The StageDisplayState class provides values for the
 * <code>Stage.displayState</code> property.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/StageQuality.hx">
		<BEST><haxe_doc>* Specifies very high rendering quality: graphics are anti-aliased using a 4
	 * x 4 pixel grid and bitmaps are always smoothed.</haxe_doc></BEST>
		<HIGH><haxe_doc>* Specifies high rendering quality: graphics are anti-aliased using a 4 x 4
	 * pixel grid, and bitmaps are smoothed if the movie is static.</haxe_doc></HIGH>
		<LOW><haxe_doc>* Specifies low rendering quality: graphics are not anti-aliased, and
	 * bitmaps are not smoothed.</haxe_doc></LOW>
		<MEDIUM><haxe_doc>* Specifies medium rendering quality: graphics are anti-aliased using a 2 x
	 * 2 pixel grid, but bitmaps are not smoothed. This setting is suitable for
	 * movies that do not contain text.</haxe_doc></MEDIUM>
		<haxe_doc><![CDATA[* The StageQuality class provides values for the <code>Stage.quality</code>
 * property.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/StageScaleMode.hx">
		<EXACT_FIT/>
		<NO_BORDER/>
		<NO_SCALE/>
		<SHOW_ALL/>
		<haxe_doc><![CDATA[* The StageScaleMode class provides values for the
 * <code>Stage.scaleMode</code> property.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/display/TriangleCulling.hx">
		<NEGATIVE><haxe_doc>* Specifies culling of all triangles facing toward the current view point.</haxe_doc></NEGATIVE>
		<NONE><haxe_doc>* Specifies no culling. All triangles in the path are rendered.</haxe_doc></NONE>
		<POSITIVE><haxe_doc>* Specifies culling of all triangles facing away from the current view
	 * point. This is also known as backface culling.</haxe_doc></POSITIVE>
		<haxe_doc><![CDATA[* Defines codes for culling algorithms that determine which triangles not to
 * render when drawing triangle paths.
 *
 * <p> The terms <code>POSITIVE</code> and <code>NEGATIVE</code> refer to the
 * sign of a triangle's normal along the z-axis. The normal is a 3D vector
 * that is perpendicular to the surface of the triangle. </p>
 *
 * <p> A triangle whose vertices 0, 1, and 2 are arranged in a clockwise order
 * has a positive normal value. That is, its normal points in a positive
 * z-axis direction, away from the current view point. When the
 * <code>TriangleCulling.POSITIVE</code> algorithm is used, triangles with
 * positive normals are not rendered. Another term for this is backface
 * culling. </p>
 *
 * <p> A triangle whose vertices are arranged in a counter-clockwise order has
 * a negative normal value. That is, its normal points in a negative z-axis
 * direction, toward the current view point. When the
 * <code>TriangleCulling.NEGATIVE</code> algorithm is used, triangles with
 * negative normals will not be rendered. </p>]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.errors.Error" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="Int"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.errors.ArgumentError" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/errors/ArgumentError.hx" extern="1">
		<extends path="flash.errors.Error"/>
		<meta><m n=":native"><e>"ArgumentError"</e></m></meta>
	</class>
	<class path="flash.events.Event" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>ACTIVATE</code> constant defines the value of the
	 * <code>type</code> property of an <code>activate</code> event object.
	 *
	 * <p><b>Note:</b> This event has neither a "capture phase" nor a "bubble
	 * phase", which means that event listeners must be added directly to any
	 * potential targets, whether the target is on the display list or not.</p>
	 *
	 * <p>AIR for TV devices never automatically dispatch this event. You can,
	 * however, dispatch it manually.</p>
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ACTIVATE>
		<ADDED public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.ADDED</code> constant defines the value of the
	 * <code>type</code> property of an <code>added</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ADDED>
		<ADDED_TO_STAGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.ADDED_TO_STAGE</code> constant defines the value of the
	 * <code>type</code> property of an <code>addedToStage</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ADDED_TO_STAGE>
		<CANCEL public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.CANCEL</code> constant defines the value of the
	 * <code>type</code> property of a <code>cancel</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</CANCEL>
		<CHANNEL_MESSAGE public="1" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" static="1"><c path="String"/></CHANNEL_STATE>
		<CHANGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.CHANGE</code> constant defines the value of the
	 * <code>type</code> property of a <code>change</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</CHANGE>
		<CLOSE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.CLOSE</code> constant defines the value of the
	 * <code>type</code> property of a <code>close</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</CLOSE>
		<COMPLETE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.COMPLETE</code> constant defines the value of the
	 * <code>type</code> property of a <code>complete</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</COMPLETE>
		<CONNECT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.CONNECT</code> constant defines the value of the
	 * <code>type</code> property of a <code>connect</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</CONNECT>
		<DEACTIVATE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.DEACTIVATE</code> constant defines the value of the
	 * <code>type</code> property of a <code>deactivate</code> event object.
	 *
	 * <p><b>Note:</b> This event has neither a "capture phase" nor a "bubble
	 * phase", which means that event listeners must be added directly to any
	 * potential targets, whether the target is on the display list or not.</p>
	 *
	 * <p>AIR for TV devices never automatically dispatch this event. You can,
	 * however, dispatch it manually.</p>
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</DEACTIVATE>
		<ENTER_FRAME public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.ENTER_FRAME</code> constant defines the value of the
	 * <code>type</code> property of an <code>enterFrame</code> event object.
	 *
	 * <p><b>Note:</b> This event has neither a "capture phase" nor a "bubble
	 * phase", which means that event listeners must be added directly to any
	 * potential targets, whether the target is on the display list or not.</p>
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ENTER_FRAME>
		<FULLSCREEN public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.FULL_SCREEN</code> constant defines the value of the
	 * <code>type</code> property of a <code>fullScreen</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</FULLSCREEN>
		<ID3 public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.ID3</code> constant defines the value of the
	 * <code>type</code> property of an <code>id3</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ID3>
		<INIT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.INIT</code> constant defines the value of the
	 * <code>type</code> property of an <code>init</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</INIT>
		<MOUSE_LEAVE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.MOUSE_LEAVE</code> constant defines the value of the
	 * <code>type</code> property of a <code>mouseLeave</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_LEAVE>
		<OPEN public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.OPEN</code> constant defines the value of the
	 * <code>type</code> property of an <code>open</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</OPEN>
		<REMOVED public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.REMOVED</code> constant defines the value of the
	 * <code>type</code> property of a <code>removed</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.REMOVED_FROM_STAGE</code> constant defines the value of
	 * the <code>type</code> property of a <code>removedFromStage</code> event
	 * object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</REMOVED_FROM_STAGE>
		<RENDER public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.RENDER</code> constant defines the value of the
	 * <code>type</code> property of a <code>render</code> event object.
	 *
	 * <p><b>Note:</b> This event has neither a "capture phase" nor a "bubble
	 * phase", which means that event listeners must be added directly to any
	 * potential targets, whether the target is on the display list or not.</p>
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</RENDER>
		<RESIZE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.RESIZE</code> constant defines the value of the
	 * <code>type</code> property of a <code>resize</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</RESIZE>
		<SCROLL public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.SCROLL</code> constant defines the value of the
	 * <code>type</code> property of a <code>scroll</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</SCROLL>
		<SELECT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.SELECT</code> constant defines the value of the
	 * <code>type</code> property of a <code>select</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</SELECT>
		<SOUND_COMPLETE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.SOUND_COMPLETE</code> constant defines the value of the
	 * <code>type</code> property of a <code>soundComplete</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.TAB_CHILDREN_CHANGE</code> constant defines the value of
	 * the <code>type</code> property of a <code>tabChildrenChange</code> event
	 * object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.TAB_ENABLED_CHANGE</code> constant defines the value of
	 * the <code>type</code> property of a <code>tabEnabledChange</code> event
	 * object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.TAB_INDEX_CHANGE</code> constant defines the value of the
	 * <code>type</code> property of a <code>tabIndexChange</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</TAB_INDEX_CHANGE>
		<UNLOAD public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>Event.UNLOAD</code> constant defines the value of the
	 * <code>type</code> property of an <code>unload</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</UNLOAD>
		<VIDEO_FRAME public="1" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" static="1"><c path="String"/></WORKER_STATE>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Returns a string containing all the properties of the Event object. The
	 * string is in the following format:
	 *
	 * <p><code>[Event type=<i>value</i> bubbles=<i>value</i>
	 * cancelable=<i>value</i>]</code></p>
	 * 
	 * @return A string containing all the properties of the Event object.]]></haxe_doc>
		</toString>
		<stopPropagation public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Prevents processing of any event listeners in nodes subsequent to the
	 * current node in the event flow. This method does not affect any event
	 * listeners in the current node(<code>currentTarget</code>). In contrast,
	 * the <code>stopImmediatePropagation()</code> method prevents processing of
	 * event listeners in both the current node and subsequent nodes. Additional
	 * calls to this method have no effect. This method can be called in any
	 * phase of the event flow.
	 *
	 * <p><b>Note: </b> This method does not cancel the behavior associated with
	 * this event; see <code>preventDefault()</code> for that functionality.</p>
	 *]]></haxe_doc>
		</stopPropagation>
		<stopImmediatePropagation public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Prevents processing of any event listeners in the current node and any
	 * subsequent nodes in the event flow. This method takes effect immediately,
	 * and it affects event listeners in the current node. In contrast, the
	 * <code>stopPropagation()</code> method doesn't take effect until all the
	 * event listeners in the current node finish processing.
	 *
	 * <p><b>Note: </b> This method does not cancel the behavior associated with
	 * this event; see <code>preventDefault()</code> for that functionality.</p>
	 *]]></haxe_doc>
		</stopImmediatePropagation>
		<preventDefault public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Cancels an event's default behavior if that behavior can be canceled.
	 *
	 * <p>Many events have associated behaviors that are carried out by default.
	 * For example, if a user types a character into a text field, the default
	 * behavior is that the character is displayed in the text field. Because the
	 * <code>TextEvent.TEXT_INPUT</code> event's default behavior can be
	 * canceled, you can use the <code>preventDefault()</code> method to prevent
	 * the character from appearing. </p>
	 *
	 * <p>An example of a behavior that is not cancelable is the default behavior
	 * associated with the <code>Event.REMOVED</code> event, which is generated
	 * whenever Flash Player is about to remove a display object from the display
	 * list. The default behavior(removing the element) cannot be canceled, so
	 * the <code>preventDefault()</code> method has no effect on this default
	 * behavior. </p>
	 *
	 * <p>You can use the <code>Event.cancelable</code> property to check whether
	 * you can prevent the default behavior associated with a particular event.
	 * If the value of <code>Event.cancelable</code> is <code>true</code>, then
	 * <code>preventDefault()</code> can be used to cancel the event; otherwise,
	 * <code>preventDefault()</code> has no effect.</p>
	 *]]></haxe_doc>
		</preventDefault>
		<isDefaultPrevented public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Checks whether the <code>preventDefault()</code> method has been called on
	 * the event. If the <code>preventDefault()</code> method has been called,
	 * returns <code>true</code>; otherwise, returns <code>false</code>.
	 * 
	 * @return If <code>preventDefault()</code> has been called, returns
	 *         <code>true</code>; otherwise, returns <code>false</code>.]]></haxe_doc>
		</isDefaultPrevented>
		<formatToString public="1" set="method">
			<f a="className:?p1:?p2:?p3:?p4:?p5">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* A utility function for implementing the <code>toString()</code> method in
	 * custom ActionScript 3.0 Event classes. Overriding the
	 * <code>toString()</code> method is recommended, but not required. <pre
	 * xml:space="preserve"> class PingEvent extends Event { var URL:String;
	 * public override function toString():String { return
	 * formatToString("PingEvent", "type", "bubbles", "cancelable", "eventPhase",
	 * "URL"); } } </pre>
	 * 
	 * @param className The name of your custom Event class. In the previous
	 *                  example, the <code>className</code> parameter is
	 *                  <code>PingEvent</code>.
	 * @return The name of your custom Event class and the String value of your
	 *         <code>...arguments</code> parameter.]]></haxe_doc>
		</formatToString>
		<clone public="1" set="method">
			<f a=""><c path="flash.events.Event"/></f>
			<haxe_doc><![CDATA[* Duplicates an instance of an Event subclass.
	 *
	 * <p>Returns a new Event object that is a copy of the original instance of
	 * the Event object. You do not normally call <code>clone()</code>; the
	 * EventDispatcher class calls it automatically when you redispatch an
	 * event - that is, when you call <code>dispatchEvent(event)</code> from a
	 * handler that is handling <code>event</code>.</p>
	 *
	 * <p>The new Event object includes all the properties of the original.</p>
	 *
	 * <p>When creating your own custom Event class, you must override the
	 * inherited <code>Event.clone()</code> method in order for it to duplicate
	 * the properties of your custom class. If you do not set all the properties
	 * that you add in your event subclass, those properties will not have the
	 * correct values when listeners handle the redispatched event.</p>
	 *
	 * <p>In this example, <code>PingEvent</code> is a subclass of
	 * <code>Event</code> and therefore implements its own version of
	 * <code>clone()</code>.</p>
	 * 
	 * @return A new Event object that is identical to the original.]]></haxe_doc>
		</clone>
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The type of event. The type is case-sensitive.</haxe_doc>
		</type>
		<target public="1" set="null">
			<d/>
			<haxe_doc>* The event target. This property contains the target node. For example, if
	 * a user clicks an OK button, the target node is the display list node
	 * containing that button.</haxe_doc>
		</target>
		<eventPhase public="1" set="null">
			<e path="flash.events.EventPhase"/>
			<haxe_doc><![CDATA[* The current phase in the event flow. This property can contain the
	 * following numeric values:
	 * <ul>
	 *   <li> The capture phase(<code>EventPhase.CAPTURING_PHASE</code>).</li>
	 *   <li> The target phase(<code>EventPhase.AT_TARGET</code>).</li>
	 *   <li> The bubbling phase(<code>EventPhase.BUBBLING_PHASE</code>).</li>
	 * </ul>]]></haxe_doc>
		</eventPhase>
		<currentTarget public="1" set="null">
			<d/>
			<haxe_doc>* The object that is actively processing the Event object with an event
	 * listener. For example, if a user clicks an OK button, the current target
	 * could be the node containing that button or one of its ancestors that has
	 * registered an event listener for that event.</haxe_doc>
		</currentTarget>
		<cancelable public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the behavior associated with the event can be prevented.
	 * If the behavior can be canceled, this value is <code>true</code>;
	 * otherwise it is <code>false</code>.]]></haxe_doc>
		</cancelable>
		<bubbles public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether an event is a bubbling event. If the event can bubble,
	 * this value is <code>true</code>; otherwise it is <code>false</code>.
	 *
	 * <p>When an event occurs, it moves through the three phases of the event
	 * flow: the capture phase, which flows from the top of the display list
	 * hierarchy to the node just before the target node; the target phase, which
	 * comprises the target node; and the bubbling phase, which flows from the
	 * node subsequent to the target node back up the display list hierarchy.</p>
	 *
	 * <p>Some events, such as the <code>activate</code> and <code>unload</code>
	 * events, do not have a bubbling phase. The <code>bubbles</code> property
	 * has a value of <code>false</code> for events that do not have a bubbling
	 * phase.</p>]]></haxe_doc>
		</bubbles>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object to pass as a parameter to event listeners.
	 * 
	 * @param type       The type of the event, accessible as
	 *                   <code>Event.type</code>.
	 * @param bubbles    Determines whether the Event object participates in the
	 *                   bubbling stage of the event flow. The default value is
	 *                   <code>false</code>.
	 * @param cancelable Determines whether the Event object can be canceled. The
	 *                   default values is <code>false</code>.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Event class is used as the base class for the creation of Event
 * objects, which are passed as parameters to event listeners when an event
 * occurs.
 *
 * <p>The properties of the Event class carry basic information about an
 * event, such as the event's type or whether the event's default behavior can
 * be canceled. For many events, such as the events represented by the Event
 * class constants, this basic information is sufficient. Other events,
 * however, may require more detailed information. Events associated with a
 * mouse click, for example, need to include additional information about the
 * location of the click event and whether any keys were pressed during the
 * click event. You can pass such additional information to event listeners by
 * extending the Event class, which is what the MouseEvent class does.
 * ActionScript 3.0 API defines several Event subclasses for common events
 * that require additional information. Events associated with each of the
 * Event subclasses are described in the documentation for each class.</p>
 *
 * <p>The methods of the Event class can be used in event listener functions
 * to affect the behavior of the event object. Some events have an associated
 * default behavior. For example, the <code>doubleClick</code> event has an
 * associated default behavior that highlights the word under the mouse
 * pointer at the time of the event. Your event listener can cancel this
 * behavior by calling the <code>preventDefault()</code> method. You can also
 * make the current event listener the last one to process an event by calling
 * the <code>stopPropagation()</code> or
 * <code>stopImmediatePropagation()</code> method.</p>
 *
 * <p>Other sources of information include:</p>
 *
 * <ul>
 *   <li>A useful description about the timing of events, code execution, and
 * rendering at runtime in Ted Patrick's blog entry: <a
 * href="http://www.onflex.org/ted/2005/07/flash-player-mental-model-elastic.php"
 * scope="external">Flash Player Mental Model - The Elastic
 * Racetrack</a>.</li>
 *   <li>A blog entry by Johannes Tacskovics about the timing of frame events,
 * such as ENTER_FRAME, EXIT_FRAME: <a
 * href="http://blog.johannest.com/2009/06/15/the-movieclip-life-cycle-revisited-from-event-added-to-event-removed_from_stage/"
 * scope="external">The MovieClip Lifecycle</a>.</li>
 *   <li>An article by Trevor McCauley about the order of ActionScript
 * operations: <a
 * href="http://www.senocular.com/flash/tutorials/orderofoperations/"
 * scope="external">Order of Operations in ActionScript</a>.</li>
 *   <li>A blog entry by Matt Przybylski on creating custom events: <a
 * href="http://evolve.reintroducing.com/2007/10/23/as3/as3-custom-events/"
 * scope="external">AS3: Custom Events</a>.</li>
 * </ul>
 *]]></haxe_doc>
	</class>
	<class path="flash.events.TextEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a <code>link</code>
	 * event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</LINK>
		<TEXT_INPUT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>textInput</code> event object.
	 *
	 * <p><b>Note:</b> This event is not dispatched for the Delete or Backspace
	 * keys.</p>
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</TEXT_INPUT>
		<text public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* For a <code>textInput</code> event, the character or sequence of
	 * characters entered by the user. For a <code>link</code> event, the text of
	 * the <code>event</code> attribute of the <code>href</code> attribute of the
	 * <code><a></code> tag.]]></haxe_doc>
		</text>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object that contains information about text events. Event
	 * objects are passed as parameters to event listeners.
	 * 
	 * @param type       The type of the event. Event listeners can access this
	 *                   information through the inherited <code>type</code>
	 *                   property. Possible values are:
	 *                   <code>TextEvent.LINK</code> and
	 *                   <code>TextEvent.TEXT_INPUT</code>.
	 * @param bubbles    Determines whether the Event object participates in the
	 *                   bubbling phase of the event flow. Event listeners can
	 *                   access this information through the inherited
	 *                   <code>bubbles</code> property.
	 * @param cancelable Determines whether the Event object can be canceled.
	 *                   Event listeners can access this information through the
	 *                   inherited <code>cancelable</code> property.
	 * @param text       One or more characters of text entered by the user.
	 *                   Event listeners can access this information through the
	 *                   <code>text</code> property.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* An object dispatches a TextEvent object when a user enters text in a text
 * field or clicks a hyperlink in an HTML-enabled text field. There are two
 * types of text events: <code>TextEvent.LINK</code> and
 * <code>TextEvent.TEXT_INPUT</code>.
 *]]></haxe_doc>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of an
	 * <code>error</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ERROR>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object that contains information about error events.
	 * Event objects are passed as parameters to event listeners.
	 * 
	 * @param type       The type of the event. Event listeners can access this
	 *                   information through the inherited <code>type</code>
	 *                   property. There is only one type of error event:
	 *                   <code>ErrorEvent.ERROR</code>.
	 * @param bubbles    Determines whether the Event object bubbles. Event
	 *                   listeners can access this information through the
	 *                   inherited <code>bubbles</code> property.
	 * @param cancelable Determines whether the Event object can be canceled.
	 *                   Event listeners can access this information through the
	 *                   inherited <code>cancelable</code> property.
	 * @param text       Text to be displayed as an error message. Event
	 *                   listeners can access this information through the
	 *                   <code>text</code> property.
	 * @param id         A reference number to associate with the specific error
	 *                  (supported in Adobe AIR only).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* An object dispatches an ErrorEvent object when an error causes an
 * asynchronous operation to fail.
 *
 * <p>The ErrorEvent class defines only one type of <code>error</code> event:
 * <code>ErrorEvent.ERROR</code>. The ErrorEvent class also serves as the base
 * class for several other error event classes, including the AsyncErrorEvent,
 * IOErrorEvent, SecurityErrorEvent, SQLErrorEvent, and UncaughtErrorEvent
 * classes.</p>
 *
 * <p>You can check for <code>error</code> events that do not have any
 * listeners by registering a listener for the <code>uncaughtError</code>
 * (UncaughtErrorEvent.UNCAUGHT_ERROR) event.</p>
 *
 * <p>An uncaught error also causes an error dialog box displaying the error
 * event to appear when content is running in the debugger version of Flash
 * Player or the AIR Debug Launcher(ADL) application.</p>
 *]]></haxe_doc>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/EventPhase.hx">
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<CAPTURING_PHASE/>
		<haxe_doc><![CDATA[* The EventPhase class provides values for the <code>eventPhase</code>
 * property of the Event class.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>Int</e></m>
		</meta>
	</enum>
	<class path="flash.events.FocusEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/FocusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<FOCUS_IN public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>focusIn</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</FOCUS_IN>
		<FOCUS_OUT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>focusOut</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>keyFocusChange</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseFocusChange</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_FOCUS_CHANGE>
		<shiftKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the Shift key modifier is activated, in which case the
	 * value is <code>true</code>. Otherwise, the value is <code>false</code>.
	 * This property is used only if the FocusEvent is of type
	 * <code>keyFocusChange</code>.]]></haxe_doc>
		</shiftKey>
		<relatedObject public="1">
			<c path="flash.display.InteractiveObject"/>
			<haxe_doc><![CDATA[* A reference to the complementary InteractiveObject instance that is
	 * affected by the change in focus. For example, when a <code>focusOut</code>
	 * event occurs, the <code>relatedObject</code> represents the
	 * InteractiveObject instance that has gained focus.
	 *
	 * <p>The value of this property can be <code>null</code> in two
	 * circumstances: if there no related object, or there is a related object,
	 * but it is in a security sandbox to which you don't have access. Use the
	 * <code>isRelatedObjectInaccessible()</code> property to determine which of
	 * these reasons applies.</p>]]></haxe_doc>
		</relatedObject>
		<keyCode public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The key code value of the key pressed to trigger a
	 * <code>keyFocusChange</code> event.]]></haxe_doc>
		</keyCode>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object with specific information relevant to focus
	 * events. Event objects are passed as parameters to event listeners.
	 * 
	 * @param type          The type of the event. Possible values are:
	 *                      <code>FocusEvent.FOCUS_IN</code>,
	 *                      <code>FocusEvent.FOCUS_OUT</code>,
	 *                      <code>FocusEvent.KEY_FOCUS_CHANGE</code>, and
	 *                      <code>FocusEvent.MOUSE_FOCUS_CHANGE</code>.
	 * @param bubbles       Determines whether the Event object participates in
	 *                      the bubbling stage of the event flow.
	 * @param cancelable    Determines whether the Event object can be canceled.
	 * @param relatedObject Indicates the complementary InteractiveObject
	 *                      instance that is affected by the change in focus. For
	 *                      example, when a <code>focusIn</code> event occurs,
	 *                      <code>relatedObject</code> represents the
	 *                      InteractiveObject that has lost focus.
	 * @param shiftKey      Indicates whether the Shift key modifier is
	 *                      activated.
	 * @param keyCode       Indicates the code of the key pressed to trigger a
	 *                      <code>keyFocusChange</code> event.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* An object dispatches a FocusEvent object when the user changes the focus
 * from one object in the display list to another. There are four types of
 * focus events:
 * <ul>
 *   <li><code>FocusEvent.FOCUS_IN</code></li>
 *   <li><code>FocusEvent.FOCUS_OUT</code></li>
 *   <li><code>FocusEvent.KEY_FOCUS_CHANGE</code></li>
 *   <li><code>FocusEvent.MOUSE_FOCUS_CHANGE</code></li>
 * </ul>
 *]]></haxe_doc>
	</class>
	<class path="flash.events.IOErrorEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of an
	 * <code>ioError</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?text:?id">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object that contains specific information about
	 * <code>ioError</code> events. Event objects are passed as parameters to
	 * Event listeners.
	 * 
	 * @param type       The type of the event. Event listeners can access this
	 *                   information through the inherited <code>type</code>
	 *                   property. There is only one type of input/output error
	 *                   event: <code>IOErrorEvent.IO_ERROR</code>.
	 * @param bubbles    Determines whether the Event object participates in the
	 *                   bubbling stage of the event flow. Event listeners can
	 *                   access this information through the inherited
	 *                   <code>bubbles</code> property.
	 * @param cancelable Determines whether the Event object can be canceled.
	 *                   Event listeners can access this information through the
	 *                   inherited <code>cancelable</code> property.
	 * @param text       Text to be displayed as an error message. Event
	 *                   listeners can access this information through the
	 *                   <code>text</code> property.
	 * @param id         A reference number to associate with the specific error
	 *                  (supported in Adobe AIR only).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* An IOErrorEvent object is dispatched when an error causes input or output
 * operations to fail.
 *
 * <p>You can check for error events that do not have any listeners by using
 * the debugger version of Flash Player or the AIR Debug Launcher(ADL). The
 * string defined by the <code>text</code> parameter of the IOErrorEvent
 * constructor is displayed.</p>
 *]]></haxe_doc>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>KeyboardEvent.KEY_DOWN</code> constant defines the value of the
	 * <code>type</code> property of a <code>keyDown</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</KEY_DOWN>
		<KEY_UP public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The <code>KeyboardEvent.KEY_UP</code> constant defines the value of the
	 * <code>type</code> property of a <code>keyUp</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</KEY_UP>
		<updateAfterEvent public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Indicates that the display should be rendered after processing of this
	 * event completes, if the display list has been modified
	 *</haxe_doc>
		</updateAfterEvent>
		<shiftKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates the location of the key on the keyboard. This is useful for
	 * differentiating keys that appear more than once on a keyboard. For
	 * example, you can differentiate between the left and right Shift keys by
	 * the value of this property: <code>KeyLocation.LEFT</code> for the left and
	 * <code>KeyLocation.RIGHT</code> for the right. Another example is
	 * differentiating between number keys pressed on the standard keyboard
	 * (<code>KeyLocation.STANDARD</code>) versus the numeric keypad
	 * (<code>KeyLocation.NUM_PAD</code>).]]></haxe_doc>
		</shiftKey>
		<keyCode public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The key code value of the key pressed or released.
	 *
	 * <p><b>Note: </b>When an input method editor(IME) is running,
	 * <code>keyCode</code> does not report accurate key codes.</p>]]></haxe_doc>
		</keyCode>
		<ctrlKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* On Windows and Linux, indicates whether the Ctrl key is active
	 * (<code>true</code>) or inactive(<code>false</code>); On Mac OS, indicates
	 * whether either the Ctrl key or the Command key is active.]]></haxe_doc>
		</ctrlKey>
		<charCode public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Contains the character code value of the key pressed or released. The
	 * character code values are English keyboard values. For example, if you
	 * press Shift+3, <code>charCode</code> is # on a Japanese keyboard, just as
	 * it is on an English keyboard.
	 *
	 * <p><b>Note: </b>When an input method editor(IME) is running,
	 * <code>charCode</code> does not report accurate character codes.</p>]]></haxe_doc>
		</charCode>
		<altKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the Alt key is active(<code>true</code>) or inactive
	 * (<code>false</code>) on Windows; indicates whether the Option key is
	 * active on Mac OS.]]></haxe_doc>
		</altKey>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?charCodeValue:?keyCodeValue">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object that contains specific information about keyboard
	 * events. Event objects are passed as parameters to event listeners.
	 * 
	 * @param type          The type of the event. Possible values are:
	 *                      <code>KeyboardEvent.KEY_DOWN</code> and
	 *                      <code>KeyboardEvent.KEY_UP</code>
	 * @param bubbles       Determines whether the Event object participates in
	 *                      the bubbling stage of the event flow.
	 * @param cancelable    Determines whether the Event object can be canceled.
	 * @param charCodeValue The character code value of the key pressed or
	 *                      released. The character code values returned are
	 *                      English keyboard values. For example, if you press
	 *                      Shift+3, the <code>Keyboard.charCode()</code>
	 *                      property returns # on a Japanese keyboard, just as it
	 *                      does on an English keyboard.
	 * @param keyCodeValue  The key code value of the key pressed or released.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A KeyboardEvent object id dispatched in response to user input through a
 * keyboard. There are two types of keyboard events:
 * <code>KeyboardEvent.KEY_DOWN</code> and <code>KeyboardEvent.KEY_UP</code>
 *
 * <p>Because mappings between keys and specific characters vary by device and
 * operating system, use the TextEvent event type for processing character
 * input.</p>
 *
 * <p>To listen globally for key events, listen on the Stage for the capture
 * and target or bubble phase.</p>
 *]]></haxe_doc>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>click</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</CLICK>
		<DOUBLE_CLICK public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>doubleClick</code> event object. The <code>doubleClickEnabled</code>
	 * property must be <code>true</code> for an object to generate the
	 * <code>doubleClick</code> event.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</DOUBLE_CLICK>
		<MOUSE_DOWN public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseDown</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseMove</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseOut</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_OUT>
		<MOUSE_OVER public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseOver</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_OVER>
		<MOUSE_UP public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseUp</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>mouseWheel</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</MOUSE_WHEEL>
		<ROLL_OUT public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>rollOut</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ROLL_OUT>
		<ROLL_OVER public="1" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Defines the value of the <code>type</code> property of a
	 * <code>rollOver</code> event object.
	 *
	 * <p>This event has the following properties:</p>]]></haxe_doc>
		</ROLL_OVER>
		<updateAfterEvent public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instructs Flash Player or Adobe AIR to render after processing of this
	 * event completes, if the display list has been modified.
	 *</haxe_doc>
		</updateAfterEvent>
		<stageY public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The vertical coordinate at which the event occurred in global Stage
	 * coordinates. This property is calculated when the <code>localY</code>
	 * property is set.]]></haxe_doc>
		</stageY>
		<stageX public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The horizontal coordinate at which the event occurred in global Stage
	 * coordinates. This property is calculated when the <code>localX</code>
	 * property is set.]]></haxe_doc>
		</stageX>
		<shiftKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the Shift key is active(<code>true</code>) or inactive
	 * (<code>false</code>).]]></haxe_doc>
		</shiftKey>
		<relatedObject public="1">
			<c path="flash.display.InteractiveObject"/>
			<haxe_doc><![CDATA[* A reference to a display list object that is related to the event. For
	 * example, when a <code>mouseOut</code> event occurs,
	 * <code>relatedObject</code> represents the display list object to which the
	 * pointing device now points. This property applies to the
	 * <code>mouseOut</code>, <code>mouseOver</code>, <code>rollOut</code>, and
	 * <code>rollOver</code> events.
	 *
	 * <p>The value of this property can be <code>null</code> in two
	 * circumstances: if there no related object, or there is a related object,
	 * but it is in a security sandbox to which you don't have access. Use the
	 * <code>isRelatedObjectInaccessible()</code> property to determine which of
	 * these reasons applies.</p>]]></haxe_doc>
		</relatedObject>
		<localY public="1">
			<x path="Float"/>
			<haxe_doc>* The vertical coordinate at which the event occurred relative to the
	 * containing sprite.</haxe_doc>
		</localY>
		<localX public="1">
			<x path="Float"/>
			<haxe_doc>* The horizontal coordinate at which the event occurred relative to the
	 * containing sprite.</haxe_doc>
		</localX>
		<delta public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Indicates how many lines should be scrolled for each unit the user rotates
	 * the mouse wheel. A positive delta value indicates an upward scroll; a
	 * negative value indicates a downward scroll. Typical values are 1 to 3, but
	 * faster rotation may produce larger values. This setting depends on the
	 * device and operating system and is usually configurable by the user. This
	 * property applies only to the <code>MouseEvent.mouseWheel</code> event.]]></haxe_doc>
		</delta>
		<ctrlKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* On Windows or Linux, indicates whether the Ctrl key is active
	 * (<code>true</code>) or inactive(<code>false</code>). On Macintosh,
	 * indicates whether either the Control key or the Command key is activated.]]></haxe_doc>
		</ctrlKey>
		<buttonDown public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the primary mouse button is pressed(<code>true</code>)
	 * or not(<code>false</code>).]]></haxe_doc>
		</buttonDown>
		<altKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the Alt key is active(<code>true</code>) or inactive
	 * (<code>false</code>). Supported for Windows only. On other operating
	 * systems, this property is always set to <code>false</code>.]]></haxe_doc>
		</altKey>
		<new public="1" set="method">
			<f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object that contains information about mouse events.
	 * Event objects are passed as parameters to event listeners.
	 * 
	 * @param type          The type of the event. Possible values are:
	 *                      <code>MouseEvent.CLICK</code>,
	 *                      <code>MouseEvent.DOUBLE_CLICK</code>,
	 *                      <code>MouseEvent.MOUSE_DOWN</code>,
	 *                      <code>MouseEvent.MOUSE_MOVE</code>,
	 *                      <code>MouseEvent.MOUSE_OUT</code>,
	 *                      <code>MouseEvent.MOUSE_OVER</code>,
	 *                      <code>MouseEvent.MOUSE_UP</code>,
	 *                      <code>MouseEvent.MIDDLE_CLICK</code>,
	 *                      <code>MouseEvent.MIDDLE_MOUSE_DOWN</code>,
	 *                      <code>MouseEvent.MIDDLE_MOUSE_UP</code>,
	 *                      <code>MouseEvent.RIGHT_CLICK</code>,
	 *                      <code>MouseEvent.RIGHT_MOUSE_DOWN</code>,
	 *                      <code>MouseEvent.RIGHT_MOUSE_UP</code>,
	 *                      <code>MouseEvent.MOUSE_WHEEL</code>,
	 *                      <code>MouseEvent.ROLL_OUT</code>, and
	 *                      <code>MouseEvent.ROLL_OVER</code>.
	 * @param bubbles       Determines whether the Event object participates in
	 *                      the bubbling phase of the event flow.
	 * @param cancelable    Determines whether the Event object can be canceled.
	 * @param localX        The horizontal coordinate at which the event occurred
	 *                      relative to the containing sprite.
	 * @param localY        The vertical coordinate at which the event occurred
	 *                      relative to the containing sprite.
	 * @param relatedObject The complementary InteractiveObject instance that is
	 *                      affected by the event. For example, when a
	 *                      <code>mouseOut</code> event occurs,
	 *                      <code>relatedObject</code> represents the display
	 *                      list object to which the pointing device now points.
	 * @param ctrlKey       On Windows or Linux, indicates whether the Ctrl key
	 *                      is activated. On Mac, indicates whether either the
	 *                      Ctrl key or the Command key is activated.
	 * @param altKey        Indicates whether the Alt key is activated(Windows
	 *                      or Linux only).
	 * @param shiftKey      Indicates whether the Shift key is activated.
	 * @param buttonDown    Indicates whether the primary mouse button is
	 *                      pressed.
	 * @param delta         Indicates how many lines should be scrolled for each
	 *                      unit the user rotates the mouse wheel. A positive
	 *                      delta value indicates an upward scroll; a negative
	 *                      value indicates a downward scroll. Typical values are
	 *                      1 to 3, but faster rotation may produce larger
	 *                      values. This parameter is used only for the
	 *                      <code>MouseEvent.mouseWheel</code> event.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A MouseEvent object is dispatched into the event flow whenever mouse events
 * occur. A mouse event is usually generated by a user input device, such as a
 * mouse or a trackball, that uses a pointer.
 *
 * <p>When nested nodes are involved, mouse events target the deepest possible
 * nested node that is visible in the display list. This node is called the
 * <i>target node</i>. To have a target node's ancestor receive notification
 * of a mouse event, use <code>EventDispatcher.addEventListener()</code> on
 * the ancestor node with the <code>type</code> parameter set to the specific
 * mouse event you want to detect.</p>
 *]]></haxe_doc>
	</class>
	<class path="flash.events.TouchEvent" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/events/TouchEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<updateAfterEvent public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instructs Flash Player or Adobe AIR to render after processing of this
	 * event completes, if the display list has been modified.
	 *</haxe_doc>
		</updateAfterEvent>
		<touchPointID public="1">
			<x path="Int"/>
			<haxe_doc>* A unique identification number(as an int) assigned to the touch point.</haxe_doc>
		</touchPointID>
		<stageY public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The vertical coordinate at which the event occurred in global Stage
	 * coordinates. This property is calculated when the <code>localY</code>
	 * property is set.]]></haxe_doc>
		</stageY>
		<stageX public="1" set="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The horizontal coordinate at which the event occurred in global Stage
	 * coordinates. This property is calculated when the <code>localX</code>
	 * property is set.]]></haxe_doc>
		</stageX>
		<sizeY public="1">
			<x path="Float"/>
			<haxe_doc>* Height of the contact area.
	 * Only supported on Android(C++ target), in the range of 0-1.</haxe_doc>
		</sizeY>
		<sizeX public="1">
			<x path="Float"/>
			<haxe_doc>* Width of the contact area.
	 * Only supported on Android(C++ target), in the range of 0-1.</haxe_doc>
		</sizeX>
		<shiftKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the Shift key is active(<code>true</code>) or inactive
	 * (<code>false</code>).]]></haxe_doc>
		</shiftKey>
		<relatedObject public="1">
			<c path="flash.display.InteractiveObject"/>
			<haxe_doc><![CDATA[* A reference to a display list object that is related to the event. For
	 * example, when a <code>touchOut</code> event occurs,
	 * <code>relatedObject</code> represents the display list object to which the
	 * pointing device now points. This property applies to the
	 * <code>touchOut</code>, <code>touchOver</code>, <code>touchRollOut</code>,
	 * and <code>touchRollOver</code> events.
	 *
	 * <p>The value of this property can be <code>null</code> in two
	 * circumstances: if there is no related object, or there is a related
	 * object, but it is in a security sandbox to which you don't have access.
	 * Use the <code>isRelatedObjectInaccessible()</code> property to determine
	 * which of these reasons applies.</p>]]></haxe_doc>
		</relatedObject>
		<pressure public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* A value between <code>0.0</code> and <code>1.0</code> indicating force of
	 * the contact with the device. If the device does not support detecting the
	 * pressure, the value is <code>1.0</code>.]]></haxe_doc>
		</pressure>
		<localY public="1">
			<x path="Float"/>
			<haxe_doc>* The vertical coordinate at which the event occurred relative to the
	 * containing sprite.</haxe_doc>
		</localY>
		<localX public="1">
			<x path="Float"/>
			<haxe_doc>* The horizontal coordinate at which the event occurred relative to the
	 * containing sprite.</haxe_doc>
		</localX>
		<isRelatedObjectInaccessible public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* If <code>true</code>, the <code>relatedObject</code> property is set to
	 * <code>null</code> for reasons related to security sandboxes. If the
	 * nominal value of <code>relatedObject</code> is a reference to a
	 * DisplayObject in another sandbox, <code>relatedObject</code> is set to
	 * <code>null</code> unless there is permission in both directions across
	 * this sandbox boundary. Permission is established by calling
	 * <code>Security.allowDomain()</code> from a SWF file, or by providing a
	 * policy file from the server of an image file, and setting the
	 * <code>LoaderContext.checkPolicyFile</code> property when loading the
	 * image.]]></haxe_doc>
		</isRelatedObjectInaccessible>
		<isPrimaryTouchPoint public="1">
			<x path="Bool"/>
			<haxe_doc>* Indicates whether the first point of contact is mapped to mouse events.</haxe_doc>
		</isPrimaryTouchPoint>
		<ctrlKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* On Windows or Linux, indicates whether the Ctrl key is active
	 * (<code>true</code>) or inactive(<code>false</code>). On Macintosh,
	 * indicates whether either the Control key or the Command key is activated.]]></haxe_doc>
		</ctrlKey>
		<altKey public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the Alt key is active(<code>true</code>) or inactive
	 * (<code>false</code>). Supported for Windows and Linux operating systems
	 * only.]]></haxe_doc>
		</altKey>
		<new public="1">
			<f a="type:?bubbles:?cancelable:?touchPointID:?isPrimaryTouchPoint:?localX:?localY:?sizeX:?sizeY:?pressure:?relatedObject:?ctrlKey:?altKey:?shiftKey">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.display.InteractiveObject"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates an Event object that contains information about touch events.
	 * Event objects are passed as parameters to event listeners.
	 * 
	 * @param type                The type of the event. Possible values are:
	 *                            <code>TouchEvent.TOUCH_BEGIN</code>,
	 *                            <code>TouchEvent.TOUCH_END</code>,
	 *                            <code>TouchEvent.TOUCH_MOVE</code>,
	 *                            <code>TouchEvent.TOUCH_OUT</code>,
	 *                            <code>TouchEvent.TOUCH_OVER</code>,
	 *                            <code>TouchEvent.TOUCH_ROLL_OUT</code>,
	 *                            <code>TouchEvent.TOUCH_ROLL_OVER</code>, and
	 *                            <code>TouchEvent.TOUCH_TAP</code>.
	 * @param bubbles             Determines whether the Event object
	 *                            participates in the bubbling phase of the event
	 *                            flow.
	 * @param cancelable          Determines whether the Event object can be
	 *                            canceled.
	 * @param touchPointID        A unique identification number(as an int)
	 *                            assigned to the touch point.
	 * @param isPrimaryTouchPoint Indicates whether the first point of contact is
	 *                            mapped to mouse events.
	 * @param relatedObject       The complementary InteractiveObject instance
	 *                            that is affected by the event. For example,
	 *                            when a <code>touchOut</code> event occurs,
	 *                            <code>relatedObject</code> represents the
	 *                            display list object to which the pointing
	 *                            device now points.
	 * @param ctrlKey             On Windows or Linux, indicates whether the Ctrl
	 *                            key is activated. On Mac, indicates whether
	 *                            either the Ctrl key or the Command key is
	 *                            activated.
	 * @param altKey              Indicates whether the Alt key is activated
	 *                           (Windows or Linux only).
	 * @param shiftKey            Indicates whether the Shift key is activated.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The TouchEvent class lets you handle events on devices that detect user
 * contact with the device(such as a finger on a touch screen). When a user
 * interacts with a device such as a mobile phone or tablet with a touch
 * screen, the user typically touches the screen with his or her fingers or a
 * pointing device. You can develop applications that respond to basic touch
 * events(such as a single finger tap) with the TouchEvent class. Create
 * event listeners using the event types defined in this class. For user
 * interaction with multiple points of contact(such as several fingers moving
 * across a touch screen at the same time) use the related GestureEvent,
 * PressAndTapGestureEvent, and TransformGestureEvent classes. And, use the
 * properties and methods of these classes to construct event handlers that
 * respond to the user touching the device.
 *
 * <p>Use the Multitouch class to determine the current environment's support
 * for touch interaction, and to manage the support of touch interaction if
 * the current environment supports it.</p>
 *
 * <p><b>Note:</b> When objects are nested on the display list, touch events
 * target the deepest possible nested object that is visible in the display
 * list. This object is called the target node. To have a target node's
 * ancestor(an object containing the target node in the display list) receive
 * notification of a touch event, use
 * <code>EventDispatcher.addEventListener()</code> on the ancestor node with
 * the type parameter set to the specific touch event you want to detect.</p>
 *]]></haxe_doc>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether this player is in a container that offers an external
	 * interface. If the external interface is available, this property is
	 * <code>true</code>; otherwise, it is <code>false</code>.
	 *
	 * <p><b>Note:</b> When using the External API with HTML, always check that
	 * the HTML has finished loading before you attempt to call any JavaScript
	 * methods.</p>]]></haxe_doc>
		</available>
		<marshallExceptions public="1" static="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether the external interface should attempt to pass
	 * ActionScript exceptions to the current browser and JavaScript exceptions
	 * to the player. You must explicitly set this property to <code>true</code>
	 * to catch JavaScript exceptions in ActionScript and to catch ActionScript
	 * exceptions in JavaScript.]]></haxe_doc>
		</marshallExceptions>
		<objectID public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Returns the <code>id</code> attribute of the <code>object</code> tag in
	 * Internet Explorer, or the <code>name</code> attribute of the
	 * <code>embed</code> tag in Netscape.]]></haxe_doc>
		</objectID>
		<addCallback public="1" set="method" static="1">
			<f a="functionName:closure">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Registers an ActionScript method as callable from the container. After a
	 * successful invocation of <code>addCallBack()</code>, the registered
	 * function in the player can be called by JavaScript or ActiveX code in the
	 * container.
	 *
	 * <p><b>Note:</b> For <i>local</i> content running in a browser, calls to
	 * the <code>ExternalInterface.addCallback()</code> method work only if the
	 * SWF file and the containing web page are in the local-trusted security
	 * sandbox. For more information, see the Flash Player Developer Center
	 * Topic: <a href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @param functionName The name by which the container can invoke the
	 *                     function.
	 * @param closure      The function closure to invoke. This could be a
	 *                     free-standing function, or it could be a method
	 *                     closure referencing a method of an object instance. By
	 *                     passing a method closure, you can direct the callback
	 *                     at a method of a particular object instance.
	 *
	 *                     <p><b>Note:</b> Repeating <code>addCallback()</code>
	 *                     on an existing callback function with a
	 *                     <code>null</code> closure value removes the
	 *                     callback.</p>
	 * @throws Error         The container does not support incoming calls.
	 *                       Incoming calls are supported only in Internet
	 *                       Explorer for Windows and browsers that use the
	 *                       NPRuntime API such as Mozilla 1.7.5 and later or
	 *                       Firefox 1.0 and later.
	 * @throws SecurityError A callback with the specified name has already been
	 *                       added by ActionScript in a sandbox to which you do
	 *                       not have access; you cannot overwrite that callback.
	 *                       To work around this problem, rewrite the
	 *                       ActionScript that originally called the
	 *                       <code>addCallback()</code> method so that it also
	 *                       calls the <code>Security.allowDomain()</code>
	 *                       method.
	 * @throws SecurityError The containing environment belongs to a security
	 *                       sandbox to which the calling code does not have
	 *                       access. To fix this problem, follow these steps:
	 *                       <ol>
	 *                         <li>In the <code>object</code> tag for the SWF
	 *                       file in the containing HTML page, set the following
	 *                       parameter:
	 *
	 *                       <p><code><param name="allowScriptAccess"
	 *                       value="always" /></code></p>
	 *                       </li>
	 *                         <li>In the SWF file, add the following
	 *                       ActionScript:
	 *
	 *
	 *                       <p><code>flash.system.Security.allowDomain(<i>sourceDomain</i>)</code></p>
	 *                       </li>
	 *                       </ol>]]></haxe_doc>
		</addCallback>
		<call public="1" set="method" static="1">
			<f a="functionName:?p1:?p2:?p3:?p4:?p5">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc><![CDATA[* Calls a function exposed by the SWF container, passing zero or more
	 * arguments. If the function is not available, the call returns
	 * <code>null</code>; otherwise it returns the value provided by the
	 * function. Recursion is <i>not</i> permitted on Opera or Netscape browsers;
	 * on these browsers a recursive call produces a <code>null</code> response.
	 * (Recursion is supported on Internet Explorer and Firefox browsers.)
	 *
	 * <p>If the container is an HTML page, this method invokes a JavaScript
	 * function in a <code>script</code> element.</p>
	 *
	 * <p>If the container is another ActiveX container, this method dispatches
	 * the FlashCall ActiveX event with the specified name, and the container
	 * processes the event.</p>
	 *
	 * <p>If the container is hosting the Netscape plug-in, you can either write
	 * custom support for the new NPRuntime interface or embed an HTML control
	 * and embed the player within the HTML control. If you embed an HTML
	 * control, you can communicate with the player through a JavaScript
	 * interface to the native container application.</p>
	 *
	 * <p><b>Note:</b> For <i>local</i> content running in a browser, calls to
	 * the <code>ExternalInterface.call()</code> method are permitted only if the
	 * SWF file and the containing web page(if there is one) are in the
	 * local-trusted security sandbox. Also, you can prevent a SWF file from
	 * using this method by setting the <code>allowNetworking</code> parameter of
	 * the <code>object</code> and <code>embed</code> tags in the HTML page that
	 * contains the SWF content. For more information, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 *
	 * <p><b>Note for Flash Player applications:</b> In Flash Player 10 and Flash
	 * Player 9 Update 5, some web browsers restrict this method if a pop-up
	 * blocker is enabled. In this scenario, you can only call this method
	 * successfully in response to a user event(for example, in an event handler
	 * for a mouse click or keypress event).</p>
	 * 
	 * @param functionName The alphanumeric name of the function to call in the
	 *                     container. Using a non-alphanumeric function name
	 *                     causes a runtime error(error 2155). You can use a
	 *                     <code>try..catch</code> block to handle the error.
	 * @return The response received from the container. If the call failed–
	 *         for example, if there is no such function in the container, the
	 *         interface is not available, a recursion occurred(with a Netscape
	 *         or Opera browser), or there is a security issue–
	 *         <code>null</code> is returned and an error is thrown.
	 * @throws Error         The container does not support outgoing calls.
	 *                       Outgoing calls are supported only in Internet
	 *                       Explorer for Windows and browsers that use the
	 *                       NPRuntime API such as Mozilla 1.7.5 and later or
	 *                       Firefox 1.0 and later.
	 * @throws SecurityError The containing environment belongs to a security
	 *                       sandbox to which the calling code does not have
	 *                       access. To fix this problem, follow these steps:
	 *                       <ol>
	 *                         <li>In the <code>object</code> tag for the SWF
	 *                       file in the containing HTML page, set the following
	 *                       parameter:
	 *
	 *                       <p><code><param name="allowScriptAccess"
	 *                       value="always" /></code></p>
	 *                       </li>
	 *                         <li>In the SWF file, add the following
	 *                       ActionScript:
	 *
	 *
	 *                       <p><code>flash.system.Security.allowDomain(<i>sourceDomain</i>)</code></p>
	 *                       </li>
	 *                       </ol>]]></haxe_doc>
		</call>
		<haxe_doc><![CDATA[* The ExternalInterface class is an application programming interface that
 * enables straightforward communication between ActionScript and the SWF
 * container– for example, an HTML page with JavaScript or a desktop
 * application that uses Flash Player to display a SWF file.
 *
 * <p>Using the ExternalInterface class, you can call an ActionScript function
 * in the Flash runtime, using JavaScript in the HTML page. The ActionScript
 * function can return a value, and JavaScript receives it immediately as the
 * return value of the call.</p>
 *
 * <p>This functionality replaces the <code>fscommand()</code> method.</p>
 *
 * <p>Use the ExternalInterface class in the following combinations of browser
 * and operating system:</p>
 *
 * <p>The ExternalInterface class requires the user's web browser to support
 * either ActiveX<sup>®</sup> or the NPRuntime API that is exposed by some
 * browsers for plug-in scripting. Even if a browser and operating system
 * combination are not listed above, they should support the ExternalInterface
 * class if they support the NPRuntime API. See <a
 * href="http://www.mozilla.org/projects/plugins/npruntime.html"
 * scope="external">http://www.mozilla.org/projects/plugins/npruntime.html</a>.</p>
 *
 * <p><b>Note:</b> When embedding SWF files within an HTML page, make sure
 * that the <code>id</code> attribute is set and the <code>id</code> and
 * <code>name</code> attributes of the <code>object</code> and
 * <code>embed</code> tags do not include the following characters:</p>
 * <pre xml:space="preserve"> . - + ~~ / \ </pre>
 *
 * <p><b>Note for Flash Player applications:</b> Flash Player version
 * 9.0.115.0 and later allows the <code>.</code>(period) character within the
 * <code>id</code> and <code>name</code> attributes.</p>
 *
 * <p><b>Note for Flash Player applications:</b> In Flash Player 10 and later
 * running in a browser, using this class programmatically to open a pop-up
 * window may not be successful. Various browsers(and browser configurations)
 * may block pop-up windows at any time; it is not possible to guarantee any
 * pop-up window will appear. However, for the best chance of success, use
 * this class to open a pop-up window only in code that executes as a direct
 * result of a user action(for example, in an event handler for a mouse click
 * or key-press event.)</p>
 *
 * <p>From ActionScript, you can do the following on the HTML page:
 * <ul>
 *   <li>Call any JavaScript function.</li>
 *   <li>Pass any number of arguments, with any names.</li>
 *   <li>Pass various data types(Boolean, Number, String, and so on).</li>
 *   <li>Receive a return value from the JavaScript function.</li>
 * </ul>
 * </p>
 *
 * <p>From JavaScript on the HTML page, you can:
 * <ul>
 *   <li>Call an ActionScript function.</li>
 *   <li>Pass arguments using standard function call notation.</li>
 *   <li>Return a value to the JavaScript function.</li>
 * </ul>
 * </p>
 *
 * <p><b>Note for Flash Player applications:</b> Flash Player does not
 * currently support SWF files embedded within HTML forms.</p>
 *
 * <p><b>Note for AIR applications:</b> In Adobe AIR, the ExternalInterface
 * class can be used to communicate between JavaScript in an HTML page loaded
 * in the HTMLLoader control and ActionScript in SWF content embedded in that
 * HTML page.</p>]]></haxe_doc>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method">
			<f a=""><c path="flash.filters.BitmapFilter"/></f>
			<haxe_doc>* Returns a BitmapFilter object that is an exact copy of the original
	 * BitmapFilter object.
	 * 
	 * @return A BitmapFilter object.</haxe_doc>
		</clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The BitmapFilter class is the base class for all image filter effects.
 *
 * <p>The BevelFilter, BlurFilter, ColorMatrixFilter, ConvolutionFilter,
 * DisplacementMapFilter, DropShadowFilter, GlowFilter, GradientBevelFilter,
 * and GradientGlowFilter classes all extend the BitmapFilter class. You can
 * apply these filter effects to any display object.</p>
 *
 * <p>You can neither directly instantiate nor extend BitmapFilter.</p>]]></haxe_doc>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Formats and returns a string that describes all of the properties of the
	 * ColorTransform object.
	 * 
	 * @return A string that lists all of the properties of the ColorTransform
	 *         object.</haxe_doc>
		</toString>
		<concat public="1" set="method">
			<f a="second">
				<c path="flash.geom.ColorTransform"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Concatenates the ColorTranform object specified by the <code>second</code>
	 * parameter with the current ColorTransform object and sets the current
	 * object as the result, which is an additive combination of the two color
	 * transformations. When you apply the concatenated ColorTransform object,
	 * the effect is the same as applying the <code>second</code> color
	 * transformation after the <i>original</i> color transformation.
	 * 
	 * @param second The ColorTransform object to be combined with the current
	 *               ColorTransform object.]]></haxe_doc>
		</concat>
		<redOffset public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* A number from -255 to 255 that is added to the red channel value after it
	 * has been multiplied by the <code>redMultiplier</code> value.]]></haxe_doc>
		</redOffset>
		<redMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* A decimal value that is multiplied with the red channel value.</haxe_doc>
		</redMultiplier>
		<greenOffset public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* A number from -255 to 255 that is added to the green channel value after
	 * it has been multiplied by the <code>greenMultiplier</code> value.]]></haxe_doc>
		</greenOffset>
		<greenMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* A decimal value that is multiplied with the green channel value.</haxe_doc>
		</greenMultiplier>
		<color public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The RGB color value for a ColorTransform object.
	 *
	 * <p>When you set this property, it changes the three color offset values
	 * (<code>redOffset</code>, <code>greenOffset</code>, and
	 * <code>blueOffset</code>) accordingly, and it sets the three color
	 * multiplier values(<code>redMultiplier</code>,
	 * <code>greenMultiplier</code>, and <code>blueMultiplier</code>) to 0. The
	 * alpha transparency multiplier and offset values do not change.</p>
	 *
	 * <p>When you pass a value for this property, use the format
	 * 0x<i>RRGGBB</i>. <i>RR</i>, <i>GG</i>, and <i>BB</i> each consist of two
	 * hexadecimal digits that specify the offset of each color component. The 0x
	 * tells the ActionScript compiler that the number is a hexadecimal
	 * value.</p>]]></haxe_doc>
		</color>
		<blueOffset public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* A number from -255 to 255 that is added to the blue channel value after it
	 * has been multiplied by the <code>blueMultiplier</code> value.]]></haxe_doc>
		</blueOffset>
		<blueMultiplier public="1">
			<x path="Float"/>
			<haxe_doc>* A decimal value that is multiplied with the blue channel value.</haxe_doc>
		</blueMultiplier>
		<alphaOffset public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* A number from -255 to 255 that is added to the alpha transparency channel
	 * value after it has been multiplied by the <code>alphaMultiplier</code>
	 * value.]]></haxe_doc>
		</alphaOffset>
		<alphaMultiplier public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* A decimal value that is multiplied with the alpha transparency channel
	 * value.
	 *
	 * <p>If you set the alpha transparency value of a display object directly by
	 * using the <code>alpha</code> property of the DisplayObject instance, it
	 * affects the value of the <code>alphaMultiplier</code> property of that
	 * display object's <code>transform.colorTransform</code> property.</p>]]></haxe_doc>
		</alphaMultiplier>
		<new public="1" set="method">
			<f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a ColorTransform object for a display object with the specified
	 * color channel values and alpha values.
	 * 
	 * @param redMultiplier   The value for the red multiplier, in the range from
	 *                        0 to 1.
	 * @param greenMultiplier The value for the green multiplier, in the range
	 *                        from 0 to 1.
	 * @param blueMultiplier  The value for the blue multiplier, in the range
	 *                        from 0 to 1.
	 * @param alphaMultiplier The value for the alpha transparency multiplier, in
	 *                        the range from 0 to 1.
	 * @param redOffset       The offset value for the red color channel, in the
	 *                        range from -255 to 255.
	 * @param greenOffset     The offset value for the green color channel, in
	 *                        the range from -255 to 255.
	 * @param blueOffset      The offset for the blue color channel value, in the
	 *                        range from -255 to 255.
	 * @param alphaOffset     The offset for alpha transparency channel value, in
	 *                        the range from -255 to 255.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The ColorTransform class lets you adjust the color values in a display
 * object. The color adjustment or <i>color transformation</i> can be applied
 * to all four channels: red, green, blue, and alpha transparency.
 *
 * <p>When a ColorTransform object is applied to a display object, a new value
 * for each color channel is calculated like this:</p>
 *
 * <ul>
 *   <li>New red value = (old red value * <code>redMultiplier</code>) +
 * <code>redOffset</code></li>
 *   <li>New green value = (old green value * <code>greenMultiplier</code>) +
 * <code>greenOffset</code></li>
 *   <li>New blue value = (old blue value * <code>blueMultiplier</code>) +
 * <code>blueOffset</code></li>
 *   <li>New alpha value = (old alpha value * <code>alphaMultiplier</code>) +
 * <code>alphaOffset</code></li>
 * </ul>
 *
 * <p>If any of the color channel values is greater than 255 after the
 * calculation, it is set to 255. If it is less than 0, it is set to 0.</p>
 *
 * <p>You can use ColorTransform objects in the following ways:</p>
 *
 * <ul>
 *   <li>In the <code>colorTransform</code> parameter of the
 * <code>colorTransform()</code> method of the BitmapData class</li>
 *   <li>As the <code>colorTransform</code> property of a Transform object
 * (which can be used as the <code>transform</code> property of a display
 * object)</li>
 * </ul>
 *
 * <p>You must use the <code>new ColorTransform()</code> constructor to create
 * a ColorTransform object before you can call the methods of the
 * ColorTransform object.</p>
 *
 * <p>Color transformations do not apply to the background color of a movie
 * clip(such as a loaded SWF object). They apply only to graphics and symbols
 * that are attached to the movie clip.</p>]]></haxe_doc>
	</class>
	<class path="flash.geom.Matrix" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified
	 * by the <code>dx</code> and <code>dy</code> parameters.
	 * 
	 * @param dx The amount of movement along the <i>x</i> axis to the right, in
	 *           pixels.
	 * @param dy The amount of movement down along the <i>y</i> axis, in pixels.]]></haxe_doc>
		</translate>
		<transformPoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Returns the result of applying the geometric transformation represented by
	 * the Matrix object to the specified point.
	 * 
	 * @param point The point for which you want to get the result of the Matrix
	 *              transformation.
	 * @return The point resulting from applying the Matrix transformation.</haxe_doc>
		</transformPoint>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Returns a text value listing the properties of the Matrix object.
	 * 
	 * @return A string containing the values of the properties of the Matrix
	 *         object: <code>a</code>, <code>b</code>, <code>c</code>,
	 *         <code>d</code>, <code>tx</code>, and <code>ty</code>.]]></haxe_doc>
		</toString>
		<scale public="1" set="method">
			<f a="sx:sy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Applies a scaling transformation to the matrix. The <i>x</i> axis is
	 * multiplied by <code>sx</code>, and the <i>y</i> axis it is multiplied by
	 * <code>sy</code>.
	 *
	 * <p>The <code>scale()</code> method alters the <code>a</code> and
	 * <code>d</code> properties of the Matrix object. In matrix notation, this
	 * is the same as concatenating the current matrix with the following
	 * matrix:</p>
	 * 
	 * @param sx A multiplier used to scale the object along the <i>x</i> axis.
	 * @param sy A multiplier used to scale the object along the <i>y</i> axis.]]></haxe_doc>
		</scale>
		<rotate public="1" set="method">
			<f a="angle">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Applies a rotation transformation to the Matrix object.
	 *
	 * <p>The <code>rotate()</code> method alters the <code>a</code>,
	 * <code>b</code>, <code>c</code>, and <code>d</code> properties of the
	 * Matrix object. In matrix notation, this is the same as concatenating the
	 * current matrix with the following:</p>
	 * 
	 * @param angle The rotation angle in radians.]]></haxe_doc>
		</rotate>
		<invert public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Performs the opposite transformation of the original matrix. You can apply
	 * an inverted matrix to an object to undo the transformation performed when
	 * applying the original matrix.
	 *</haxe_doc>
		</invert>
		<identity public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Sets each matrix property to a value that causes a null transformation. An
	 * object transformed by applying an identity matrix will be identical to the
	 * original.
	 *
	 * <p>After calling the <code>identity()</code> method, the resulting matrix
	 * has the following properties: <code>a</code>=1, <code>b</code>=0,
	 * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
	 * <code>ty</code>=0.</p>
	 *
	 * <p>In matrix notation, the identity matrix looks like this:</p>
	 *]]></haxe_doc>
		</identity>
		<deltaTransformPoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Given a point in the pretransform coordinate space, returns the
	 * coordinates of that point after the transformation occurs. Unlike the
	 * standard transformation applied using the <code>transformPoint()</code>
	 * method, the <code>deltaTransformPoint()</code> method's transformation
	 * does not consider the translation parameters <code>tx</code> and
	 * <code>ty</code>.
	 * 
	 * @param point The point for which you want to get the result of the matrix
	 *              transformation.
	 * @return The point resulting from applying the matrix transformation.]]></haxe_doc>
		</deltaTransformPoint>
		<createGradientBox public="1" set="method">
			<f a="width:height:?rotation:?tx:?ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates the specific style of matrix expected by the
	 * <code>beginGradientFill()</code> and <code>lineGradientStyle()</code>
	 * methods of the Graphics class. Width and height are scaled to a
	 * <code>scaleX</code>/<code>scaleY</code> pair and the
	 * <code>tx</code>/<code>ty</code> values are offset by half the width and
	 * height.
	 *
	 * <p>For example, consider a gradient with the following
	 * characteristics:</p>
	 *
	 * <ul>
	 *   <li><code>GradientType.LINEAR</code></li>
	 *   <li>Two colors, green and blue, with the ratios array set to <code>[0,
	 * 255]</code></li>
	 *   <li><code>SpreadMethod.PAD</code></li>
	 *   <li><code>InterpolationMethod.LINEAR_RGB</code></li>
	 * </ul>
	 *
	 * <p>The following illustrations show gradients in which the matrix was
	 * defined using the <code>createGradientBox()</code> method with different
	 * parameter settings:</p>
	 * 
	 * @param width    The width of the gradient box.
	 * @param height   The height of the gradient box.
	 * @param rotation The amount to rotate, in radians.
	 * @param tx       The distance, in pixels, to translate to the right along
	 *                 the <i>x</i> axis. This value is offset by half of the
	 *                 <code>width</code> parameter.
	 * @param ty       The distance, in pixels, to translate down along the
	 *                 <i>y</i> axis. This value is offset by half of the
	 *                 <code>height</code> parameter.]]></haxe_doc>
		</createGradientBox>
		<createBox public="1" set="method">
			<f a="scaleX:scaleY:?rotation:?tx:?ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Includes parameters for scaling, rotation, and translation. When applied
	 * to a matrix it sets the matrix's values based on those parameters.
	 *
	 * <p>Using the <code>createBox()</code> method lets you obtain the same
	 * matrix as you would if you applied the <code>identity()</code>,
	 * <code>rotate()</code>, <code>scale()</code>, and <code>translate()</code>
	 * methods in succession. For example, <code>mat1.createBox(2,2,Math.PI/4,
	 * 100, 100)</code> has the same effect as the following:</p>
	 * 
	 * @param scaleX   The factor by which to scale horizontally.
	 * @param scaleY   The factor by which scale vertically.
	 * @param rotation The amount to rotate, in radians.
	 * @param tx       The number of pixels to translate(move) to the right
	 *                 along the <i>x</i> axis.
	 * @param ty       The number of pixels to translate(move) down along the
	 *                 <i>y</i> axis.]]></haxe_doc>
		</createBox>
		<concat public="1" set="method">
			<f a="m">
				<c path="flash.geom.Matrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Concatenates a matrix with the current matrix, effectively combining the
	 * geometric effects of the two. In mathematical terms, concatenating two
	 * matrixes is the same as combining them using matrix multiplication.
	 *
	 * <p>For example, if matrix <code>m1</code> scales an object by a factor of
	 * four, and matrix <code>m2</code> rotates an object by 1.5707963267949
	 * radians(<code>Math.PI/2</code>), then <code>m1.concat(m2)</code>
	 * transforms <code>m1</code> into a matrix that scales an object by a factor
	 * of four and rotates the object by <code>Math.PI/2</code> radians. </p>
	 *
	 * <p>This method replaces the source matrix with the concatenated matrix. If
	 * you want to concatenate two matrixes without altering either of the two
	 * source matrixes, first copy the source matrix by using the
	 * <code>clone()</code> method, as shown in the Class Examples section.</p>
	 * 
	 * @param m The matrix to be concatenated to the source matrix.]]></haxe_doc>
		</concat>
		<clone public="1" set="method">
			<f a=""><c path="flash.geom.Matrix"/></f>
			<haxe_doc>* Returns a new Matrix object that is a clone of this matrix, with an exact
	 * copy of the contained object.
	 * 
	 * @return A Matrix object.</haxe_doc>
		</clone>
		<ty public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The distance by which to translate each point along the <i>y</i> axis.]]></haxe_doc>
		</ty>
		<tx public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The distance by which to translate each point along the <i>x</i> axis.]]></haxe_doc>
		</tx>
		<d public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The value that affects the positioning of pixels along the <i>y</i> axis
	 * when scaling or rotating an image.]]></haxe_doc>
		</d>
		<c public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The value that affects the positioning of pixels along the <i>x</i> axis
	 * when rotating or skewing an image.]]></haxe_doc>
		</c>
		<b public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The value that affects the positioning of pixels along the <i>y</i> axis
	 * when rotating or skewing an image.]]></haxe_doc>
		</b>
		<a public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The value that affects the positioning of pixels along the <i>x</i> axis
	 * when scaling or rotating an image.]]></haxe_doc>
		</a>
		<new public="1" set="method">
			<f a="?a:?b:?c:?d:?tx:?ty">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new Matrix object with the specified parameters. In matrix
	 * notation, the properties are organized like this:
	 *
	 * <p>If you do not provide any parameters to the <code>new Matrix()</code>
	 * constructor, it creates an <i>identity matrix</i> with the following
	 * values:</p>
	 *
	 * <p>In matrix notation, the identity matrix looks like this:</p>
	 * 
	 * @param a  The value that affects the positioning of pixels along the
	 *           <i>x</i> axis when scaling or rotating an image.
	 * @param b  The value that affects the positioning of pixels along the
	 *           <i>y</i> axis when rotating or skewing an image.
	 * @param c  The value that affects the positioning of pixels along the
	 *           <i>x</i> axis when rotating or skewing an image.
	 * @param d  The value that affects the positioning of pixels along the
	 *           <i>y</i> axis when scaling or rotating an image..
	 * @param tx The distance by which to translate each point along the <i>x</i>
	 *           axis.
	 * @param ty The distance by which to translate each point along the <i>y</i>
	 *           axis.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Matrix class represents a transformation matrix that determines how to
 * map points from one coordinate space to another. You can perform various
 * graphical transformations on a display object by setting the properties of
 * a Matrix object, applying that Matrix object to the <code>matrix</code>
 * property of a Transform object, and then applying that Transform object as
 * the <code>transform</code> property of the display object. These
 * transformation functions include translation(<i>x</i> and <i>y</i>
 * repositioning), rotation, scaling, and skewing.
 *
 * <p>Together these types of transformations are known as <i>affine
 * transformations</i>. Affine transformations preserve the straightness of
 * lines while transforming, so that parallel lines stay parallel.</p>
 *
 * <p>To apply a transformation matrix to a display object, you create a
 * Transform object, set its <code>matrix</code> property to the
 * transformation matrix, and then set the <code>transform</code> property of
 * the display object to the Transform object. Matrix objects are also used as
 * parameters of some methods, such as the following:</p>
 *
 * <ul>
 *   <li>The <code>draw()</code> method of a BitmapData object</li>
 *   <li>The <code>beginBitmapFill()</code> method,
 * <code>beginGradientFill()</code> method, or
 * <code>lineGradientStyle()</code> method of a Graphics object</li>
 * </ul>
 *
 * <p>A transformation matrix object is a 3 x 3 matrix with the following
 * contents:</p>
 *
 * <p>In traditional transformation matrixes, the <code>u</code>,
 * <code>v</code>, and <code>w</code> properties provide extra capabilities.
 * The Matrix class can only operate in two-dimensional space, so it always
 * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
 * and that the property value <code>w</code> is 1.0. The effective values of
 * the matrix are as follows:</p>
 *
 * <p>You can get and set the values of all six of the other properties in a
 * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
 * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
 *
 * <p>The Matrix class supports the four major types of transformations:
 * translation, scaling, rotation, and skewing. You can set three of these
 * transformations by using specialized methods, as described in the following
 * table: </p>
 *
 * <p>Each transformation function alters the current matrix properties so
 * that you can effectively combine multiple transformations. To do this, you
 * call more than one transformation function before applying the matrix to
 * its display object target(by using the <code>transform</code> property of
 * that display object).</p>
 *
 * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
 * before you can call the methods of the Matrix object.</p>]]></haxe_doc>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/Matrix3D.hx" extern="1">
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<invert public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Performs the opposite transformation of the original matrix. You can apply
	 * an inverted matrix to an object to undo the transformation performed when
	 * applying the original matrix.
	 *</haxe_doc>
		</invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Sets each matrix property to a value that causes a null transformation. An
	 * object transformed by applying an identity matrix will be identical to the
	 * original.
	 *
	 * <p>After calling the <code>identity()</code> method, the resulting matrix
	 * has the following properties: <code>a</code>=1, <code>b</code>=0,
	 * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
	 * <code>ty</code>=0.</p>
	 *
	 * <p>In matrix notation, the identity matrix looks like this:</p>
	 *]]></haxe_doc>
		</identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<clone public="1" set="method">
			<f a=""><c path="flash.geom.Matrix3D"/></f>
			<haxe_doc>* Returns a new Matrix object that is a clone of this matrix, with an exact
	 * copy of the contained object.
	 * 
	 * @return A Matrix object.</haxe_doc>
		</clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<new public="1">
			<f a="?v">
				<c path="flash.Vector"><x path="Float"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new Matrix object with the specified parameters. In matrix
	 * notation, the properties are organized like this:
	 *
	 * <p>If you do not provide any parameters to the <code>new Matrix()</code>
	 * constructor, it creates an <i>identity matrix</i> with the following
	 * values:</p>
	 *
	 * <p>In matrix notation, the identity matrix looks like this:</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Matrix class represents a transformation matrix that determines how to
 * map points from one coordinate space to another. You can perform various
 * graphical transformations on a display object by setting the properties of
 * a Matrix object, applying that Matrix object to the <code>matrix</code>
 * property of a Transform object, and then applying that Transform object as
 * the <code>transform</code> property of the display object. These
 * transformation functions include translation(<i>x</i> and <i>y</i>
 * repositioning), rotation, scaling, and skewing.
 *
 * <p>Together these types of transformations are known as <i>affine
 * transformations</i>. Affine transformations preserve the straightness of
 * lines while transforming, so that parallel lines stay parallel.</p>
 *
 * <p>To apply a transformation matrix to a display object, you create a
 * Transform object, set its <code>matrix</code> property to the
 * transformation matrix, and then set the <code>transform</code> property of
 * the display object to the Transform object. Matrix objects are also used as
 * parameters of some methods, such as the following:</p>
 *
 * <ul>
 *   <li>The <code>draw()</code> method of a BitmapData object</li>
 *   <li>The <code>beginBitmapFill()</code> method,
 * <code>beginGradientFill()</code> method, or
 * <code>lineGradientStyle()</code> method of a Graphics object</li>
 * </ul>
 *
 * <p>A transformation matrix object is a 3 x 3 matrix with the following
 * contents:</p>
 *
 * <p>In traditional transformation matrixes, the <code>u</code>,
 * <code>v</code>, and <code>w</code> properties provide extra capabilities.
 * The Matrix class can only operate in two-dimensional space, so it always
 * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
 * and that the property value <code>w</code> is 1.0. The effective values of
 * the matrix are as follows:</p>
 *
 * <p>You can get and set the values of all six of the other properties in a
 * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
 * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
 *
 * <p>The Matrix class supports the four major types of transformations:
 * translation, scaling, rotation, and skewing. You can set three of these
 * transformations by using specialized methods, as described in the following
 * table: </p>
 *
 * <p>Each transformation function alters the current matrix properties so
 * that you can effectively combine multiple transformations. To do this, you
 * call more than one transformation function before applying the matrix to
 * its display object target(by using the <code>transform</code> property of
 * that display object).</p>
 *
 * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
 * before you can call the methods of the Matrix object.</p>]]></haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1">
			<f a="pt1:pt2">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Returns the distance between <code>pt1</code> and <code>pt2</code>.
	 * 
	 * @param pt1 The first point.
	 * @param pt2 The second point.
	 * @return The distance between the first and second points.]]></haxe_doc>
		</distance>
		<interpolate public="1" set="method" static="1">
			<f a="pt1:pt2:f">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
				<x path="Float"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Determines a point between two specified points. The parameter
	 * <code>f</code> determines where the new interpolated point is located
	 * relative to the two end points specified by parameters <code>pt1</code>
	 * and <code>pt2</code>. The closer the value of the parameter <code>f</code>
	 * is to <code>1.0</code>, the closer the interpolated point is to the first
	 * point(parameter <code>pt1</code>). The closer the value of the parameter
	 * <code>f</code> is to 0, the closer the interpolated point is to the second
	 * point(parameter <code>pt2</code>).
	 * 
	 * @param pt1 The first point.
	 * @param pt2 The second point.
	 * @param f   The level of interpolation between the two points. Indicates
	 *            where the new point will be, along the line between
	 *            <code>pt1</code> and <code>pt2</code>. If <code>f</code>=1,
	 *            <code>pt1</code> is returned; if <code>f</code>=0,
	 *            <code>pt2</code> is returned.
	 * @return The new, interpolated point.]]></haxe_doc>
		</interpolate>
		<polar public="1" set="method" static="1">
			<f a="len:angle">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Converts a pair of polar coordinates to a Cartesian point coordinate.
	 * 
	 * @param len   The length coordinate of the polar pair.
	 * @param angle The angle, in radians, of the polar pair.
	 * @return The Cartesian point.</haxe_doc>
		</polar>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Returns a string that contains the values of the <i>x</i> and <i>y</i>
	 * coordinates. The string has the form <code>"(x=<i>x</i>,
	 * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
	 * point at 23,17 would return <code>"(x=23, y=17)"</code>.
	 * 
	 * @return The string representation of the coordinates.]]></haxe_doc>
		</toString>
		<subtract public="1" set="method">
			<f a="v">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Subtracts the coordinates of another point from the coordinates of this
	 * point to create a new point.
	 * 
	 * @param v The point to be subtracted.
	 * @return The new point.</haxe_doc>
		</subtract>
		<offset public="1" set="method">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Offsets the Point object by the specified amount. The value of
	 * <code>dx</code> is added to the original value of <i>x</i> to create the
	 * new <i>x</i> value. The value of <code>dy</code> is added to the original
	 * value of <i>y</i> to create the new <i>y</i> value.
	 * 
	 * @param dx The amount by which to offset the horizontal coordinate,
	 *           <i>x</i>.
	 * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.]]></haxe_doc>
		</offset>
		<normalize public="1" set="method">
			<f a="thickness">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Scales the line segment between(0,0) and the current point to a set
	 * length.
	 * 
	 * @param thickness The scaling value. For example, if the current point is
	 *                 (0,5), and you normalize it to 1, the point returned is
	 *                  at(0,1).
	 * @return The normalized point.</haxe_doc>
		</normalize>
		<equals public="1" set="method">
			<f a="toCompare">
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether two points are equal. Two points are equal if they have
	 * the same <i>x</i> and <i>y</i> values.
	 * 
	 * @param toCompare The point to be compared.
	 * @return A value of <code>true</code> if the object is equal to this Point
	 *         object; <code>false</code> if it is not equal.]]></haxe_doc>
		</equals>
		<clone public="1" set="method">
			<f a=""><c path="flash.geom.Point"/></f>
			<haxe_doc>* Creates a copy of this Point object.
	 * 
	 * @return The new Point object.</haxe_doc>
		</clone>
		<add public="1" set="method">
			<f a="v">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc>* Adds the coordinates of another point to the coordinates of this point to
	 * create a new point.
	 * 
	 * @param v The point to be added.
	 * @return The new point.</haxe_doc>
		</add>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The vertical coordinate of the point. The default value is 0.</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The horizontal coordinate of the point. The default value is 0.</haxe_doc>
		</x>
		<length public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The length of the line segment from(0,0) to this point.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new point. If you pass no parameters to this method, a point is
	 * created at(0,0).
	 * 
	 * @param x The horizontal coordinate.
	 * @param y The vertical coordinate.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Point object represents a location in a two-dimensional coordinate
 * system, where <i>x</i> represents the horizontal axis and <i>y</i>
 * represents the vertical axis.
 *
 * <p>The following code creates a point at(0,0):</p>
 *
 * <p>Methods and properties of the following classes use Point objects:</p>
 *
 * <ul>
 *   <li>BitmapData</li>
 *   <li>DisplayObject</li>
 *   <li>DisplayObjectContainer</li>
 *   <li>DisplacementMapFilter</li>
 *   <li>NativeWindow</li>
 *   <li>Matrix</li>
 *   <li>Rectangle</li>
 * </ul>
 *
 * <p>You can use the <code>new Point()</code> constructor to create a Point
 * object.</p>]]></haxe_doc>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method">
			<f a="toUnion">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Adds two rectangles together to create a new Rectangle object, by filling
	 * in the horizontal and vertical space between the two rectangles.
	 *
	 * <p><b>Note:</b> The <code>union()</code> method ignores rectangles with
	 * <code>0</code> as the height or width value, such as: <code>var
	 * rect2:Rectangle = new Rectangle(300,300,50,0);</code></p>
	 * 
	 * @param toUnion A Rectangle object to add to this Rectangle object.
	 * @return A new Rectangle object that is the union of the two rectangles.]]></haxe_doc>
		</union>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Builds and returns a string that lists the horizontal and vertical
	 * positions and the width and height of the Rectangle object.
	 * 
	 * @return A string listing the value of each of the following properties of
	 *         the Rectangle object: <code>x</code>, <code>y</code>,
	 *         <code>width</code>, and <code>height</code>.]]></haxe_doc>
		</toString>
		<setEmpty public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Sets all of the Rectangle object's properties to 0. A Rectangle object is
	 * empty if its width or height is less than or equal to 0.
	 *
	 * <p> This method sets the values of the <code>x</code>, <code>y</code>,
	 * <code>width</code>, and <code>height</code> properties to 0.</p>
	 *]]></haxe_doc>
		</setEmpty>
		<offsetPoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjusts the location of the Rectangle object using a Point object as a
	 * parameter. This method is similar to the <code>Rectangle.offset()</code>
	 * method, except that it takes a Point object as a parameter.
	 * 
	 * @param point A Point object to use to offset this Rectangle object.]]></haxe_doc>
		</offsetPoint>
		<offset public="1" set="method">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjusts the location of the Rectangle object, as determined by its
	 * top-left corner, by the specified amounts.
	 * 
	 * @param dx Moves the <i>x</i> value of the Rectangle object by this amount.
	 * @param dy Moves the <i>y</i> value of the Rectangle object by this amount.]]></haxe_doc>
		</offset>
		<isEmpty public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Determines whether or not this Rectangle object is empty.
	 * 
	 * @return A value of <code>true</code> if the Rectangle object's width or
	 *         height is less than or equal to 0; otherwise <code>false</code>.]]></haxe_doc>
		</isEmpty>
		<intersects public="1" set="method">
			<f a="toIntersect">
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the object specified in the <code>toIntersect</code>
	 * parameter intersects with this Rectangle object. This method checks the
	 * <code>x</code>, <code>y</code>, <code>width</code>, and
	 * <code>height</code> properties of the specified Rectangle object to see if
	 * it intersects with this Rectangle object.
	 * 
	 * @param toIntersect The Rectangle object to compare against this Rectangle
	 *                    object.
	 * @return A value of <code>true</code> if the specified object intersects
	 *         with this Rectangle object; otherwise <code>false</code>.]]></haxe_doc>
		</intersects>
		<intersection public="1" set="method">
			<f a="toIntersect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* If the Rectangle object specified in the <code>toIntersect</code>
	 * parameter intersects with this Rectangle object, returns the area of
	 * intersection as a Rectangle object. If the rectangles do not intersect,
	 * this method returns an empty Rectangle object with its properties set to
	 * 0.
	 * 
	 * @param toIntersect The Rectangle object to compare against to see if it
	 *                    intersects with this Rectangle object.
	 * @return A Rectangle object that equals the area of intersection. If the
	 *         rectangles do not intersect, this method returns an empty
	 *         Rectangle object; that is, a rectangle with its <code>x</code>,
	 *         <code>y</code>, <code>width</code>, and <code>height</code>
	 *         properties set to 0.]]></haxe_doc>
		</intersection>
		<inflatePoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Increases the size of the Rectangle object. This method is similar to the
	 * <code>Rectangle.inflate()</code> method except it takes a Point object as
	 * a parameter.
	 *
	 * <p>The following two code examples give the same result:</p>
	 * 
	 * @param point The <code>x</code> property of this Point object is used to
	 *              increase the horizontal dimension of the Rectangle object.
	 *              The <code>y</code> property is used to increase the vertical
	 *              dimension of the Rectangle object.]]></haxe_doc>
		</inflatePoint>
		<inflate public="1" set="method">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Increases the size of the Rectangle object by the specified amounts, in
	 * pixels. The center point of the Rectangle object stays the same, and its
	 * size increases to the left and right by the <code>dx</code> value, and to
	 * the top and the bottom by the <code>dy</code> value.
	 * 
	 * @param dx The value to be added to the left and the right of the Rectangle
	 *           object. The following equation is used to calculate the new
	 *           width and position of the rectangle:
	 * @param dy The value to be added to the top and the bottom of the
	 *           Rectangle. The following equation is used to calculate the new
	 *           height and position of the rectangle:]]></haxe_doc>
		</inflate>
		<equals public="1" set="method">
			<f a="toCompare">
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the object specified in the <code>toCompare</code>
	 * parameter is equal to this Rectangle object. This method compares the
	 * <code>x</code>, <code>y</code>, <code>width</code>, and
	 * <code>height</code> properties of an object against the same properties of
	 * this Rectangle object.
	 * 
	 * @param toCompare The rectangle to compare to this Rectangle object.
	 * @return A value of <code>true</code> if the object has exactly the same
	 *         values for the <code>x</code>, <code>y</code>, <code>width</code>,
	 *         and <code>height</code> properties as this Rectangle object;
	 *         otherwise <code>false</code>.]]></haxe_doc>
		</equals>
		<containsRect public="1" set="method">
			<f a="rect">
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the Rectangle object specified by the <code>rect</code>
	 * parameter is contained within this Rectangle object. A Rectangle object is
	 * said to contain another if the second Rectangle object falls entirely
	 * within the boundaries of the first.
	 * 
	 * @param rect The Rectangle object being checked.
	 * @return A value of <code>true</code> if the Rectangle object that you
	 *         specify is contained by this Rectangle object; otherwise
	 *         <code>false</code>.]]></haxe_doc>
		</containsRect>
		<containsPoint public="1" set="method">
			<f a="point">
				<c path="flash.geom.Point"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the specified point is contained within the rectangular
	 * region defined by this Rectangle object. This method is similar to the
	 * <code>Rectangle.contains()</code> method, except that it takes a Point
	 * object as a parameter.
	 * 
	 * @param point The point, as represented by its <i>x</i> and <i>y</i>
	 *              coordinates.
	 * @return A value of <code>true</code> if the Rectangle object contains the
	 *         specified point; otherwise <code>false</code>.]]></haxe_doc>
		</containsPoint>
		<contains public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Determines whether the specified point is contained within the rectangular
	 * region defined by this Rectangle object.
	 * 
	 * @param x The <i>x</i> coordinate(horizontal position) of the point.
	 * @param y The <i>y</i> coordinate(vertical position) of the point.
	 * @return A value of <code>true</code> if the Rectangle object contains the
	 *         specified point; otherwise <code>false</code>.]]></haxe_doc>
		</contains>
		<clone public="1" set="method">
			<f a=""><c path="flash.geom.Rectangle"/></f>
			<haxe_doc><![CDATA[* Returns a new Rectangle object with the same values for the
	 * <code>x</code>, <code>y</code>, <code>width</code>, and
	 * <code>height</code> properties as the original Rectangle object.
	 * 
	 * @return A new Rectangle object with the same values for the
	 *         <code>x</code>, <code>y</code>, <code>width</code>, and
	 *         <code>height</code> properties as the original Rectangle object.]]></haxe_doc>
		</clone>
		<y public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
	 * the value of the <code>y</code> property of a Rectangle object has no
	 * effect on the <code>x</code>, <code>width</code>, and <code>height</code>
	 * properties.
	 *
	 * <p>The value of the <code>y</code> property is equal to the value of the
	 * <code>top</code> property.</p>]]></haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
	 * the value of the <code>x</code> property of a Rectangle object has no
	 * effect on the <code>y</code>, <code>width</code>, and <code>height</code>
	 * properties.
	 *
	 * <p>The value of the <code>x</code> property is equal to the value of the
	 * <code>left</code> property.</p>]]></haxe_doc>
		</x>
		<width public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The width of the rectangle, in pixels. Changing the <code>width</code>
	 * value of a Rectangle object has no effect on the <code>x</code>,
	 * <code>y</code>, and <code>height</code> properties.]]></haxe_doc>
		</width>
		<topLeft public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc><![CDATA[* The location of the Rectangle object's top-left corner, determined by the
	 * <i>x</i> and <i>y</i> coordinates of the point.]]></haxe_doc>
		</topLeft>
		<top public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
	 * the <code>top</code> property of a Rectangle object has no effect on the
	 * <code>x</code> and <code>width</code> properties. However it does affect
	 * the <code>height</code> property, whereas changing the <code>y</code>
	 * value does <i>not</i> affect the <code>height</code> property.
	 *
	 * <p>The value of the <code>top</code> property is equal to the value of the
	 * <code>y</code> property.</p>]]></haxe_doc>
		</top>
		<size public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc><![CDATA[* The size of the Rectangle object, expressed as a Point object with the
	 * values of the <code>width</code> and <code>height</code> properties.]]></haxe_doc>
		</size>
		<right public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The sum of the <code>x</code> and <code>width</code> properties.]]></haxe_doc>
		</right>
		<left public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
	 * the <code>left</code> property of a Rectangle object has no effect on the
	 * <code>y</code> and <code>height</code> properties. However it does affect
	 * the <code>width</code> property, whereas changing the <code>x</code> value
	 * does <i>not</i> affect the <code>width</code> property.
	 *
	 * <p>The value of the <code>left</code> property is equal to the value of
	 * the <code>x</code> property.</p>]]></haxe_doc>
		</left>
		<height public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The height of the rectangle, in pixels. Changing the <code>height</code>
	 * value of a Rectangle object has no effect on the <code>x</code>,
	 * <code>y</code>, and <code>width</code> properties.]]></haxe_doc>
		</height>
		<bottomRight public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc><![CDATA[* The location of the Rectangle object's bottom-right corner, determined by
	 * the values of the <code>right</code> and <code>bottom</code> properties.]]></haxe_doc>
		</bottomRight>
		<bottom public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The sum of the <code>y</code> and <code>height</code> properties.]]></haxe_doc>
		</bottom>
		<new public="1" set="method">
			<f a="?x:?y:?width:?height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new Rectangle object with the top-left corner specified by the
	 * <code>x</code> and <code>y</code> parameters and with the specified
	 * <code>width</code> and <code>height</code> parameters. If you call this
	 * function without parameters, a rectangle with <code>x</code>,
	 * <code>y</code>, <code>width</code>, and <code>height</code> properties set
	 * to 0 is created.
	 * 
	 * @param x      The <i>x</i> coordinate of the top-left corner of the
	 *               rectangle.
	 * @param y      The <i>y</i> coordinate of the top-left corner of the
	 *               rectangle.
	 * @param width  The width of the rectangle, in pixels.
	 * @param height The height of the rectangle, in pixels.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A Rectangle object is an area defined by its position, as indicated by its
 * top-left corner point(<i>x</i>, <i>y</i>) and by its width and its height.
 *
 *
 * <p>The <code>x</code>, <code>y</code>, <code>width</code>, and
 * <code>height</code> properties of the Rectangle class are independent of
 * each other; changing the value of one property has no effect on the others.
 * However, the <code>right</code> and <code>bottom</code> properties are
 * integrally related to those four properties. For example, if you change the
 * value of the <code>right</code> property, the value of the
 * <code>width</code> property changes; if you change the <code>bottom</code>
 * property, the value of the <code>height</code> property changes. </p>
 *
 * <p>The following methods and properties use Rectangle objects:</p>
 *
 * <ul>
 *   <li>The <code>applyFilter()</code>, <code>colorTransform()</code>,
 * <code>copyChannel()</code>, <code>copyPixels()</code>, <code>draw()</code>,
 * <code>fillRect()</code>, <code>generateFilterRect()</code>,
 * <code>getColorBoundsRect()</code>, <code>getPixels()</code>,
 * <code>merge()</code>, <code>paletteMap()</code>,
 * <code>pixelDisolve()</code>, <code>setPixels()</code>, and
 * <code>threshold()</code> methods, and the <code>rect</code> property of the
 * BitmapData class</li>
 *   <li>The <code>getBounds()</code> and <code>getRect()</code> methods, and
 * the <code>scrollRect</code> and <code>scale9Grid</code> properties of the
 * DisplayObject class</li>
 *   <li>The <code>getCharBoundaries()</code> method of the TextField
 * class</li>
 *   <li>The <code>pixelBounds</code> property of the Transform class</li>
 *   <li>The <code>bounds</code> parameter for the <code>startDrag()</code>
 * method of the Sprite class</li>
 *   <li>The <code>printArea</code> parameter of the <code>addPage()</code>
 * method of the PrintJob class</li>
 * </ul>
 *
 * <p>You can use the <code>new Rectangle()</code> constructor to create a
 * Rectangle object.</p>
 *
 * <p><b>Note:</b> The Rectangle class does not define a rectangular Shape
 * display object. To draw a rectangular Shape object onscreen, use the
 * <code>drawRect()</code> method of the Graphics class.</p>]]></haxe_doc>
	</class>
	<class path="flash.geom.Transform" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/Transform.hx" extern="1">
		<pixelBounds public="1" set="null">
			<c path="flash.geom.Rectangle"/>
			<haxe_doc><![CDATA[* Provides access to the PerspectiveProjection object of a three-dimensional
	 * display object. The PerspectiveProjection object can be used to modify the
	 * perspective transformation of the stage or to assign a perspective
	 * transformation to all the three-dimensional children of a display object.
	 *
	 * <p>Based on the field of view and aspect ratio(dimensions) of the stage,
	 * a default PerspectiveProjection object is assigned to the root object.</p>]]></haxe_doc>
		</pixelBounds>
		<matrix public="1">
			<c path="flash.geom.Matrix"/>
			<haxe_doc><![CDATA[* A Matrix object containing values that alter the scaling, rotation, and
	 * translation of the display object.
	 *
	 * <p>If the <code>matrix</code> property is set to a value(not
	 * <code>null</code>), the <code>matrix3D</code> property is
	 * <code>null</code>. And if the <code>matrix3D</code> property is set to a
	 * value(not <code>null</code>), the <code>matrix</code> property is
	 * <code>null</code>.</p>
	 * 
	 * @throws TypeError The matrix is null when being set]]></haxe_doc>
		</matrix>
		<concatenatedMatrix public="1" set="null">
			<c path="flash.geom.Matrix"/>
			<haxe_doc>* A Matrix object representing the combined transformation matrixes of the
	 * display object and all of its parent objects, back to the root level. If
	 * different transformation matrixes have been applied at different levels,
	 * all of those matrixes are concatenated into one matrix for this property.
	 * Also, for resizeable SWF content running in the browser, this property
	 * factors in the difference between stage coordinates and window coordinates
	 * due to window resizing. Thus, the property converts local coordinates to
	 * window coordinates, which may not be the same coordinate space as that of
	 * the Stage.</haxe_doc>
		</concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null">
			<c path="flash.geom.ColorTransform"/>
			<haxe_doc>* A ColorTransform object representing the combined color transformations
	 * applied to the display object and all of its parent objects, back to the
	 * root level. If different color transformations have been applied at
	 * different levels, all of those transformations are concatenated into one
	 * ColorTransform object for this property.</haxe_doc>
		</concatenatedColorTransform>
		<colorTransform public="1">
			<c path="flash.geom.ColorTransform"/>
			<haxe_doc>* A ColorTransform object containing values that universally adjust the
	 * colors in the display object.
	 * 
	 * @throws TypeError The colorTransform is null when being set</haxe_doc>
		</colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* The Transform class provides access to color adjustment properties and two-
 * or three-dimensional transformation objects that can be applied to a
 * display object. During the transformation, the color or the orientation and
 * position of a display object is adjusted(offset) from the current values
 * or coordinates to new values or coordinates. The Transform class also
 * collects data about color and two-dimensional matrix transformations that
 * are applied to a display object and all of its parent objects. You can
 * access these combined transformations through the
 * <code>concatenatedColorTransform</code> and <code>concatenatedMatrix</code>
 * properties.
 *
 * <p>To apply color transformations: create a ColorTransform object, set the
 * color adjustments using the object's methods and properties, and then
 * assign the <code>colorTransformation</code> property of the
 * <code>transform</code> property of the display object to the new
 * ColorTransformation object.</p>
 *
 * <p>To apply two-dimensional transformations: create a Matrix object, set
 * the matrix's two-dimensional transformation, and then assign the
 * <code>transform.matrix</code> property of the display object to the new
 * Matrix object.</p>
 *
 * <p>To apply three-dimensional transformations: start with a
 * three-dimensional display object. A three-dimensional display object has a
 * <code>z</code> property value other than zero. You do not need to create
 * the Matrix3D object. For all three-dimensional objects, a Matrix3D object
 * is created automatically when you assign a <code>z</code> value to a
 * display object. You can access the display object's Matrix3D object through
 * the display object's <code>transform</code> property. Using the methods of
 * the Matrix3D class, you can add to or modify the existing transformation
 * settings. Also, you can create a custom Matrix3D object, set the custom
 * Matrix3D object's transformation elements, and then assign the new Matrix3D
 * object to the display object using the <code>transform.matrix</code>
 * property.</p>
 *
 * <p>To modify a perspective projection of the stage or root object: use the
 * <code>transform.matrix</code> property of the root display object to gain
 * access to the PerspectiveProjection object. Or, apply different perspective
 * projection properties to a display object by setting the perspective
 * projection properties of the display object's parent. The child display
 * object inherits the new properties. Specifically, create a
 * PerspectiveProjection object and set its properties, then assign the
 * PerspectiveProjection object to the <code>perspectiveProjection</code>
 * property of the parent display object's <code>transform</code> property.
 * The specified projection transformation then applies to all the display
 * object's three-dimensional children.</p>
 *
 * <p>Since both PerspectiveProjection and Matrix3D objects perform
 * perspective transformations, do not assign both to a display object at the
 * same time. Use the PerspectiveProjection object for focal length and
 * projection center changes. For more control over the perspective
 * transformation, create a perspective projection Matrix3D object.</p>]]></haxe_doc>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/geom/Vector3D.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<w public="1"><x path="Float"/></w>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.ID3Info" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/media/ID3Info.hx" extern="1">
		<year public="1"><c path="String"/></year>
		<track public="1"><c path="String"/></track>
		<songName public="1"><c path="String"/></songName>
		<genre public="1"><c path="String"/></genre>
		<comment public="1"><c path="String"/></comment>
		<artist public="1"><c path="String"/></artist>
		<album public="1"><c path="String"/></album>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.media.Sound" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/media/Sound.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<play public="1" set="method">
			<f a="?startTime:?loops:?sndTransform">
				<x path="Float"/>
				<x path="Int"/>
				<c path="flash.media.SoundTransform"/>
				<c path="flash.media.SoundChannel"/>
			</f>
			<haxe_doc><![CDATA[* Generates a new SoundChannel object to play back the sound. This method
	 * returns a SoundChannel object, which you access to stop the sound and to
	 * monitor volume.(To control the volume, panning, and balance, access the
	 * SoundTransform object assigned to the sound channel.)
	 * 
	 * @param startTime    The initial position in milliseconds at which playback
	 *                     should start.
	 * @param loops        Defines the number of times a sound loops back to the
	 *                     <code>startTime</code> value before the sound channel
	 *                     stops playback.
	 * @param sndTransform The initial SoundTransform object assigned to the
	 *                     sound channel.
	 * @return A SoundChannel object, which you use to control the sound. This
	 *         method returns <code>null</code> if you have no sound card or if
	 *         you run out of available sound channels. The maximum number of
	 *         sound channels available at once is 32.]]></haxe_doc>
		</play>
		<load public="1" set="method">
			<f a="stream:?context">
				<c path="flash.net.URLRequest"/>
				<c path="flash.media.SoundLoaderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Initiates loading of an external MP3 file from the specified URL. If you
	 * provide a valid URLRequest object to the Sound constructor, the
	 * constructor calls <code>Sound.load()</code> for you. You only need to call
	 * <code>Sound.load()</code> yourself if you don't pass a valid URLRequest
	 * object to the Sound constructor or you pass a <code>null</code> value.
	 *
	 * <p>Once <code>load()</code> is called on a Sound object, you can't later
	 * load a different sound file into that Sound object. To load a different
	 * sound file, create a new Sound object.</p>
	 *
	 * <p>When using this method, consider the following security model:</p>
	 *
	 * <ul>
	 *   <li>Calling <code>Sound.load()</code> is not allowed if the calling file
	 * is in the local-with-file-system sandbox and the sound is in a network
	 * sandbox.</li>
	 *   <li>Access from the local-trusted or local-with-networking sandbox
	 * requires permission from a website through a URL policy file.</li>
	 *   <li>You cannot connect to commonly reserved ports. For a complete list
	 * of blocked ports, see "Restricting Networking APIs" in the <i>ActionScript
	 * 3.0 Developer's Guide</i>.</li>
	 *   <li>You can prevent a SWF file from using this method by setting the
	 * <code>allowNetworking</code> parameter of the <code>object</code> and
	 * <code>embed</code> tags in the HTML page that contains the SWF
	 * content.</li>
	 * </ul>
	 *
	 * <p> In Flash Player 10 and later, if you use a multipart Content-Type(for
	 * example "multipart/form-data") that contains an upload(indicated by a
	 * "filename" parameter in a "content-disposition" header within the POST
	 * body), the POST operation is subject to the security rules applied to
	 * uploads:</p>
	 *
	 * <ul>
	 *   <li>The POST operation must be performed in response to a user-initiated
	 * action, such as a mouse click or key press.</li>
	 *   <li>If the POST operation is cross-domain(the POST target is not on the
	 * same server as the SWF file that is sending the POST request), the target
	 * server must provide a URL policy file that permits cross-domain
	 * access.</li>
	 * </ul>
	 *
	 * <p>Also, for any multipart Content-Type, the syntax must be valid
	 * (according to the RFC2046 standards). If the syntax appears to be invalid,
	 * the POST operation is subject to the security rules applied to
	 * uploads.</p>
	 *
	 * <p>In Adobe AIR, content in the <code>application</code> security sandbox
	 * (content installed with the AIR application) are not restricted by these
	 * security limitations.</p>
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @param stream  A URL that points to an external MP3 file.
	 * @param context An optional SoundLoader context object, which can define
	 *                the buffer time(the minimum number of milliseconds of MP3
	 *                data to hold in the Sound object's buffer) and can specify
	 *                whether the application should check for a cross-domain
	 *                policy file prior to loading the sound.
	 * @throws IOError       A network error caused the load to fail.
	 * @throws IOError       The <code>digest</code> property of the
	 *                       <code>stream</code> object is not <code>null</code>.
	 *                       You should only set the <code>digest</code> property
	 *                       of a URLRequest object when calling the
	 *                       <code>URLLoader.load()</code> method when loading a
	 *                       SWZ file(an Adobe platform component).
	 * @throws SecurityError Local untrusted files may not communicate with the
	 *                       Internet. You can work around this by reclassifying
	 *                       this file as local-with-networking or trusted.
	 * @throws SecurityError You cannot connect to commonly reserved ports. For a
	 *                       complete list of blocked ports, see "Restricting
	 *                       Networking APIs" in the <i>ActionScript 3.0
	 *                       Developer's Guide</i>.]]></haxe_doc>
		</load>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Closes the stream, causing any download of data to cease. No data may be
	 * read from the stream after the <code>close()</code> method is called.
	 * 
	 * @throws IOError The stream could not be closed, or the stream was not
	 *                 open.]]></haxe_doc>
		</close>
		<url public="1" set="null">
			<c path="String"/>
			<haxe_doc><![CDATA[* The URL from which this sound was loaded. This property is applicable only
	 * to Sound objects that were loaded using the <code>Sound.load()</code>
	 * method. For Sound objects that are associated with a sound asset from a
	 * SWF file's library, the value of the <code>url</code> property is
	 * <code>null</code>.
	 *
	 * <p>When you first call <code>Sound.load()</code>, the <code>url</code>
	 * property initially has a value of <code>null</code>, because the final URL
	 * is not yet known. The <code>url</code> property will have a non-null value
	 * as soon as an <code>open</code> event is dispatched from the Sound
	 * object.</p>
	 *
	 * <p>The <code>url</code> property contains the final, absolute URL from
	 * which a sound was loaded. The value of <code>url</code> is usually the
	 * same as the value passed to the <code>stream</code> parameter of
	 * <code>Sound.load()</code>. However, if you passed a relative URL to
	 * <code>Sound.load()</code> the value of the <code>url</code> property
	 * represents the absolute URL. Additionally, if the original URL request is
	 * redirected by an HTTP server, the value of the <code>url</code> property
	 * reflects the final URL from which the sound file was actually downloaded.
	 * This reporting of an absolute, final URL is equivalent to the behavior of
	 * <code>LoaderInfo.url</code>.</p>
	 *
	 * <p>In some cases, the value of the <code>url</code> property is truncated;
	 * see the <code>isURLInaccessible</code> property for details.</p>]]></haxe_doc>
		</url>
		<length public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The length of the current sound in milliseconds.</haxe_doc>
		</length>
		<isBuffering public="1" set="null">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Returns the buffering state of external MP3 files. If the value is
	 * <code>true</code>, any playback is currently suspended while the object
	 * waits for more data.]]></haxe_doc>
		</isBuffering>
		<id3 public="1" set="null">
			<c path="flash.media.ID3Info"/>
			<haxe_doc><![CDATA[* Provides access to the metadata that is part of an MP3 file.
	 *
	 * <p>MP3 sound files can contain ID3 tags, which provide metadata about the
	 * file. If an MP3 sound that you load using the <code>Sound.load()</code>
	 * method contains ID3 tags, you can query these properties. Only ID3 tags
	 * that use the UTF-8 character set are supported.</p>
	 *
	 * <p>Flash Player 9 and later and AIR support ID3 2.0 tags, specifically 2.3
	 * and 2.4. The following tables list the standard ID3 2.0 tags and the type
	 * of content the tags represent. The <code>Sound.id3</code> property
	 * provides access to these tags through the format
	 * <code>my_sound.id3.COMM</code>, <code>my_sound.id3.TIME</code>, and so on.
	 * The first table describes tags that can be accessed either through the ID3
	 * 2.0 property name or the ActionScript property name. The second table
	 * describes ID3 tags that are supported but do not have predefined
	 * properties in ActionScript. </p>
	 *
	 * <p>When using this property, consider the Flash Player security model:</p>
	 *
	 * <ul>
	 *   <li>The <code>id3</code> property of a Sound object is always permitted
	 * for SWF files that are in the same security sandbox as the sound file. For
	 * files in other sandboxes, there are security checks.</li>
	 *   <li>When you load the sound, using the <code>load()</code> method of the
	 * Sound class, you can specify a <code>context</code> parameter, which is a
	 * SoundLoaderContext object. If you set the <code>checkPolicyFile</code>
	 * property of the SoundLoaderContext object to <code>true</code>, Flash
	 * Player checks for a URL policy file on the server from which the sound is
	 * loaded. If a policy file exists and permits access from the domain of the
	 * loading SWF file, then the file is allowed to access the <code>id3</code>
	 * property of the Sound object; otherwise it is not.</li>
	 * </ul>
	 *
	 * <p>However, in Adobe AIR, content in the <code>application</code> security
	 * sandbox(content installed with the AIR application) are not restricted by
	 * these security limitations.</p>
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>]]></haxe_doc>
		</id3>
		<bytesTotal public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns the total number of bytes in this sound object.</haxe_doc>
		</bytesTotal>
		<bytesLoaded public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns the currently available number of bytes in this sound object. This
	 * property is usually useful only for externally loaded files.</haxe_doc>
		</bytesLoaded>
		<new public="1" set="method">
			<f a="?stream:?context">
				<c path="flash.net.URLRequest"/>
				<c path="flash.media.SoundLoaderContext"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new Sound object. If you pass a valid URLRequest object to the
	 * Sound constructor, the constructor automatically calls the
	 * <code>load()</code> function for the Sound object. If you do not pass a
	 * valid URLRequest object to the Sound constructor, you must call the
	 * <code>load()</code> function for the Sound object yourself, or the stream
	 * will not load.
	 *
	 * <p>Once <code>load()</code> is called on a Sound object, you can't later
	 * load a different sound file into that Sound object. To load a different
	 * sound file, create a new Sound object.</p>
	 * In Flash Player 10 and later and AIR 1.5 and later, instead of using
	 * <code>load()</code>, you can use the <code>sampleData</code> event handler
	 * to load sound dynamically into the Sound object.
	 * 
	 * @param stream  The URL that points to an external MP3 file.
	 * @param context An optional SoundLoader context object, which can define
	 *                the buffer time(the minimum number of milliseconds of MP3
	 *                data to hold in the Sound object's buffer) and can specify
	 *                whether the application should check for a cross-domain
	 *                policy file prior to loading the sound.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The Sound class lets you work with sound in an application. The Sound class
 * lets you create a Sound object, load and play an external MP3 file into
 * that object, close the sound stream, and access data about the sound, such
 * as information about the number of bytes in the stream and ID3 metadata.
 * More detailed control of the sound is performed through the sound source
 *  -  the SoundChannel or Microphone object for the sound  -  and through the
 * properties in the SoundTransform class that control the output of the sound
 * to the computer's speakers.
 *
 * <p>In Flash Player 10 and later and AIR 1.5 and later, you can also use
 * this class to work with sound that is generated dynamically. In this case,
 * the Sound object uses the function you assign to a <code>sampleData</code>
 * event handler to poll for sound data. The sound is played as it is
 * retrieved from a ByteArray object that you populate with sound data. You
 * can use <code>Sound.extract()</code> to extract sound data from a Sound
 * object, after which you can manipulate it before writing it back to the
 * stream for playback.</p>
 *
 * <p>To control sounds that are embedded in a SWF file, use the properties in
 * the SoundMixer class.</p>
 *
 * <p><b>Note</b>: The ActionScript 3.0 Sound API differs from ActionScript
 * 2.0. In ActionScript 3.0, you cannot take sound objects and arrange them in
 * a hierarchy to control their properties.</p>
 *
 * <p>When you use this class, consider the following security model: </p>
 *
 * <ul>
 *   <li>Loading and playing a sound is not allowed if the calling file is in
 * a network sandbox and the sound file to be loaded is local.</li>
 *   <li>By default, loading and playing a sound is not allowed if the calling
 * file is local and tries to load and play a remote sound. A user must grant
 * explicit permission to allow this type of access.</li>
 *   <li>Certain operations dealing with sound are restricted. The data in a
 * loaded sound cannot be accessed by a file in a different domain unless you
 * implement a cross-domain policy file. Sound-related APIs that fall under
 * this restriction are <code>Sound.id3</code>,
 * <code>SoundMixer.computeSpectrum()</code>,
 * <code>SoundMixer.bufferTime</code>, and the <code>SoundTransform</code>
 * class.</li>
 * </ul>
 *
 * <p>However, in Adobe AIR, content in the <code>application</code> security
 * sandbox(content installed with the AIR application) are not restricted by
 * these security limitations.</p>
 *
 * <p>For more information related to security, see the Flash Player Developer
 * Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
 * scope="external">Security</a>.</p>
 * 
 * @event complete   Dispatched when data has loaded successfully.
 * @event id3        Dispatched by a Sound object when ID3 data is available
 *                   for an MP3 sound.
 * @event ioError    Dispatched when an input/output error occurs that causes
 *                   a load operation to fail.
 * @event open       Dispatched when a load operation starts.
 * @event progress   Dispatched when data is received as a load operation
 *                   progresses.
 * @event sampleData Dispatched when the runtime requests new audio data.]]></haxe_doc>
	</class>
	<class path="flash.media.SoundChannel" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/media/SoundChannel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<stop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the sound playing in the channel.
	 *</haxe_doc>
		</stop>
		<soundTransform public="1">
			<c path="flash.media.SoundTransform"/>
			<haxe_doc>* The SoundTransform object assigned to the sound channel. A SoundTransform
	 * object includes properties for setting volume, panning, left speaker
	 * assignment, and right speaker assignment.</haxe_doc>
		</soundTransform>
		<rightPeak public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The current amplitude(volume) of the right channel, from 0(silent) to 1
	 * (full amplitude).</haxe_doc>
		</rightPeak>
		<position public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* When the sound is playing, the <code>position</code> property indicates in
	 * milliseconds the current point that is being played in the sound file.
	 * When the sound is stopped or paused, the <code>position</code> property
	 * indicates the last point that was played in the sound file.
	 *
	 * <p>A common use case is to save the value of the <code>position</code>
	 * property when the sound is stopped. You can resume the sound later by
	 * restarting it from that saved position. </p>
	 *
	 * <p>If the sound is looped, <code>position</code> is reset to 0 at the
	 * beginning of each loop.</p>]]></haxe_doc>
		</position>
		<leftPeak public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The current amplitude(volume) of the left channel, from 0(silent) to 1
	 * (full amplitude).</haxe_doc>
		</leftPeak>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The SoundChannel class controls a sound in an application. Every sound is
 * assigned to a sound channel, and the application can have multiple sound
 * channels that are mixed together. The SoundChannel class contains a
 * <code>stop()</code> method, properties for monitoring the amplitude
 * (volume) of the channel, and a property for assigning a SoundTransform
 * object to the channel.
 * 
 * @event soundComplete Dispatched when a sound has finished playing.]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.SoundLoaderContext" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/media/SoundLoaderContext.hx" extern="1">
		<checkPolicyFile public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether the application should try to download a URL policy file
	 * from the loaded sound's server before beginning to load the sound. This
	 * property applies to sound that is loaded from outside the calling file's
	 * own domain using the <code>Sound.load()</code> method.
	 *
	 * <p>Set this property to <code>true</code> when you load a sound from
	 * outside the calling file's own domain and code in the calling file needs
	 * low-level access to the sound's data. Examples of low-level access to a
	 * sound's data include referencing the <code>Sound.id3</code> property to
	 * get an ID3Info object or calling the
	 * <code>SoundMixer.computeSpectrum()</code> method to get sound samples from
	 * the loaded sound. If you try to access sound data without setting the
	 * <code>checkPolicyFile</code> property to <code>true</code> at loading
	 * time, you may get a SecurityError exception because the required policy
	 * file has not been downloaded.</p>
	 *
	 * <p>If you don't need low-level access to the sound data that you are
	 * loading, avoid setting <code>checkPolicyFile</code> to <code>true</code>.
	 * Checking for a policy file consumes network bandwidth and might delay the
	 * start of your download, so it should only be done when necessary.</p>
	 *
	 * <p>When you call <code>Sound.load()</code> with
	 * <code>SoundLoaderContext.checkPolicyFile</code> set to <code>true</code>,
	 * Flash Player or AIR must either successfully download a relevant URL
	 * policy file or determine that no such policy file exists before it begins
	 * downloading the specified sound. Flash Player or AIR performs the
	 * following actions, in this order, to verify the existence of a policy
	 * file:</p>
	 *
	 * <ul>
	 *   <li>Flash Player or AIR considers policy files that have already been
	 * downloaded.</li>
	 *   <li>Flash Player or AIR tries to download any pending policy files
	 * specified in calls to <code>Security.loadPolicyFile()</code>.</li>
	 *   <li>Flash Player or AIR tries to download a policy file from the default
	 * location that corresponds to the sound's URL, which is
	 * <code>/crossdomain.xml</code> on the same server as
	 * <code>URLRequest.url</code>.(The sound's URL is specified in the
	 * <code>url</code> property of the URLRequest object passed to
	 * <code>Sound.load()</code> or the Sound() constructor function.)</li>
	 * </ul>
	 *
	 * <p>In all cases, Flash Player or AIR requires that an appropriate policy
	 * file exist on the sound's server, that it provide access to the sound file
	 * at <code>URLRequest.url</code> by virtue of the policy file's location,
	 * and that it allow the domain of the calling file to access the sound,
	 * through one or more <code><allow-access-from></code> tags. </p>
	 *
	 * <p>If you set <code>checkPolicyFile</code> to <code>true</code>, Flash
	 * Player or AIR waits until the policy file is verified before loading the
	 * sound. You should wait to perform any low-level operations on the sound
	 * data, such as calling <code>Sound.id3</code> or
	 * <code>SoundMixer.computeSpectrum()</code>, until <code>progress</code> and
	 * <code>complete</code> events are dispatched from the Sound object. </p>
	 *
	 * <p>If you set <code>checkPolicyFile</code> to <code>true</code> but no
	 * appropriate policy file is found, you will not receive an error until you
	 * perform an operation that requires a policy file, and then Flash Player or
	 * AIR throws a <code>SecurityError</code> exception. After you receive a
	 * <code>complete</code> event, you can test whether a relevant policy file
	 * was found by getting the value of <code>Sound.id3</code> within a
	 * <code>try</code> block and seeing if a <code>SecurityError</code> is
	 * thrown.</p>
	 *
	 * <p>Be careful with <code>checkPolicyFile</code> if you are downloading
	 * sound from a URL that uses server-side HTTP redirects. Flash Player or AIR
	 * tries to retrieve policy files that correspond to the <code>url</code>
	 * property of the URLRequest object passed to <code>Sound.load()</code>. If
	 * the final sound file comes from a different URL because of HTTP redirects,
	 * then the initially downloaded policy files might not be applicable to the
	 * sound's final URL, which is the URL that matters in security
	 * decisions.</p>
	 *
	 * <p>If you find yourself in this situation, here is one possible solution.
	 * After you receive a <code>progress</code> or <code>complete</code> event,
	 * you can examine the value of the <code>Sound.url</code> property, which
	 * contains the sound's final URL. Then call the
	 * <code>Security.loadPolicyFile()</code> method with a policy file URL that
	 * you calculate based on the sound's final URL. Finally, poll the value of
	 * <code>Sound.id3</code> until no exception is thrown.</p>
	 *
	 * <p>This does not apply to content in the AIR application sandbox. Content
	 * in the application sandbox always has programatic access to sound content,
	 * regardless of its origin.</p>
	 *
	 * <p>For more information related to security, see the Flash Player
	 * Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>]]></haxe_doc>
		</checkPolicyFile>
		<bufferTime public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The number of milliseconds to preload a streaming sound into a buffer
	 * before the sound starts to stream.
	 *
	 * <p>Note that you cannot override the value of
	 * <code>SoundLoaderContext.bufferTime</code> by setting the global
	 * <code>SoundMixer.bufferTime</code> property. The
	 * <code>SoundMixer.bufferTime</code> property affects the buffer time for
	 * embedded streaming sounds in a SWF file and is independent of dynamically
	 * created Sound objects(that is, Sound objects created in
	 * ActionScript).</p>]]></haxe_doc>
		</bufferTime>
		<new public="1" set="method">
			<f a="?bufferTime:?checkPolicyFile">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound loader context object.
	 * 
	 * @param bufferTime      The number of seconds to preload a streaming sound
	 *                        into a buffer before the sound starts to stream.
	 * @param checkPolicyFile Specifies whether the existence of a URL policy
	 *                        file should be checked upon loading the object
	 *                       (<code>true</code>) or not.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The SoundLoaderContext class provides security checks for files that load
 * sound. SoundLoaderContext objects are passed as an argument to the
 * constructor and the <code>load()</code> method of the Sound class.
 *
 * <p>When you use this class, consider the following security model: </p>
 *
 * <ul>
 *   <li>Loading and playing a sound is not allowed if the calling file is in
 * a network sandbox and the sound file to be loaded is local.</li>
 *   <li>By default, loading and playing a sound is not allowed if the calling
 * is local and tries to load and play a remote sound. A user must grant
 * explicit permission to allow this.</li>
 *   <li>Certain operations dealing with sound are restricted. The data in a
 * loaded sound cannot be accessed by a file in a different domain unless you
 * implement a URL policy file. Sound-related APIs that fall under this
 * restriction are the <code>Sound.id3</code> property and the
 * <code>SoundMixer.computeSpectrum()</code>,
 * <code>SoundMixer.bufferTime</code>, and <code>SoundTransform()</code>
 * methods.</li>
 * </ul>
 *
 * <p>However, in Adobe AIR, content in the <code>application</code> security
 * sandbox(content installed with the AIR application) are not restricted by
 * these security limitations.</p>
 *
 * <p>For more information related to security, see the Flash Player Developer
 * Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
 * scope="external">Security</a>.</p>]]></haxe_doc>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/media/SoundTransform.hx" extern="1">
		<volume public="1">
			<x path="Float"/>
			<haxe_doc>* The volume, ranging from 0(silent) to 1(full volume).</haxe_doc>
		</volume>
		<rightToRight public="1">
			<x path="Float"/>
			<haxe_doc>* A value, from 0(none) to 1(all), specifying how much of the right input
	 * is played in the right speaker.</haxe_doc>
		</rightToRight>
		<rightToLeft public="1">
			<x path="Float"/>
			<haxe_doc>* A value, from 0(none) to 1(all), specifying how much of the right input
	 * is played in the left speaker.</haxe_doc>
		</rightToLeft>
		<pan public="1">
			<x path="Float"/>
			<haxe_doc>* The left-to-right panning of the sound, ranging from -1(full pan left) to
	 * 1(full pan right). A value of 0 represents no panning(balanced center
	 * between right and left).</haxe_doc>
		</pan>
		<leftToRight public="1">
			<x path="Float"/>
			<haxe_doc>* A value, from 0(none) to 1(all), specifying how much of the left input
	 * is played in the right speaker.</haxe_doc>
		</leftToRight>
		<leftToLeft public="1">
			<x path="Float"/>
			<haxe_doc>* A value, from 0(none) to 1(all), specifying how much of the left input
	 * is played in the left speaker.</haxe_doc>
		</leftToLeft>
		<new public="1" set="method">
			<f a="?vol:?panning">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a SoundTransform object.
	 * 
	 * @param vol     The volume, ranging from 0(silent) to 1(full volume).
	 * @param panning The left-to-right panning of the sound, ranging from -1
	 *               (full pan left) to 1(full pan right). A value of 0
	 *                represents no panning(center).</haxe_doc>
		</new>
		<haxe_doc>* The SoundTransform class contains properties for volume and panning.</haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.SharedObject" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/net/SharedObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The default object encoding(AMF version) for all local shared objects
	 * created in the SWF file. When local shared objects are written to disk,
	 * the <code>SharedObject.defaultObjectEncoding</code> property indicates
	 * which Action Message Format version should be used: the ActionScript 3.0
	 * format(AMF3) or the ActionScript 1.0 or 2.0 format(AMF0).
	 *
	 * <p>For more information about object encoding, including the difference
	 * between encoding in local and remote shared objects, see the description
	 * of the <code>objectEncoding</code> property.</p>
	 *
	 * <p>The default value of <code>SharedObject.defaultObjectEncoding</code> is
	 * set to use the ActionScript 3.0 format, AMF3. If you need to write local
	 * shared objects that ActionScript 2.0 or 1.0 SWF files can read, set
	 * <code>SharedObject.defaultObjectEncoding</code> to use the ActionScript
	 * 1.0 or ActionScript 2.0 format,
	 * <code>flash.net.ObjectEncoding.AMF0</code>, at the beginning of your
	 * script, before you create any local shared objects. All local shared
	 * objects created thereafter will use AMF0 encoding and can interact with
	 * older content. You cannot change the <code>objectEncoding</code> value of
	 * existing local shared objects by setting
	 * <code>SharedObject.defaultObjectEncoding</code> after the local shared
	 * objects have been created.</p>
	 *
	 * <p>To set the object encoding on a per-object basis, rather than for all
	 * shared objects created by the SWF file, set the
	 * <code>objectEncoding</code> property of the local shared object
	 * instead.</p>]]></haxe_doc>
		</defaultObjectEncoding>
		<deleteAll public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<x path="Int"/>
</f></deleteAll>
		<getDiskUsage public="1" set="method" static="1"><f a="url">
	<c path="String"/>
	<x path="Int"/>
</f></getDiskUsage>
		<getLocal public="1" set="method" static="1">
			<f a="name:?localPath:?secure">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
				<c path="flash.net.SharedObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns a reference to a locally persistent shared object that is only
	 * available to the current client. If the shared object does not already
	 * exist, this method creates one. If any values passed to
	 * <code>getLocal()</code> are invalid or if the call fails, Flash Player
	 * throws an exception.
	 *
	 * <p>The following code shows how you assign the returned shared object
	 * reference to a variable:</p>
	 *
	 * <p><code>var so:SharedObject =
	 * SharedObject.getLocal("savedData");</code></p>
	 *
	 * <p><b>Note:</b> If the user has chosen to never allow local storage for
	 * this domain, the object is not saved locally, even if a value for
	 * <code>localPath</code> is specified. The exception to this rule is local
	 * content. Local content can always write shared objects from third-party
	 * domains(domains other than the domain in the current browser address bar)
	 * to disk, even if writing of third-party shared objects to disk is
	 * disallowed. </p>
	 *
	 * <p>To avoid name conflicts, Flash looks at the location of the SWF file
	 * creating the shared object. For example, if a SWF file at
	 * www.myCompany.com/apps/stockwatcher.swf creates a shared object named
	 * <code>portfolio</code>, that shared object does not conflict with another
	 * object named <code>portfolio</code> that was created by a SWF file at
	 * www.yourCompany.com/photoshoot.swf because the SWF files originate from
	 * different directories. </p>
	 *
	 * <p>Although the <code>localPath</code> parameter is optional, you should
	 * give some thought to its use, especially if other SWF files need to access
	 * the shared object. If the data in the shared object is specific to one SWF
	 * file that will not be moved to another location, then use of the default
	 * value makes sense. If other SWF files need access to the shared object, or
	 * if the SWF file that creates the shared object will later be moved, then
	 * the value of this parameter affects how accessible the shared object will
	 * be. For example, if you create a shared object with <code>localPath</code>
	 * set to the default value of the full path to the SWF file, no other SWF
	 * file can access that shared object. If you later move the original SWF
	 * file to another location, not even that SWF file can access the data
	 * already stored in the shared object.</p>
	 *
	 * <p>To avoid inadvertently restricting access to a shared object, use the
	 * <code>localpath</code> parameter. The most permissive approach is to set
	 * <code>localPath</code> to <code>/</code>(slash), which makes the shared
	 * object available to all SWF files in the domain, but increases the
	 * likelihood of name conflicts with other shared objects in the domain. A
	 * more restrictive approach is to append <code>localPath</code> with folder
	 * names that are in the full path to the SWF file. For example, for a
	 * <code>portfolio</code> shared object created by the SWF file at
	 * www.myCompany.com/apps/stockwatcher.swf, you could set the
	 * <code>localPath</code> parameter to <code>/</code>, <code>/apps</code>, or
	 * <code>/apps/stockwatcher.swf</code>. You must determine which approach
	 * provides optimal flexibility for your application.</p>
	 *
	 * <p>When using this method, consider the following security model:
	 * <ul>
	 *   <li>You cannot access shared objects across sandbox boundaries.</li>
	 *   <li>Users can restrict shared object access by using the Flash Player
	 * Settings dialog box or the Settings Manager. By default, an application
	 * can create shared objects of up 100 KB of data per domain. Administrators
	 * and users can also place restrictions on the ability to write to the file
	 * system.</li>
	 * </ul>
	 * </p>
	 *
	 * <p>Suppose you publish SWF file content to be played back as local files
	 * (either locally installed SWF files or EXE files), and you need to access
	 * a specific shared object from more than one local SWF file. In this
	 * situation, be aware that for local files, two different locations might be
	 * used to store shared objects. The domain that is used depends on the
	 * security permissions granted to the local file that created the shared
	 * object. Local files can have three different levels of permissions:
	 * <ol>
	 *   <li>Access to the local filesystem only.</li>
	 *   <li>Access to the network only.</li>
	 *   <li>Access to both the network and the local filesystem.</li>
	 * </ol>
	 * </p>
	 *
	 * <p>Local files with access to the local filesystem(level 1 or 3) store
	 * their shared objects in one location. Local files without access to the
	 * local filesystem(level 2) store their shared objects in another
	 * location.</p>
	 *
	 * <p>You can prevent a SWF file from using this method by setting the
	 * <code>allowNetworking</code> parameter of the the <code>object</code> and
	 * <code>embed</code> tags in the HTML page that contains the SWF
	 * content.</p>
	 *
	 * <p>For more information, see the Flash Player Developer Center Topic: <a
	 * href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 * 
	 * @param name      The name of the object. The name can include forward
	 *                  slashes(<code>/</code>); for example,
	 *                  <code>work/addresses</code> is a legal name. Spaces are
	 *                  not allowed in a shared object name, nor are the
	 *                  following characters: <pre xml:space="preserve"> ~ % & \
	 *                  ; : " ' , < > ? # </pre>
	 * @param localPath The full or partial path to the SWF file that created the
	 *                  shared object, and that determines where the shared
	 *                  object will be stored locally. If you do not specify this
	 *                  parameter, the full path is used.
	 * @param secure    Determines whether access to this shared object is
	 *                  restricted to SWF files that are delivered over an HTTPS
	 *                  connection. If your SWF file is delivered over HTTPS,
	 *                  this parameter's value has the following effects:
	 *                  <ul>
	 *                    <li>If this parameter is set to <code>true</code>,
	 *                  Flash Player creates a new secure shared object or gets a
	 *                  reference to an existing secure shared object. This
	 *                  secure shared object can be read from or written to only
	 *                  by SWF files delivered over HTTPS that call
	 *                  <code>SharedObject.getLocal()</code> with the
	 *                  <code>secure</code> parameter set to
	 *                  <code>true</code>.</li>
	 *                    <li>If this parameter is set to <code>false</code>,
	 *                  Flash Player creates a new shared object or gets a
	 *                  reference to an existing shared object that can be read
	 *                  from or written to by SWF files delivered over non-HTTPS
	 *                  connections.</li>
	 *                  </ul>
	 *
	 *                  <p>If your SWF file is delivered over a non-HTTPS
	 *                  connection and you try to set this parameter to
	 *                  <code>true</code>, the creation of a new shared object
	 *                 (or the access of a previously created secure shared
	 *                  object) fails and <code>null</code> is returned.
	 *                  Regardless of the value of this parameter, the created
	 *                  shared objects count toward the total amount of disk
	 *                  space allowed for a domain.</p>
	 *
	 *                  <p>The following diagram shows the use of the
	 *                  <code>secure</code> parameter:</p>
	 * @return A reference to a shared object that is persistent locally and is
	 *         available only to the current client. If Flash Player can't create
	 *         or find the shared object(for example, if <code>localPath</code>
	 *         was specified but no such directory exists), this method throws an
	 *         exception.
	 * @throws Error Flash Player cannot create the shared object for whatever
	 *               reason. This error might occur is if persistent shared
	 *               object creation and storage by third-party Flash content is
	 *               prohibited(does not apply to local content). Users can
	 *               prohibit third-party persistent shared objects on the Global
	 *               Storage Settings panel of the Settings Manager, located at
	 *               <a
	 *               href="http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html"
	 *               scope="external">http://www.adobe.com/support/documentation/en/flashplayer/help/settings_manager03.html</a>.]]></haxe_doc>
		</getLocal>
		<getRemote public="1" set="method" static="1">
			<f a="name:?remotePath:?persistence:?secure">
				<c path="String"/>
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<c path="flash.net.SharedObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns a reference to a shared object on Flash Media Server that multiple
	 * clients can access. If the remote shared object does not already exist,
	 * this method creates one.
	 *
	 * <p> To create a remote shared object, call <code>getRemote()</code> the
	 * call <code>connect()</code> to connect the remote shared object to the
	 * server, as in the following:</p>
	 *
	 * <p> To confirm that the local and remote copies of the shared object are
	 * synchronized, listen for and handle the <code>sync</code> event. All
	 * clients that want to share this object must pass the same values for the
	 * <code>name</code> and <code>remotePath</code> parameters. </p>
	 *
	 * <p>To create a shared object that is available only to the current client,
	 * use <code>SharedObject.getLocal()</code>. </p>
	 * 
	 * @param name        The name of the remote shared object. The name can
	 *                    include forward slashes(/); for example,
	 *                    work/addresses is a legal name. Spaces are not allowed
	 *                    in a shared object name, nor are the following
	 *                    characters: <pre xml:space="preserve"> ~ % & \ ; : " '
	 *                    , > ? ? #</pre>
	 * @param remotePath  The URI of the server on which the shared object will
	 *                    be stored. This URI must be identical to the URI of the
	 *                    NetConnection object passed to the
	 *                    <code>connect()</code> method.
	 * @param persistence Specifies whether the attributes of the shared object's
	 *                    data property are persistent locally, remotely, or
	 *                    both. This parameter can also specify where the shared
	 *                    object will be stored locally. Acceptable values are as
	 *                    follows:
	 *                    <ul>
	 *                      <li>A value of <code>false</code> specifies that the
	 *                    shared object is not persistent on the client or
	 *                    server.</li>
	 *                      <li>A value of <code>true</code> specifies that the
	 *                    shared object is persistent only on the server.</li>
	 *                      <li>A full or partial local path to the shared object
	 *                    indicates that the shared object is persistent on the
	 *                    client and the server. On the client, it is stored in
	 *                    the specified path; on the server, it is stored in a
	 *                    subdirectory within the application directory.</li>
	 *                    </ul>
	 *
	 *                    <p><b>Note:</b> If the user has chosen to never allow
	 *                    local storage for this domain, the object will not be
	 *                    saved locally, even if a local path is specified for
	 *                    persistence. For more information, see the class
	 *                    description.</p>
	 * @param secure      Determines whether access to this shared object is
	 *                    restricted to SWF files that are delivered over an
	 *                    HTTPS connection. For more information, see the
	 *                    description of the <code>secure</code> parameter in the
	 *                    <code>getLocal</code> method entry.
	 * @return A reference to an object that can be shared across multiple
	 *         clients.
	 * @throws Error Flash Player can't create or find the shared object. This
	 *               might occur if nonexistent paths were specified for the
	 *               <code>remotePath</code> and <code>persistence</code>
	 *               parameters.]]></haxe_doc>
		</getRemote>
		<setProperty public="1" set="method">
			<f a="propertyName:?value">
				<c path="String"/>
				<t path="flash.utils.Object"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Updates the value of a property in a shared object and indicates to the
	 * server that the value of the property has changed. The
	 * <code>setProperty()</code> method explicitly marks properties as changed,
	 * or dirty.
	 *
	 * <p>For more information about remote shared objects see the <a
	 * href="http://www.adobe.com/go/learn_fms_docs_en"> Flash Media Server
	 * documentation</a>.</p>
	 *
	 * <p><b>Note:</b> The <code>SharedObject.setProperty()</code> method
	 * implements the <code>setDirty()</code> method. In most cases, such as when
	 * the value of a property is a primitive type like String or Number, you
	 * would use <code>setProperty()</code> instead of <code>setDirty</code>.
	 * However, when the value of a property is an object that contains its own
	 * properties, use <code>setDirty()</code> to indicate when a value within
	 * the object has changed. In general, it is a good idea to call
	 * <code>setProperty()</code> rather than <code>setDirty()</code>, because
	 * <code>setProperty()</code> updates a property value only when that value
	 * has changed, whereas <code>setDirty()</code> forces synchronization on all
	 * subscribed clients.</p>
	 * 
	 * @param propertyName The name of the property in the shared object.
	 * @param value        The value of the property(an ActionScript object), or
	 *                     <code>null</code> to delete the property.]]></haxe_doc>
		</setProperty>
		<setDirty public="1" set="method">
			<f a="propertyName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Broadcasts a message to all clients connected to a remote shared object,
	 * including the client that sent the message. To process and respond to the
	 * message, create a callback function attached to the shared object.
	 *</haxe_doc>
		</setDirty>
		<flush public="1" set="method">
			<f a="?minDiskSpace">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Connects to a remote shared object on a server through a specified
	 * NetConnection object. Use this method after calling
	 * <code>getRemote()</code>. When a connection is successful, the
	 * <code>sync</code> event is dispatched.
	 *
	 * <p>Before attempting to work with a remote shared object, first check for
	 * any errors using a <code>try..catch..finally</code> statement. Then,
	 * listen for and handle the <code>sync</code> event before you make changes
	 * to the shared object. Any changes made locally  -  before the
	 * <code>sync</code> event is dispatched  -  might be lost. </p>
	 *
	 * <p> Call the <code>connect()</code> method to connect to a remote shared
	 * object, for example: </p>
	 * 
	 * @param myConnection A NetConnection object that uses the Real-Time
	 *                     Messaging Protocol(RTMP), such as a NetConnection
	 *                     object used to communicate with Flash Media Server.
	 * @param params       A string defining a message to pass to the remote
	 *                     shared object on the server. Cannot be used with Flash
	 *                     Media Server.
	 * @throws Error Flash Player could not connect to the specified remote
	 *               shared object. Verify that the NetConnection instance is
	 *               valid and connected and that the remote shared object was
	 *               successfully created on the server.]]></haxe_doc>
		</flush>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Closes the connection between a remote shared object and the server. If a
	 * remote shared object is locally persistent, the user can make changes to
	 * the local copy of the object after this method is called. Any changes made
	 * to the local object are sent to the server the next time the user connects
	 * to the remote shared object.
	 *</haxe_doc>
		</close>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* For local shared objects, purges all of the data and deletes the shared
	 * object from the disk. The reference to the shared object is still active,
	 * but its data properties are deleted.
	 *
	 * <p> For remote shared objects used with Flash Media Server,
	 * <code>clear()</code> disconnects the object and purges all of the data. If
	 * the shared object is locally persistent, this method also deletes the
	 * shared object from the disk. The reference to the shared object is still
	 * active, but its data properties are deleted. </p>
	 *]]></haxe_doc>
		</clear>
		<size public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The current size of the shared object, in bytes.
	 *
	 * <p>Flash calculates the size of a shared object by stepping through all of
	 * its data properties; the more data properties the object has, the longer
	 * it takes to estimate its size. Estimating object size can take significant
	 * processing time, so you may want to avoid using this method unless you
	 * have a specific need for it.</p>]]></haxe_doc>
		</size>
		<objectEncoding public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The object encoding(AMF version) for this shared object. When a local
	 * shared object is written to disk, the <code>objectEncoding</code> property
	 * indicates which Action Message Format version should be used: the
	 * ActionScript 3.0 format(AMF3) or the ActionScript 1.0 or 2.0 format
	 * (AMF0).
	 *
	 * <p>Object encoding is handled differently depending if the shared object
	 * is local or remote.</p>
	 *
	 * <ul>
	 *   <li><b>Local shared objects</b>. You can get or set the value of the
	 * <code>objectEncoding</code> property for local shared objects. The value
	 * of <code>objectEncoding</code> affects what formatting is used for
	 * <i>writing</i> this local shared object. If this local shared object must
	 * be readable by ActionScript 2.0 or 1.0 SWF files, set
	 * <code>objectEncoding</code> to <code>ObjectEncoding.AMF0</code>. Even if
	 * object encoding is set to write AMF3, Flash Player can still read AMF0
	 * local shared objects. That is, if you use the default value of this
	 * property, <code>ObjectEncoding.AMF3</code>, your SWF file can still read
	 * shared objects created by ActionScript 2.0 or 1.0 SWF files. </li>
	 *   <li><b>Remote shared objects</b>. When connected to the server, a remote
	 * shared object inherits its <code>objectEncoding</code> setting from the
	 * associated NetConnection instance(the instance used to connect to the
	 * remote shared object). When not connected to the server, a remote shared
	 * object inherits the <code>defaultObjectEncoding</code> setting from the
	 * associated NetConnection instance. Because the value of a remote shared
	 * object's <code>objectEncoding</code> property is determined by the
	 * NetConnection instance, this property is read-only for remote shared
	 * objects. </li>
	 * </ul>
	 * 
	 * @throws ReferenceError You attempted to set the value of the
	 *                        <code>objectEncoding</code> property on a remote
	 *                        shared object. This property is read-only for
	 *                        remote shared objects because its value is
	 *                        determined by the associated NetConnection
	 *                        instance.]]></haxe_doc>
		</objectEncoding>
		<fps public="1" get="null">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Specifies the number of times per second that a client's changes to a
	 * shared object are sent to the server.
	 *
	 * <p>Use this method when you want to control the amount of traffic between
	 * the client and the server. For example, if the connection between the
	 * client and server is relatively slow, you may want to set <code>fps</code>
	 * to a relatively low value. Conversely, if the client is connected to a
	 * multiuser application in which timing is important, you may want to set
	 * <code>fps</code> to a relatively high value.</p>
	 *
	 * <p>Setting <code>fps</code> will trigger a <code>sync</code> event and
	 * update all changes to the server. If you only want to update the server
	 * manually, set <code>fps</code> to 0.</p>
	 *
	 * <p>Changes are not sent to the server until the <code>sync</code> event
	 * has been dispatched. That is, if the response time from the server is
	 * slow, updates may be sent to the server less frequently than the value
	 * specified in this property. </p>]]></haxe_doc>
		</fps>
		<data public="1" set="null">
			<d/>
			<haxe_doc><![CDATA[* The collection of attributes assigned to the <code>data</code> property of
	 * the object; these attributes can be shared and stored. Each attribute can
	 * be an object of any ActionScript or JavaScript type  -  Array, Number,
	 * Boolean, ByteArray, XML, and so on. For example, the following lines
	 * assign values to various aspects of a shared object:
	 *
	 * <p> For remote shared objects used with a server, all attributes of the
	 * <code>data</code> property are available to all clients connected to the
	 * shared object, and all attributes are saved if the object is persistent.
	 * If one client changes the value of an attribute, all clients now see the
	 * new value. </p>]]></haxe_doc>
		</data>
		<client public="1">
			<d/>
			<haxe_doc><![CDATA[* Indicates the object on which callback methods are invoked. The default
	 * object is <code>this</code>. You can set the client property to another
	 * object, and callback methods will be invoked on that other object.
	 * 
	 * @throws TypeError The <code>client</code> property must be set to a
	 *                   non-null object.]]></haxe_doc>
		</client>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The SharedObject class is used to read and store limited amounts of data on
 * a user's computer or on a server. Shared objects offer real-time data
 * sharing between multiple client SWF files and objects that are persistent
 * on the local computer or remote server. Local shared objects are similar to
 * browser cookies and remote shared objects are similar to real-time data
 * transfer devices. To use remote shared objects, you need Adobe Flash Media
 * Server.
 *
 * <p>Use shared objects to do the following:</p>
 *
 * <ul>
 *   <li><b>Maintain local persistence</b>. This is the simplest way to use a
 * shared object, and does not require Flash Media Server. For example, you
 * can call <code>SharedObject.getLocal()</code> to create a shared object in
 * an application, such as a calculator with memory. When the user closes the
 * calculator, Flash Player saves the last value in a shared object on the
 * user's computer. The next time the calculator is run, it contains the
 * values it had previously. Alternatively, if you set the shared object's
 * properties to <code>null</code> before the calculator application is
 * closed, the next time the application runs, it opens without any values.
 * Another example of maintaining local persistence is tracking user
 * preferences or other data for a complex website, such as a record of which
 * articles a user read on a news site. Tracking this information allows you
 * to display articles that have already been read differently from new,
 * unread articles. Storing this information on the user's computer reduces
 * server load.</li>
 *   <li><b>Store and share data on Flash Media Server</b>. A shared object
 * can store data on the server for other clients to retrieve. For example,
 * call <code>SharedObject.getRemote()</code> to create a remote shared
 * object, such as a phone list, that is persistent on the server. Whenever a
 * client makes changes to the shared object, the revised data is available to
 * all clients currently connected to the object or who later connect to it.
 * If the object is also persistent locally, and a client changes data while
 * not connected to the server, the data is copied to the remote shared object
 * the next time the client connects to the object.</li>
 *   <li><b>Share data in real time</b>. A shared object can share data among
 * multiple clients in real time. For example, you can open a remote shared
 * object that stores a list of users connected to a chat room that is visible
 * to all clients connected to the object. When a user enters or leaves the
 * chat room, the object is updated and all clients that are connected to the
 * object see the revised list of chat room users.</li>
 * </ul>
 *
 * <p> To create a local shared object, call
 * <code>SharedObject.getLocal()</code>. To create a remote shared object,
 * call <code>SharedObject.getRemote()</code>.</p>
 *
 * <p> When an application closes, shared objects are <i>flushed</i>, or
 * written to a disk. You can also call the <code>flush()</code> method to
 * explicitly write data to a disk.</p>
 *
 * <p><b>Local disk space considerations.</b> Local shared objects have some
 * limitations that are important to consider as you design your application.
 * Sometimes SWF files may not be allowed to write local shared objects, and
 * sometimes the data stored in local shared objects can be deleted without
 * your knowledge. Flash Player users can manage the disk space that is
 * available to individual domains or to all domains. When users decrease the
 * amount of disk space available, some local shared objects may be deleted.
 * Flash Player users also have privacy controls that can prevent third-party
 * domains(domains other than the domain in the current browser address bar)
 * from reading or writing local shared objects.</p>
 *
 * <p><b>Note</b>: SWF files that are stored and run on a local computer, not
 * from a remote server, can always write third-party shared objects to disk.
 * For more information about third-party shared objects, see the <a
 * href="http://www.macromedia.com/support/documentation/en/flashplayer/help/settings_manager03.html"
 * scope="external">Global Storage Settings panel</a> in Flash Player
 * Help.</p>
 *
 * <p>It's a good idea to check for failures related to the amount of disk
 * space and to user privacy controls. Perform these checks when you call
 * <code>getLocal()</code> and <code>flush()</code>:
 * <ul>
 *   <li><code>SharedObject.getLocal()</code>  -  Flash Player throws an
 * exception when a call to this method fails, such as when the user has
 * disabled third-party shared objects and the domain of your SWF file does
 * not match the domain in the browser address bar.</li>
 *   <li><code>SharedObject.flush()</code>  -  Flash Player throws an
 * exception when a call to this method fails. It returns
 * <code>SharedObjectFlushStatus.FLUSHED</code> when it succeeds. It returns
 * <code>SharedObjectFlushStatus.PENDING</code> when additional storage space
 * is needed. Flash Player prompts the user to allow an increase in storage
 * space for locally saved information. Thereafter, the <code>netStatus</code>
 * event is dispatched with an information object indicating whether the flush
 * failed or succeeded.</li>
 * </ul>
 * </p>
 *
 * <p>If your SWF file attempts to create or modify local shared objects, make
 * sure that your SWF file is at least 215 pixels wide and at least 138 pixels
 * high(the minimum dimensions for displaying the dialog box that prompts
 * users to increase their local shared object storage limit). If your SWF
 * file is smaller than these dimensions and an increase in the storage limit
 * is required, <code>SharedObject.flush()</code> fails, returning
 * <code>SharedObjectFlushedStatus.PENDING</code> and dispatching the
 * <code>netStatus</code> event.</p>
 *
 * <p> <b>Remote shared objects.</b> With Flash Media Server, you can create
 * and use remote shared objects, that are shared in real-time by all clients
 * connected to your application. When one client changes a property of a
 * remote shared object, the property is changed for all connected clients.
 * You can use remote shared objects to synchronize clients, for example,
 * users in a multi-player game. </p>
 *
 * <p> Each remote shared object has a <code>data</code> property which is an
 * Object with properties that store data. Call <code>setProperty()</code> to
 * change an property of the data object. The server updates the properties,
 * dispatches a <code>sync</code> event, and sends the properties back to the
 * connected clients. </p>
 *
 * <p> You can choose to make remote shared objects persistent on the client,
 * the server, or both. By default, Flash Player saves locally persistent
 * remote shared objects up to 100K in size. When you try to save a larger
 * object, Flash Player displays the Local Storage dialog box, which lets the
 * user allow or deny local storage for the shared object. Make sure your
 * Stage size is at least 215 by 138 pixels; this is the minimum size Flash
 * requires to display the dialog box. </p>
 *
 * <p> If the user selects Allow, the server saves the shared object and
 * dispatches a <code>netStatus</code> event with a <code>code</code> property
 * of <code>SharedObject.Flush.Success</code>. If the user select Deny, the
 * server does not save the shared object and dispatches a
 * <code>netStatus</code> event with a <code>code</code> property of
 * <code>SharedObject.Flush.Failed</code>. </p>
 * 
 * @event asyncError Dispatched when an exception is thrown asynchronously  - 
 *                   that is, from native asynchronous code.
 * @event netStatus  Dispatched when a SharedObject instance is reporting its
 *                   status or error condition. The <code>netStatus</code>
 *                   event contains an <code>info</code> property, which is an
 *                   information object that contains specific information
 *                   about the event, such as whether a connection attempt
 *                   succeeded or whether the shared object was successfully
 *                   written to the local disk.
 * @event sync       Dispatched when a remote shared object has been updated
 *                   by the server.]]></haxe_doc>
	</class>
	<class path="flash.net.SharedObjectFlushStatus" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/net/SharedObjectFlushStatus.hx" extern="1">
		<FLUSHED public="1" static="1">
			<c path="String"/>
			<haxe_doc>* Indicates that the flush completed successfully.</haxe_doc>
		</FLUSHED>
		<PENDING public="1" static="1">
			<c path="String"/>
			<haxe_doc>* Indicates that the user is being prompted to increase disk space for the
	 * shared object before the flush can occur.</haxe_doc>
		</PENDING>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The SharedObjectFlushStatus class provides values for the code returned
 * from a call to the <code>SharedObject.flush()</code> method.]]></haxe_doc>
	</class>
	<class path="flash.net.URLRequest" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/net/URLRequest.hx" extern="1">
		<url public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The URL to be requested.
	 *
	 * <p>Be sure to encode any characters that are either described as unsafe in
	 * the Uniform Resource Locator specification(see
	 * http://www.faqs.org/rfcs/rfc1738.html) or that are reserved in the URL
	 * scheme of the URLRequest object(when not used for their reserved
	 * purpose). For example, use <code>"%25"</code> for the percent(%) symbol
	 * and <code>"%23"</code> for the number sign(#), as in
	 * <code>"http://www.example.com/orderForm.cfm?item=%23B-3&discount=50%25"</code>.</p>
	 *
	 * <p>By default, the URL must be in the same domain as the calling file,
	 * unless the content is running in the Adobe AIR application security
	 * sandbox. If you need to load data from a different domain, put a URL
	 * policy file on the server that is hosting the data. For more information,
	 * see the description of the URLRequest class.</p>
	 *
	 * <p>For content running in Adobe AIR, files in the application security
	 * sandobx  -  files installed with the AIR application  -  can access URLs
	 * using any of the following URL schemes:</p>
	 *
	 * <ul>
	 *   <li><code>http</code> and <code>https</code> </li>
	 *   <li><code>file</code> </li>
	 *   <li><code>app-storage</code> </li>
	 *   <li><code>app</code> </li>
	 * </ul>
	 *
	 * <p><b>Note:</b> IPv6(Internet Protocol version 6) is supported in AIR and
	 * in Flash Player 9.0.115.0 and later. IPv6 is a version of Internet
	 * Protocol that supports 128-bit addresses(an improvement on the earlier
	 * IPv4 protocol that supports 32-bit addresses). You might need to activate
	 * IPv6 on your networking interfaces. For more information, see the Help for
	 * the operating system hosting the data. If IPv6 is supported on the hosting
	 * system, you can specify numeric IPv6 literal addresses in URLs enclosed in
	 * brackets([]), as in the following. </p>
	 * <pre xml:space="preserve">
	 * rtmp://[2001:db8:ccc3:ffff:0:444d:555e:666f]:1935/test </pre>]]></haxe_doc>
		</url>
		<requestHeaders public="1">
			<c path="Array"><c path="flash.net.URLRequestHeader"/></c>
			<haxe_doc><![CDATA[* The array of HTTP request headers to be appended to the HTTP request. The
	 * array is composed of URLRequestHeader objects. Each object in the array
	 * must be a URLRequestHeader object that contains a name string and a value
	 * string, as follows:
	 *
	 * <p>Flash Player and the AIR runtime impose certain restrictions on request
	 * headers; for more information, see the URLRequestHeader class
	 * description.</p>
	 *
	 * <p>Not all methods that accept URLRequest parameters support the
	 * <code>requestHeaders</code> property, consult the documentation for the
	 * method you are calling. For example, the
	 * <code>FileReference.upload()</code> and
	 * <code>FileReference.download()</code> methods do not support the
	 * <code>URLRequest.requestHeaders</code> property.</p>
	 *
	 * <p>Due to browser limitations, custom HTTP request headers are only
	 * supported for <code>POST</code> requests, not for <code>GET</code>
	 * requests.</p>]]></haxe_doc>
		</requestHeaders>
		<method public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Controls the HTTP form submission method.
	 *
	 * <p>For SWF content running in Flash Player(in the browser), this property
	 * is limited to GET or POST operations, and valid values are
	 * <code>URLRequestMethod.GET</code> or
	 * <code>URLRequestMethod.POST</code>.</p>
	 *
	 * <p>For content running in Adobe AIR, you can use any string value if the
	 * content is in the application security sandbox. Otherwise, as with content
	 * running in Flash Player, you are restricted to using GET or POST
	 * operations.</p>
	 *
	 * <p>For content running in Adobe AIR, when using the
	 * <code>navigateToURL()</code> function, the runtime treats a URLRequest
	 * that uses the POST method(one that has its <code>method</code> property
	 * set to <code>URLRequestMethod.POST</code>) as using the GET method.</p>
	 *
	 * <p><b>Note:</b> If running in Flash Player and the referenced form has no
	 * body, Flash Player automatically uses a GET operation, even if the method
	 * is set to <code>URLRequestMethod.POST</code>. For this reason, it is
	 * recommended to always include a "dummy" body to ensure that the correct
	 * method is used.</p>
	 * 
	 * @default URLRequestMethod.GET
	 * @throws ArgumentError If the <code>value</code> parameter is not
	 *                       <code>URLRequestMethod.GET</code> or
	 *                       <code>URLRequestMethod.POST</code>.]]></haxe_doc>
		</method>
		<digest public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* A string that uniquely identifies the signed Adobe platform component to
	 * be stored to(or retrieved from) the Flash Player cache. An Adobe platform
	 * component is a signed file(a SWZ file) that contains SWF content that is
	 * cached persistently on a user's machine. All SWZ files are signed by
	 * Adobe. A digest corresponds to a single cached file; if you change the
	 * file in any way, its digest will change in an unpredictable way. By using
	 * a digest, you can verify the cached file across multiple domains. Two
	 * files with the same digest are the same file, and two files with different
	 * digests are not the same file. A file cannot(practically) be created to
	 * "spoof" a digest and pretend to be another digest.
	 *
	 * <p>The digest is based on an SHA-256 message digest algorithm(64
	 * characters long in hexadecimal format).</p>
	 *
	 * <p>For example, the Flex SDK includes a SWZ for the Flex framework(and it
	 * provides the digest string for that SWZ file). You can post this SWZ on
	 * your web server and load it in your SWF file(using the
	 * <code>load()</code> method of a URLLoader object). If the end user's
	 * machine already has the matching SWZ file cached, the application uses the
	 * cached SWZ file.(A SWZ file matches if its <code>digest</code> matches
	 * the one you provide.) Otherwise, the application downloads the SWZ file
	 * from the URL you specify. </p>
	 *
	 * <p>Only set the <code>digest</code> parameter in a URLRequest object used
	 * in a call to the <code>URLLoader.load()</code> method to load a SWZ file.
	 * If the <code>digest</code> property of a a URLRequest object is set when
	 * it is used in other methods, the application throws an IOError
	 * exception.</p>
	 * 
	 * @throws ArgumentError The digest provided does not match the digest of the
	 *                       file that is extracted from the downloaded signed
	 *                       file or the signed file loaded out of the cache. The
	 *                       application also throws this error if the provided
	 *                       digest is the wrong length or contains invalid
	 *                      (nonhexadecimal) characters.]]></haxe_doc>
		</digest>
		<data public="1">
			<d/>
			<haxe_doc><![CDATA[* An object containing data to be transmitted with the URL request.
	 *
	 * <p>This property is used in conjunction with the <code>method</code>
	 * property. When the value of <code>method</code> is <code>GET</code>, the
	 * value of <code>data</code> is appended to the value of
	 * <code>URLRequest.url</code>, using HTTP query-string syntax. When the
	 * <code>method</code> value is <code>POST</code>(or any value other than
	 * <code>GET</code>), the value of <code>data</code> is transmitted in the
	 * body of the HTTP request.</p>
	 *
	 * <p>The URLRequest API offers binary <code>POST</code> support and support
	 * for URL-encoded variables, as well as support for strings. The data object
	 * can be a ByteArray, URLVariables, or String object.</p>
	 *
	 * <p>The way in which the data is used depends on the type of object
	 * used:</p>
	 *
	 * <ul>
	 *   <li>If the object is a ByteArray object, the binary data of the
	 * ByteArray object is used as <code>POST</code> data. For <code>GET</code>,
	 * data of ByteArray type is not supported. Also, data of ByteArray type is
	 * not supported for <code>FileReference.upload()</code> and
	 * <code>FileReference.download()</code>.</li>
	 *   <li>If the object is a URLVariables object and the method is
	 * <code>POST</code>, the variables are encoded using
	 * <i>x-www-form-urlencoded</i> format and the resulting string is used as
	 * <code>POST</code> data. An exception is a call to
	 * <code>FileReference.upload()</code>, in which the variables are sent as
	 * separate fields in a <code>multipart/form-data</code> post.</li>
	 *   <li>If the object is a URLVariables object and the method is
	 * <code>GET</code>, the URLVariables object defines variables to be sent
	 * with the URLRequest object.</li>
	 *   <li>Otherwise, the object is converted to a string, and the string is
	 * used as the <code>POST</code> or <code>GET</code> data.</li>
	 * </ul>
	 *
	 * <p>This data is not sent until a method, such as
	 * <code>navigateToURL()</code> or <code>FileReference.upload()</code>, uses
	 * the URLRequest object.</p>
	 *
	 * <p><b>Note</b>: The value of <code>contentType</code> must correspond to
	 * the type of data in the <code>data</code> property. See the note in the
	 * description of the <code>contentType</code> property.</p>]]></haxe_doc>
		</data>
		<contentType public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The MIME content type of the content in the the <code>data</code>
	 * property.
	 *
	 * <p>The default value is
	 * <code>application/x-www-form-urlencoded</code>.</p>
	 *
	 * <p><b>Note</b>:The <code>FileReference.upload()</code>,
	 * <code>FileReference.download()</code>, and <code>HTMLLoader.load()</code>
	 * methods do not support the <code>URLRequest.contentType</code>
	 * property.</p>
	 *
	 * <p>When sending a POST request, the values of the <code>contentType</code>
	 * and <code>data</code> properties must correspond properly. The value of
	 * the <code>contentType</code> property instructs servers on how to
	 * interpret the value of the <code>data</code> property. </p>
	 *
	 * <ul>
	 *   <li>If the value of the <code>data</code> property is a URLVariables
	 * object, the value of <code>contentType</code> must be
	 * <code>application/x-www-form-urlencoded</code>. </li>
	 *   <li> If the value of the <code>data</code> property is any other type,
	 * the value of <code>contentType</code> should indicate the type of the POST
	 * data that will be sent(which is the binary or string data contained in
	 * the value of the <code>data</code> property). </li>
	 *   <li>For <code>FileReference.upload()</code>, the Content-Type of the
	 * request is set automatically to <code>multipart/form-data</code>, and the
	 * value of the <code>contentType</code> property is ignored.</li>
	 * </ul>
	 *
	 * <p> In Flash Player 10 and later, if you use a multipart Content-Type(for
	 * example "multipart/form-data") that contains an upload(indicated by a
	 * "filename" parameter in a "content-disposition" header within the POST
	 * body), the POST operation is subject to the security rules applied to
	 * uploads:</p>
	 *
	 * <ul>
	 *   <li>The POST operation must be performed in response to a user-initiated
	 * action, such as a mouse click or key press.</li>
	 *   <li>If the POST operation is cross-domain(the POST target is not on the
	 * same server as the SWF file that is sending the POST request), the target
	 * server must provide a URL policy file that permits cross-domain
	 * access.</li>
	 * </ul>
	 *
	 * <p>Also, for any multipart Content-Type, the syntax must be valid
	 * (according to the RFC2046 standards). If the syntax appears to be invalid,
	 * the POST operation is subject to the security rules applied to
	 * uploads.</p>]]></haxe_doc>
		</contentType>
		<new public="1" set="method">
			<f a="?url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a URLRequest object. If <code>System.useCodePage</code> is
	 * <code>true</code>, the request is encoded using the system code page,
	 * rather than Unicode. If <code>System.useCodePage</code> is
	 * <code>false</code>, the request is encoded using Unicode, rather than the
	 * system code page.
	 * 
	 * @param url The URL to be requested. You can set the URL later by using the
	 *            <code>url</code> property.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The URLRequest class captures all of the information in a single HTTP
 * request. URLRequest objects are passed to the <code>load()</code> methods
 * of the Loader, URLStream, and URLLoader classes, and to other loading
 * operations, to initiate URL downloads. They are also passed to the
 * <code>upload()</code> and <code>download()</code> methods of the
 * FileReference class.
 *
 * <p>A SWF file in the local-with-filesystem sandbox may not load data from,
 * or provide data to, a resource that is in the network sandbox. </p>
 *
 * <p>By default, the calling SWF file and the URL you load must be in the
 * same domain. For example, a SWF file at www.adobe.com can load data only
 * from sources that are also at www.adobe.com. To load data from a different
 * domain, place a URL policy file on the server hosting the data.</p>
 *
 * <p> However, in Adobe AIR, content in the application security sandbox
 * (content installed with the AIR application) is not restricted by these
 * security limitations. For content running in Adobe AIR, files in the
 * application security sandbox can access URLs using any of the following URL
 * schemes:</p>
 *
 * <ul>
 *   <li><code>http</code> and <code>https</code> </li>
 *   <li><code>file</code> </li>
 *   <li><code>app-storage</code> </li>
 *   <li><code>app</code> </li>
 * </ul>
 *
 * <p>Content running in Adobe AIR that is not in the application security
 * sandbox observes the same restrictions as content running in the browser
 * (in Flash Player), and loading is governed by the content's domain and any
 * permissions granted in URL policy files.</p>
 *
 * <p>For more information related to security, see the Flash Player Developer
 * Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
 * scope="external">Security</a>.</p>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The value associated with the <code>name</code> property(such as
	 * <code>text/plain</code>).]]></haxe_doc>
		</value>
		<name public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* An HTTP request header name(such as <code>Content-Type</code> or
	 * <code>SOAPAction</code>).]]></haxe_doc>
		</name>
		<new public="1" set="method">
			<f a="?name:?value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new URLRequestHeader object that encapsulates a single HTTP
	 * request header. URLRequestHeader objects are used in the
	 * <code>requestHeaders</code> property of the URLRequest class.
	 * 
	 * @param name  An HTTP request header name(such as
	 *              <code>Content-Type</code> or <code>SOAPAction</code>).
	 * @param value The value associated with the <code>name</code> property
	 *             (such as <code>text/plain</code>).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A URLRequestHeader object encapsulates a single HTTP request header and
 * consists of a name/value pair. URLRequestHeader objects are used in the
 * <code>requestHeaders</code> property of the URLRequest class.
 *
 * <p>In Adobe<sup>®</sup> AIR<sup>®</sup>, content in the application
 * security sandbox(such as content installed with the AIR application) can
 * use any request headers, without error. However, for content running in
 * Adobe AIR that is in a different security sandbox, or for content running
 * in Flash<sup>®</sup> Player, using following request headers cause a
 * runtime error to be thrown, and the restricted terms are not case-sensitive
 * (for example, <code>Get</code>, <code>get</code>, and <code>GET</code> are
 * each not allowed): </p>
 *
 * <p>In Flash Player and in Adobe AIR content outside of the application
 * security sandbox, the following request headers cannot be used, and the
 * restricted terms are not case-sensitive(for example, <code>Get</code>,
 * <code>get</code>, and <code>GET</code> are all not allowed). Also,
 * hyphenated terms apply if an underscore character is used(for example,
 * both <code>Content-Length</code> and <code>Content_Length</code> are not
 * allowed): </p>
 *
 * <p><code>Accept-Charset</code>, <code>Accept-Encoding</code>,
 * <code>Accept-Ranges</code>, <code>Age</code>, <code>Allow</code>,
 * <code>Allowed</code>, <code>Authorization</code>, <code>Charge-To</code>,
 * <code>Connect</code>, <code>Connection</code>, <code>Content-Length</code>,
 * <code>Content-Location</code>, <code>Content-Range</code>,
 * <code>Cookie</code>, <code>Date</code>, <code>Delete</code>,
 * <code>ETag</code>, <code>Expect</code>, <code>Get</code>,
 * <code>Head</code>, <code>Host</code>, <code>If-Modified-Since</code>,
 * <code>Keep-Alive</code>, <code>Last-Modified</code>, <code>Location</code>,
 * <code>Max-Forwards</code>, <code>Options</code>, <code>Origin</code>,
 * <code>Post</code>, <code>Proxy-Authenticate</code>,
 * <code>Proxy-Authorization</code>, <code>Proxy-Connection</code>,
 * <code>Public</code>, <code>Put</code>, <code>Range</code>,
 * <code>Referer</code>, <code>Request-Range</code>, <code>Retry-After</code>,
 * <code>Server</code>, <code>TE</code>, <code>Trace</code>,
 * <code>Trailer</code>, <code>Transfer-Encoding</code>, <code>Upgrade</code>,
 * <code>URI</code>, <code>User-Agent</code>, <code>Vary</code>,
 * <code>Via</code>, <code>Warning</code>, <code>WWW-Authenticate</code>,
 * <code>x-flash-version</code>.</p>
 *
 * <p>URLRequestHeader objects are restricted in length. If the cumulative
 * length of a URLRequestHeader object(the length of the <code>name</code>
 * property plus the <code>value</code> property) or an array of
 * URLRequestHeader objects used in the <code>URLRequest.requestHeaders</code>
 * property exceeds the acceptable length, an exception is thrown.</p>
 *
 * <p>Content running in Adobe AIR sets the <code>ACCEPT</code> header to the
 * following, unless you specify a setting for the <code>ACCEPT</code> header
 * in the <code>requestHeaders</code> property of the URLRequest class:</p>
 * <code>text/xml, application/xml, application/xhtml+xml, text/html;q=0.9,
 * text/plain;q=0.8, image/png, application/x-shockwave-flash,
 * video/mp4;q=0.9, flv-application/octet-stream;q=0.8, video/x-flv;q=0.7,
 * audio/mp4, ~~/~~;q=0.5</code>
 *
 * <p>Not all methods that accept URLRequest parameters support the
 * <code>requestHeaders</code> property, consult the documentation for the
 * method you are calling. For example, the
 * <code>FileReference.upload()</code> and
 * <code>FileReference.download()</code> methods do not support the
 * <code>URLRequest.requestHeaders</code> property.</p>
 *
 * <p>Due to browser limitations, custom HTTP request headers are only
 * supported for <code>POST</code> requests, not for <code>GET</code>
 * requests.</p>]]></haxe_doc>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/system/ApplicationDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_DEMAND/>
		<ON_LOAD/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<x path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<class path="flash.system.System" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/system/System.hx" extern="1">
		<deviceID public="1" set="null" static="1"><c path="String"/></deviceID>
		<totalMemory public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The amount of memory(in bytes) currently in use that has been directly
	 * allocated by Flash Player or AIR.
	 *
	 * <p>This property does not return <i>all</i> memory used by an Adobe AIR
	 * application or by the application(such as a browser) containing Flash
	 * Player content. The browser or operating system may consume other memory.
	 * The <code>System.privateMemory</code> property reflects <i>all</i> memory
	 * used by an application.</p>
	 *
	 * <p>If the amount of memory allocated is greater than the maximum value for
	 * a uint object(<code>uint.MAX_VALUE</code>, or 4,294,967,295), then this
	 * property is set to 0. The <code>System.totalMemoryNumber</code> property
	 * allows larger values.</p>]]></haxe_doc>
		</totalMemory>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Closes Flash Player.
	 *
	 * <p><i>For the standalone Flash Player debugger version only.</i></p>
	 *
	 * <p>AIR applications should call the <code>NativeApplication.exit()</code>
	 * method to exit the application.</p>
	 * 
	 * @param code A value to pass to the operating system. Typically, if the
	 *             process exits normally, the value is 0.]]></haxe_doc>
		</exit>
		<gc public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Forces the garbage collection process.
	 *
	 * <p><i>For the Flash Player debugger version and AIR applications only.</i>
	 * In an AIR application, the <code>System.gc()</code> method is only enabled
	 * in content running in the AIR Debug Launcher(ADL) or, in an installed
	 * applcation, in content in the application security sandbox.</p>
	 *]]></haxe_doc>
		</gc>
		<haxe_doc><![CDATA[* The System class contains properties related to local settings and
 * operations. Among these are settings for camers and microphones, operations
 * with shared objects and the use of the Clipboard.
 *
 * <p>Additional properties and methods are in other classes within the
 * flash.system package: the Capabilities class, the IME class, and the
 * Security class.</p>
 *
 * <p>This class contains only static methods and properties. You cannot
 * create new instances of the System class.</p>]]></haxe_doc>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/AntiAliasType.hx">
		<ADVANCED><haxe_doc><![CDATA[* Sets anti-aliasing to advanced anti-aliasing. Advanced anti-aliasing
	 * allows font faces to be rendered at very high quality at small sizes. It
	 * is best used with applications that have a lot of small text. Advanced
	 * anti-aliasing is not recommended for very large fonts(larger than 48
	 * points). This constant is used for the <code>antiAliasType</code> property
	 * in the TextField class. Use the syntax
	 * <code>AntiAliasType.ADVANCED</code>.]]></haxe_doc></ADVANCED>
		<NORMAL><haxe_doc><![CDATA[* Sets anti-aliasing to the anti-aliasing that is used in Flash Player 7 and
	 * earlier. This setting is recommended for applications that do not have a
	 * lot of text. This constant is used for the <code>antiAliasType</code>
	 * property in the TextField class. Use the syntax
	 * <code>AntiAliasType.NORMAL</code>.]]></haxe_doc></NORMAL>
		<haxe_doc>* The AntiAliasType class provides values for anti-aliasing in the
 * flash.text.TextField class.</haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.Font" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/Font.hx" extern="1">
		<enumerateFonts public="1" set="method" static="1">
			<f a="?enumerateDeviceFonts">
				<x path="Bool"/>
				<c path="Array"><c path="flash.text.Font"/></c>
			</f>
			<haxe_doc><![CDATA[* Specifies whether to provide a list of the currently available embedded
	 * fonts.
	 * 
	 * @param enumerateDeviceFonts Indicates whether you want to limit the list
	 *                             to only the currently available embedded
	 *                             fonts. If this is set to <code>true</code>
	 *                             then a list of all fonts, both device fonts
	 *                             and embedded fonts, is returned. If this is
	 *                             set to <code>false</code> then only a list of
	 *                             embedded fonts is returned.
	 * @return A list of available fonts as an array of Font objects.]]></haxe_doc>
		</enumerateFonts>
		<registerFont public="1" set="method" static="1">
			<f a="font">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Registers a font class in the global font list.
	 *</haxe_doc>
		</registerFont>
		<hasGlyphs public="1" set="method">
			<f a="str">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Specifies whether a provided string can be displayed using the currently
	 * assigned font.
	 * 
	 * @param str The string to test against the current font.
	 * @return A value of <code>true</code> if the specified string can be fully
	 *         displayed using this font.]]></haxe_doc>
		</hasGlyphs>
		<fontType public="1" set="null">
			<e path="flash.text.FontType"/>
			<haxe_doc>* The type of the font. This value can be any of the constants defined in
	 * the FontType class.</haxe_doc>
		</fontType>
		<fontStyle public="1" set="null">
			<e path="flash.text.FontStyle"/>
			<haxe_doc>* The style of the font. This value can be any of the values defined in the
	 * FontStyle class.</haxe_doc>
		</fontStyle>
		<fontName public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The name of an embedded font.</haxe_doc>
		</fontName>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The Font class is used to manage embedded fonts in SWF files. Embedded
 * fonts are represented as a subclass of the Font class. The Font class is
 * currently useful only to find out information about embedded fonts; you
 * cannot alter a font by using this class. You cannot use the Font class to
 * load external fonts, or to create an instance of a Font object by itself.
 * Use the Font class as an abstract base class.</haxe_doc>
	</class>
	<enum path="flash.text.FontStyle" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/FontStyle.hx">
		<BOLD><haxe_doc><![CDATA[* Defines the bold style of a font for the <code>fontStyle</code> parameter
	 * in the <code>setAdvancedAntiAliasingTable()</code> method. Use the syntax
	 * <code>FontStyle.BOLD</code>.]]></haxe_doc></BOLD>
		<BOLD_ITALIC><haxe_doc><![CDATA[* Defines the italic style of a font for the <code>fontStyle</code>
	 * parameter in the <code>setAdvancedAntiAliasingTable()</code> method. Use
	 * the syntax <code>FontStyle.ITALIC</code>.]]></haxe_doc></BOLD_ITALIC>
		<ITALIC><haxe_doc><![CDATA[* Defines the italic style of a font for the <code>fontStyle</code>
	 * parameter in the <code>setAdvancedAntiAliasingTable()</code> method. Use
	 * the syntax <code>FontStyle.ITALIC</code>.]]></haxe_doc></ITALIC>
		<REGULAR><haxe_doc><![CDATA[* Defines the plain style of a font for the <code>fontStyle</code> parameter
	 * in the <code>setAdvancedAntiAliasingTable()</code> method. Use the syntax
	 * <code>FontStyle.REGULAR</code>.]]></haxe_doc></REGULAR>
		<haxe_doc>* The FontStyle class provides values for the TextRenderer class.</haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.FontType" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/FontType.hx">
		<DEVICE><haxe_doc><![CDATA[* Indicates that this is a device font. The SWF file renders fonts with
	 * those installed on the system.
	 *
	 * <p>Using device fonts results in a smaller movie size, because font data
	 * is not included in the file. Device fonts are often a good choice for
	 * displaying text at small point sizes, because anti-aliased text can be
	 * blurry at small sizes. Device fonts are also a good choice for large
	 * blocks of text, such as scrolling text.</p>
	 *
	 * <p>Text fields that use device fonts may not be displayed the same across
	 * different systems and platforms, because they are rendered with fonts
	 * installed on the system. For the same reason, device fonts are not
	 * anti-aliased and may appear jagged at large point sizes.</p>]]></haxe_doc></DEVICE>
		<EMBEDDED><haxe_doc><![CDATA[* Indicates that this is an embedded font. Font outlines are embedded in the
	 * published SWF file.
	 *
	 * <p>Text fields that use embedded fonts are always displayed in the chosen
	 * font, whether or not that font is installed on the playback system. Also,
	 * text fields that use embedded fonts are always anti-aliased(smoothed).
	 * You can select the amount of anti-aliasing you want by using the
	 * <code>TextField.antiAliasType property</code>.</p>
	 *
	 * <p>One drawback to embedded fonts is that they increase the size of the
	 * SWF file.</p>
	 *
	 * <p>Fonts of type <code>EMBEDDED</code> can only be used by TextField. If
	 * flash.text.engine classes are directed to use such a font they will fall
	 * back to device fonts.</p>]]></haxe_doc></EMBEDDED>
		<EMBEDDED_CFF/>
		<haxe_doc><![CDATA[* The FontType class contains the enumerated constants
 * <code>"embedded"</code> and <code>"device"</code> for the
 * <code>fontType</code> property of the Font class.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextField" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<setTextFormat public="1" set="method">
			<f a="format:?beginIndex:?endIndex">
				<c path="flash.text.TextFormat"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Applies the text formatting that the <code>format</code> parameter
	 * specifies to the specified text in a text field. The value of
	 * <code>format</code> must be a TextFormat object that specifies the desired
	 * text formatting changes. Only the non-null properties of
	 * <code>format</code> are applied to the text field. Any property of
	 * <code>format</code> that is set to <code>null</code> is not applied. By
	 * default, all of the properties of a newly created TextFormat object are
	 * set to <code>null</code>.
	 *
	 * <p><b>Note:</b> This method does not work if a style sheet is applied to
	 * the text field.</p>
	 *
	 * <p>The <code>setTextFormat()</code> method changes the text formatting
	 * applied to a range of characters or to the entire body of text in a text
	 * field. To apply the properties of format to all text in the text field, do
	 * not specify values for <code>beginIndex</code> and <code>endIndex</code>.
	 * To apply the properties of the format to a range of text, specify values
	 * for the <code>beginIndex</code> and the <code>endIndex</code> parameters.
	 * You can use the <code>length</code> property to determine the index
	 * values.</p>
	 *
	 * <p>The two types of formatting information in a TextFormat object are
	 * character level formatting and paragraph level formatting. Each character
	 * in a text field can have its own character formatting settings, such as
	 * font name, font size, bold, and italic.</p>
	 *
	 * <p>For paragraphs, the first character of the paragraph is examined for
	 * the paragraph formatting settings for the entire paragraph. Examples of
	 * paragraph formatting settings are left margin, right margin, and
	 * indentation.</p>
	 *
	 * <p>Any text inserted manually by the user, or replaced by the
	 * <code>replaceSelectedText()</code> method, receives the default text field
	 * formatting for new text, and not the formatting specified for the text
	 * insertion point. To set the default formatting for new text, use
	 * <code>defaultTextFormat</code>.</p>
	 * 
	 * @param format A TextFormat object that contains character and paragraph
	 *               formatting information.
	 * @throws Error      This method cannot be used on a text field with a style
	 *                    sheet.
	 * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
	 *                    specified is out of range.]]></haxe_doc>
		</setTextFormat>
		<setSelection public="1" set="method">
			<f a="beginIndex:endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Sets as selected the text designated by the index values of the first and
	 * last characters, which are specified with the <code>beginIndex</code> and
	 * <code>endIndex</code> parameters. If the two parameter values are the
	 * same, this method sets the insertion point, as if you set the
	 * <code>caretIndex</code> property.
	 * 
	 * @param beginIndex The zero-based index value of the first character in the
	 *                   selection(for example, the first character is 0, the
	 *                   second character is 1, and so on).
	 * @param endIndex   The zero-based index value of the last character in the
	 *                   selection.]]></haxe_doc>
		</setSelection>
		<replaceText public="1" set="method">
			<f a="beginIndex:endIndex:newText">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Replaces the range of characters that the <code>beginIndex</code> and
	 * <code>endIndex</code> parameters specify with the contents of the
	 * <code>newText</code> parameter. As designed, the text from
	 * <code>beginIndex</code> to <code>endIndex-1</code> is replaced.
	 *
	 * <p><b>Note:</b> This method does not work if a style sheet is applied to
	 * the text field.</p>
	 * 
	 * @param beginIndex The zero-based index value for the start position of the
	 *                   replacement range.
	 * @param endIndex   The zero-based index position of the first character
	 *                   after the desired text span.
	 * @param newText    The text to use to replace the specified range of
	 *                   characters.
	 * @throws Error This method cannot be used on a text field with a style
	 *               sheet.]]></haxe_doc>
		</replaceText>
		<replaceSelectedText public="1" set="method">
			<f a="value">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Replaces the current selection with the contents of the <code>value</code>
	 * parameter. The text is inserted at the position of the current selection,
	 * using the current default character format and default paragraph format.
	 * The text is not treated as HTML.
	 *
	 * <p>You can use the <code>replaceSelectedText()</code> method to insert and
	 * delete text without disrupting the character and paragraph formatting of
	 * the rest of the text.</p>
	 *
	 * <p><b>Note:</b> This method does not work if a style sheet is applied to
	 * the text field.</p>
	 * 
	 * @param value The string to replace the currently selected text.
	 * @throws Error This method cannot be used on a text field with a style
	 *               sheet.]]></haxe_doc>
		</replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method">
			<f a="?beginIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flash.text.TextFormat"/>
			</f>
			<haxe_doc><![CDATA[* Returns a TextFormat object that contains formatting information for the
	 * range of text that the <code>beginIndex</code> and <code>endIndex</code>
	 * parameters specify. Only properties that are common to the entire text
	 * specified are set in the resulting TextFormat object. Any property that is
	 * <i>mixed</i>, meaning that it has different values at different points in
	 * the text, has a value of <code>null</code>.
	 *
	 * <p>If you do not specify values for these parameters, this method is
	 * applied to all the text in the text field. </p>
	 *
	 * <p>The following table describes three possible usages:</p>
	 * 
	 * @return The TextFormat object that represents the formatting properties
	 *         for the specified text.
	 * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
	 *                    specified is out of range.]]></haxe_doc>
		</getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method">
			<f a="charIndex">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Given a character index, returns the length of the paragraph containing
	 * the given character. The length is relative to the first character in the
	 * paragraph(as returned by <code>getFirstCharInParagraph()</code>), not to
	 * the character index passed in.
	 * 
	 * @param charIndex The zero-based index value of the character(for example,
	 *                  the first character is 0, the second character is 1, and
	 *                  so on).
	 * @return Returns the number of characters in the paragraph.
	 * @throws RangeError The character index specified is out of range.]]></haxe_doc>
		</getParagraphLength>
		<getLineText public="1" set="method">
			<f a="lineIndex">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Returns the text of the line specified by the <code>lineIndex</code>
	 * parameter.
	 * 
	 * @param lineIndex The zero-based index value of the line(for example, the
	 *                  first line is 0, the second line is 1, and so on).
	 * @return The text string contained in the specified line.
	 * @throws RangeError The line number specified is out of range.]]></haxe_doc>
		</getLineText>
		<getLineOffset public="1" set="method">
			<f a="lineIndex">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns the character index of the first character in the line that the
	 * <code>lineIndex</code> parameter specifies.
	 * 
	 * @param lineIndex The zero-based index value of the line(for example, the
	 *                  first line is 0, the second line is 1, and so on).
	 * @return The zero-based index value of the first character in the line.
	 * @throws RangeError The line number specified is out of range.]]></haxe_doc>
		</getLineOffset>
		<getLineMetrics public="1" set="method">
			<f a="lineIndex">
				<x path="Int"/>
				<c path="flash.text.TextLineMetrics"/>
			</f>
			<haxe_doc>* Returns metrics information about a given text line.
	 * 
	 * @param lineIndex The line number for which you want metrics information.
	 * @return A TextLineMetrics object.
	 * @throws RangeError The line number specified is out of range.</haxe_doc>
		</getLineMetrics>
		<getLineLength public="1" set="method">
			<f a="lineIndex">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the number of characters in a specific text line.
	 * 
	 * @param lineIndex The line number for which you want the length.
	 * @return The number of characters in the line.
	 * @throws RangeError The line number specified is out of range.</haxe_doc>
		</getLineLength>
		<getLineIndexOfChar public="1" set="method">
			<f a="charIndex">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns the zero-based index value of the line containing the character
	 * specified by the <code>charIndex</code> parameter.
	 * 
	 * @param charIndex The zero-based index value of the character(for example,
	 *                  the first character is 0, the second character is 1, and
	 *                  so on).
	 * @return The zero-based index value of the line.
	 * @throws RangeError The character index specified is out of range.]]></haxe_doc>
		</getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns the zero-based index value of the line at the point specified by
	 * the <code>x</code> and <code>y</code> parameters.
	 * 
	 * @param x The <i>x</i> coordinate of the line.
	 * @param y The <i>y</i> coordinate of the line.
	 * @return The zero-based index value of the line(for example, the first
	 *         line is 0, the second line is 1, and so on). Returns -1 if the
	 *         point is not over any line.]]></haxe_doc>
		</getLineIndexAtPoint>
		<getImageReference public="1" set="method">
			<f a="id">
				<c path="String"/>
				<c path="flash.display.DisplayObject"/>
			</f>
			<haxe_doc><![CDATA[* Returns a DisplayObject reference for the given <code>id</code>, for an
	 * image or SWF file that has been added to an HTML-formatted text field by
	 * using an <code><img></code> tag. The <code><img></code> tag is in the
	 * following format:
	 *
	 * <p><pre xml:space="preserve"><code> <img src = 'filename.jpg' id =
	 * 'instanceName' ></code></pre></p>
	 * 
	 * @param id The <code>id</code> to match(in the <code>id</code> attribute
	 *           of the <code><img></code> tag).
	 * @return The display object corresponding to the image or SWF file with the
	 *         matching <code>id</code> attribute in the <code><img></code> tag
	 *         of the text field. For media loaded from an external source, this
	 *         object is a Loader object, and, once loaded, the media object is a
	 *         child of that Loader object. For media embedded in the SWF file,
	 *         it is the loaded object. If no <code><img></code> tag with the
	 *         matching <code>id</code> exists, the method returns
	 *         <code>null</code>.]]></haxe_doc>
		</getImageReference>
		<getFirstCharInParagraph public="1" set="method">
			<f a="charIndex">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a character index, returns the index of the first character in the
	 * same paragraph.
	 * 
	 * @param charIndex The zero-based index value of the character(for example,
	 *                  the first character is 0, the second character is 1, and
	 *                  so on).
	 * @return The zero-based index value of the first character in the same
	 *         paragraph.
	 * @throws RangeError The character index specified is out of range.</haxe_doc>
		</getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns the zero-based index value of the character at the point specified
	 * by the <code>x</code> and <code>y</code> parameters.
	 * 
	 * @param x The <i>x</i> coordinate of the character.
	 * @param y The <i>y</i> coordinate of the character.
	 * @return The zero-based index value of the character(for example, the
	 *         first position is 0, the second position is 1, and so on). Returns
	 *         -1 if the point is not over any character.]]></haxe_doc>
		</getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method">
			<f a="charIndex">
				<x path="Int"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Returns a rectangle that is the bounding box of the character.
	 * 
	 * @param charIndex The zero-based index value for the character(for
	 *                  example, the first position is 0, the second position is
	 *                  1, and so on).
	 * @return A rectangle with <code>x</code> and <code>y</code> minimum and
	 *         maximum values defining the bounding box of the character.]]></haxe_doc>
		</getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method">
			<f a="newText">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Appends the string specified by the <code>newText</code> parameter to the
	 * end of the text of the text field. This method is more efficient than an
	 * addition assignment(<code>+=</code>) on a <code>text</code> property
	 * (such as <code>someTextField.text += moreText</code>), particularly for a
	 * text field that contains a significant amount of content.
	 * 
	 * @param newText The string to append to the existing text.]]></haxe_doc>
		</appendText>
		<wordWrap public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* A Boolean value that indicates whether the text field has word wrap. If
	 * the value of <code>wordWrap</code> is <code>true</code>, the text field
	 * has word wrap; if the value is <code>false</code>, the text field does not
	 * have word wrap. The default value is <code>false</code>.]]></haxe_doc>
		</wordWrap>
		<useRichTextClipboard public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether to copy and paste the text formatting along with the
	 * text. When set to <code>true</code>, Flash Player copies and pastes
	 * formatting(such as alignment, bold, and italics) when you copy and paste
	 * between text fields. Both the origin and destination text fields for the
	 * copy and paste procedure must have <code>useRichTextClipboard</code> set
	 * to <code>true</code>. The default value is <code>false</code>.]]></haxe_doc>
		</useRichTextClipboard>
		<type public="1">
			<e path="flash.text.TextFieldType"/>
			<haxe_doc><![CDATA[* The type of the text field. Either one of the following TextFieldType
	 * constants: <code>TextFieldType.DYNAMIC</code>, which specifies a dynamic
	 * text field, which a user cannot edit, or <code>TextFieldType.INPUT</code>,
	 * which specifies an input text field, which a user can edit.
	 * 
	 * @default dynamic
	 * @throws ArgumentError The <code>type</code> specified is not a member of
	 *                       flash.text.TextFieldType.]]></haxe_doc>
		</type>
		<thickness public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The thickness of the glyph edges in this text field. This property applies
	 * only when <code>flash.text.AntiAliasType</code> is set to
	 * <code>flash.text.AntiAliasType.ADVANCED</code>.
	 *
	 * <p>The range for <code>thickness</code> is a number from -200 to 200. If
	 * you attempt to set <code>thickness</code> to a value outside that range,
	 * the property is set to the nearest value in the range(either -200 or
	 * 200).</p>
	 * 
	 * @default 0]]></haxe_doc>
		</thickness>
		<textWidth public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The interaction mode property, Default value is
	 * TextInteractionMode.NORMAL. On mobile platforms, the normal mode implies
	 * that the text can be scrolled but not selected. One can switch to the
	 * selectable mode through the in-built context menu on the text field. On
	 * Desktop, the normal mode implies that the text is in scrollable as well as
	 * selection mode.</haxe_doc>
		</textWidth>
		<textHeight public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The height of the text in pixels.</haxe_doc>
		</textHeight>
		<textColor public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The color of the text in a text field, in hexadecimal format. The
	 * hexadecimal color system uses six digits to represent color values. Each
	 * digit has 16 possible values or characters. The characters range from 0-9
	 * and then A-F. For example, black is <code>0x000000</code>; white is
	 * <code>0xFFFFFF</code>.
	 * 
	 * @default 0(0x000000)]]></haxe_doc>
		</textColor>
		<text public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Attaches a style sheet to the text field. For information on creating
	 * style sheets, see the StyleSheet class and the <i>ActionScript 3.0
	 * Developer's Guide</i>.
	 *
	 * <p>You can change the style sheet associated with a text field at any
	 * time. If you change the style sheet in use, the text field is redrawn with
	 * the new style sheet. You can set the style sheet to <code>null</code> or
	 * <code>undefined</code> to remove the style sheet. If the style sheet in
	 * use is removed, the text field is redrawn without a style sheet. </p>
	 *
	 * <p><b>Note:</b> If the style sheet is removed, the contents of both
	 * <code>TextField.text</code> and <code> TextField.htmlText</code> change to
	 * incorporate the formatting previously applied by the style sheet. To
	 * preserve the original <code>TextField.htmlText</code> contents without the
	 * formatting, save the value in a variable before removing the style
	 * sheet.</p>]]></haxe_doc>
		</text>
		<sharpness public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The sharpness of the glyph edges in this text field. This property applies
	 * only if the <code>flash.text.AntiAliasType</code> property of the text
	 * field is set to <code>flash.text.AntiAliasType.ADVANCED</code>. The range
	 * for <code>sharpness</code> is a number from -400 to 400. If you attempt to
	 * set <code>sharpness</code> to a value outside that range, Flash sets the
	 * property to the nearest value in the range(either -400 or 400).
	 * 
	 * @default 0]]></haxe_doc>
		</sharpness>
		<selectionEndIndex public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The zero-based character index value of the last character in the current
	 * selection. For example, the first character is 0, the second character is
	 * 1, and so on. If no text is selected, this property is the value of
	 * <code>caretIndex</code>.]]></haxe_doc>
		</selectionEndIndex>
		<selectionBeginIndex public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The zero-based character index value of the first character in the current
	 * selection. For example, the first character is 0, the second character is
	 * 1, and so on. If no text is selected, this property is the value of
	 * <code>caretIndex</code>.]]></haxe_doc>
		</selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* A Boolean value that indicates whether the text field is selectable. The
	 * value <code>true</code> indicates that the text is selectable. The
	 * <code>selectable</code> property controls whether a text field is
	 * selectable, not whether a text field is editable. A dynamic text field can
	 * be selectable even if it is not editable. If a dynamic text field is not
	 * selectable, the user cannot select its text.
	 *
	 * <p>If <code>selectable</code> is set to <code>false</code>, the text in
	 * the text field does not respond to selection commands from the mouse or
	 * keyboard, and the text cannot be copied with the Copy command. If
	 * <code>selectable</code> is set to <code>true</code>, the text in the text
	 * field can be selected with the mouse or keyboard, and the text can be
	 * copied with the Copy command. You can select text this way even if the
	 * text field is a dynamic text field instead of an input text field. </p>
	 * 
	 * @default true]]></haxe_doc>
		</selectable>
		<scrollV public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The vertical position of text in a text field. The <code>scrollV</code>
	 * property is useful for directing users to a specific paragraph in a long
	 * passage, or creating scrolling text fields.
	 *
	 * <p>The units of vertical scrolling are lines, whereas the units of
	 * horizontal scrolling are pixels. If the first line displayed is the first
	 * line in the text field, scrollV is set to 1(not 0). Horizontal scrolling
	 * is measured in pixels because most fonts are proportionally spaced; that
	 * is, the characters can have different widths. Flash performs vertical
	 * scrolling by line because users usually want to see a complete line of
	 * text rather than a partial line. Even if there are multiple fonts on a
	 * line, the height of the line adjusts to fit the largest font in use.</p>]]></haxe_doc>
		</scrollV>
		<scrollH public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The current horizontal scrolling position. If the <code>scrollH</code>
	 * property is 0, the text is not horizontally scrolled. This property value
	 * is an integer that represents the horizontal position in pixels.
	 *
	 * <p>The units of horizontal scrolling are pixels, whereas the units of
	 * vertical scrolling are lines. Horizontal scrolling is measured in pixels
	 * because most fonts you typically use are proportionally spaced; that is,
	 * the characters can have different widths. Flash Player performs vertical
	 * scrolling by line because users usually want to see a complete line of
	 * text rather than a partial line. Even if a line uses multiple fonts, the
	 * height of the line adjusts to fit the largest font in use.</p>
	 *
	 * <p><b>Note: </b>The <code>scrollH</code> property is zero-based, not
	 * 1-based like the <code>scrollV</code> vertical scrolling property.</p>]]></haxe_doc>
		</scrollH>
		<restrict public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Indicates the set of characters that a user can enter into the text field.
	 * If the value of the <code>restrict</code> property is <code>null</code>,
	 * you can enter any character. If the value of the <code>restrict</code>
	 * property is an empty string, you cannot enter any character. If the value
	 * of the <code>restrict</code> property is a string of characters, you can
	 * enter only characters in the string into the text field. The string is
	 * scanned from left to right. You can specify a range by using the hyphen
	 * (-) character. Only user interaction is restricted; a script can put any
	 * text into the text field. <ph outputclass="flashonly">This property does
	 * not synchronize with the Embed font options in the Property inspector.
	 *
	 * <p>If the string begins with a caret(^) character, all characters are
	 * initially accepted and succeeding characters in the string are excluded
	 * from the set of accepted characters. If the string does not begin with a
	 * caret(^) character, no characters are initially accepted and succeeding
	 * characters in the string are included in the set of accepted
	 * characters.</p>
	 *
	 * <p>The following example allows only uppercase characters, spaces, and
	 * numbers to be entered into a text field:</p>
	 * <pre xml:space="preserve"> my_txt.restrict = "A-Z 0-9"; </pre>
	 *
	 * <p>The following example includes all characters, but excludes lowercase
	 * letters:</p>
	 * <pre xml:space="preserve"> my_txt.restrict = "^a-z"; </pre>
	 *
	 * <p>You can use a backslash to enter a ^ or - verbatim. The accepted
	 * backslash sequences are \-, \^ or \\. The backslash must be an actual
	 * character in the string, so when specified in ActionScript, a double
	 * backslash must be used. For example, the following code includes only the
	 * dash(-) and caret(^):</p>
	 * <pre xml:space="preserve"> my_txt.restrict = "\\-\\^"; </pre>
	 *
	 * <p>The ^ can be used anywhere in the string to toggle between including
	 * characters and excluding characters. The following code includes only
	 * uppercase letters, but excludes the uppercase letter Q:</p>
	 * <pre xml:space="preserve"> my_txt.restrict = "A-Z^Q"; </pre>
	 *
	 * <p>You can use the <code>\u</code> escape sequence to construct
	 * <code>restrict</code> strings. The following code includes only the
	 * characters from ASCII 32(space) to ASCII 126(tilde).</p>
	 * <pre xml:space="preserve"> my_txt.restrict = "\u0020-\u007E"; </pre>
	 * 
	 * @default null]]></haxe_doc>
		</restrict>
		<numLines public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Defines the number of text lines in a multiline text field. If
	 * <code>wordWrap</code> property is set to <code>true</code>, the number of
	 * lines increases when text wraps.]]></haxe_doc>
		</numLines>
		<multiline public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Indicates whether field is a multiline text field. If the value is
	 * <code>true</code>, the text field is multiline; if the value is
	 * <code>false</code>, the text field is a single-line text field. In a field
	 * of type <code>TextFieldType.INPUT</code>, the <code>multiline</code> value
	 * determines whether the <code>Enter</code> key creates a new line(a value
	 * of <code>false</code>, and the <code>Enter</code> key is ignored). If you
	 * paste text into a <code>TextField</code> with a <code>multiline</code>
	 * value of <code>false</code>, newlines are stripped out of the text.
	 * 
	 * @default false]]></haxe_doc>
		</multiline>
		<mouseWheelEnabled public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* A Boolean value that indicates whether Flash Player automatically scrolls
	 * multiline text fields when the user clicks a text field and rolls the
	 * mouse wheel. By default, this value is <code>true</code>. This property is
	 * useful if you want to prevent mouse wheel scrolling of text fields, or
	 * implement your own text field scrolling.]]></haxe_doc>
		</mouseWheelEnabled>
		<maxScrollV public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The maximum value of <code>scrollV</code>.]]></haxe_doc>
		</maxScrollV>
		<maxScrollH public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The maximum value of <code>scrollH</code>.]]></haxe_doc>
		</maxScrollH>
		<maxChars public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The maximum number of characters that the text field can contain, as
	 * entered by a user. A script can insert more text than
	 * <code>maxChars</code> allows; the <code>maxChars</code> property indicates
	 * only how much text a user can enter. If the value of this property is
	 * <code>0</code>, a user can enter an unlimited amount of text.
	 * 
	 * @default 0]]></haxe_doc>
		</maxChars>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The number of characters in a text field. A character such as tab
	 * (<code>\t</code>) counts as one character.]]></haxe_doc>
		</length>
		<htmlText public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Contains the HTML representation of the text field contents.
	 *
	 * <p>Flash Player supports the following HTML tags:</p>
	 *
	 * <p>Flash Player and AIR also support explicit character codes, such as
	 * &#38;(ASCII ampersand) and &#x20AC;(Unicode € symbol). </p>]]></haxe_doc>
		</htmlText>
		<gridFitType public="1">
			<e path="flash.text.GridFitType"/>
			<haxe_doc><![CDATA[* The type of grid fitting used for this text field. This property applies
	 * only if the <code>flash.text.AntiAliasType</code> property of the text
	 * field is set to <code>flash.text.AntiAliasType.ADVANCED</code>.
	 *
	 * <p>The type of grid fitting used determines whether Flash Player forces
	 * strong horizontal and vertical lines to fit to a pixel or subpixel grid,
	 * or not at all.</p>
	 *
	 * <p>For the <code>flash.text.GridFitType</code> property, you can use the
	 * following string values:</p>
	 * 
	 * @default pixel]]></haxe_doc>
		</gridFitType>
		<embedFonts public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether to render by using embedded font outlines. If
	 * <code>false</code>, Flash Player renders the text field by using device
	 * fonts.
	 *
	 * <p>If you set the <code>embedFonts</code> property to <code>true</code>
	 * for a text field, you must specify a font for that text by using the
	 * <code>font</code> property of a TextFormat object applied to the text
	 * field. If the specified font is not embedded in the SWF file, the text is
	 * not displayed.</p>
	 * 
	 * @default false]]></haxe_doc>
		</embedFonts>
		<displayAsPassword public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether the text field is a password text field. If the value of
	 * this property is <code>true</code>, the text field is treated as a
	 * password text field and hides the input characters using asterisks instead
	 * of the actual characters. If <code>false</code>, the text field is not
	 * treated as a password text field. When password mode is enabled, the Cut
	 * and Copy commands and their corresponding keyboard shortcuts will not
	 * function. This security mechanism prevents an unscrupulous user from using
	 * the shortcuts to discover a password on an unattended computer.
	 * 
	 * @default false]]></haxe_doc>
		</displayAsPassword>
		<defaultTextFormat public="1">
			<c path="flash.text.TextFormat"/>
			<haxe_doc><![CDATA[* Specifies the format applied to newly inserted text, such as text entered
	 * by a user or text inserted with the <code>replaceSelectedText()</code>
	 * method.
	 *
	 * <p><b>Note:</b> When selecting characters to be replaced with
	 * <code>setSelection()</code> and <code>replaceSelectedText()</code>, the
	 * <code>defaultTextFormat</code> will be applied only if the text has been
	 * selected up to and including the last character. Here is an example:</p>
	 * <pre xml:space="preserve"> var my_txt:TextField new TextField();
	 * my_txt.text = "Flash Macintosh version"; var my_fmt:TextFormat = new
	 * TextFormat(); my_fmt.color = 0xFF0000; my_txt.defaultTextFormat = my_fmt;
	 * my_txt.setSelection(6,15); // partial text selected - defaultTextFormat
	 * not applied my_txt.setSelection(6,23); // text selected to end -
	 * defaultTextFormat applied my_txt.replaceSelectedText("Windows version");
	 * </pre>
	 *
	 * <p>When you access the <code>defaultTextFormat</code> property, the
	 * returned TextFormat object has all of its properties defined. No property
	 * is <code>null</code>.</p>
	 *
	 * <p><b>Note:</b> You can't set this property if a style sheet is applied to
	 * the text field.</p>
	 * 
	 * @throws Error This method cannot be used on a text field with a style
	 *               sheet.]]></haxe_doc>
		</defaultTextFormat>
		<condenseWhite public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* A Boolean value that specifies whether extra white space(spaces, line
	 * breaks, and so on) in a text field with HTML text is removed. The default
	 * value is <code>false</code>. The <code>condenseWhite</code> property only
	 * affects text set with the <code>htmlText</code> property, not the
	 * <code>text</code> property. If you set text with the <code>text</code>
	 * property, <code>condenseWhite</code> is ignored.
	 *
	 * <p>If <code>condenseWhite</code> is set to <code>true</code>, use standard
	 * HTML commands such as <code><BR></code> and <code><P></code> to place line
	 * breaks in the text field.</p>
	 *
	 * <p>Set the <code>condenseWhite</code> property before setting the
	 * <code>htmlText</code> property.</p>]]></haxe_doc>
		</condenseWhite>
		<caretIndex public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The index of the insertion point(caret) position. If no insertion point
	 * is displayed, the value is the position the insertion point would be if
	 * you restored focus to the field(typically where the insertion point last
	 * was, or 0 if the field has not had focus).
	 *
	 * <p>Selection span indexes are zero-based(for example, the first position
	 * is 0, the second position is 1, and so on).</p>]]></haxe_doc>
		</caretIndex>
		<bottomScrollV public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* An integer(1-based index) that indicates the bottommost line that is
	 * currently visible in the specified text field. Think of the text field as
	 * a window onto a block of text. The <code>scrollV</code> property is the
	 * 1-based index of the topmost visible line in the window.
	 *
	 * <p>All the text between the lines indicated by <code>scrollV</code> and
	 * <code>bottomScrollV</code> is currently visible in the text field.</p>]]></haxe_doc>
		</bottomScrollV>
		<borderColor public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The color of the text field border. The default value is
	 * <code>0x000000</code>(black). This property can be retrieved or set, even
	 * if there currently is no border, but the color is visible only if the text
	 * field has the <code>border</code> property set to <code>true</code>.]]></haxe_doc>
		</borderColor>
		<border public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether the text field has a border. If <code>true</code>, the
	 * text field has a border. If <code>false</code>, the text field has no
	 * border. Use the <code>borderColor</code> property to set the border color.
	 * 
	 * @default false]]></haxe_doc>
		</border>
		<backgroundColor public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The color of the text field background. The default value is
	 * <code>0xFFFFFF</code>(white). This property can be retrieved or set, even
	 * if there currently is no background, but the color is visible only if the
	 * text field has the <code>background</code> property set to
	 * <code>true</code>.]]></haxe_doc>
		</backgroundColor>
		<background public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Specifies whether the text field has a background fill. If
	 * <code>true</code>, the text field has a background fill. If
	 * <code>false</code>, the text field has no background fill. Use the
	 * <code>backgroundColor</code> property to set the background color of a
	 * text field.
	 * 
	 * @default false]]></haxe_doc>
		</background>
		<autoSize public="1">
			<e path="flash.text.TextFieldAutoSize"/>
			<haxe_doc><![CDATA[* Controls automatic sizing and alignment of text fields. Acceptable values
	 * for the <code>TextFieldAutoSize</code> constants:
	 * <code>TextFieldAutoSize.NONE</code>(the default),
	 * <code>TextFieldAutoSize.LEFT</code>, <code>TextFieldAutoSize.RIGHT</code>,
	 * and <code>TextFieldAutoSize.CENTER</code>.
	 *
	 * <p>If <code>autoSize</code> is set to <code>TextFieldAutoSize.NONE</code>
	 * (the default) no resizing occurs.</p>
	 *
	 * <p>If <code>autoSize</code> is set to <code>TextFieldAutoSize.LEFT</code>,
	 * the text is treated as left-justified text, meaning that the left margin
	 * of the text field remains fixed and any resizing of a single line of the
	 * text field is on the right margin. If the text includes a line break(for
	 * example, <code>"\n"</code> or <code>"\r"</code>), the bottom is also
	 * resized to fit the next line of text. If <code>wordWrap</code> is also set
	 * to <code>true</code>, only the bottom of the text field is resized and the
	 * right side remains fixed.</p>
	 *
	 * <p>If <code>autoSize</code> is set to
	 * <code>TextFieldAutoSize.RIGHT</code>, the text is treated as
	 * right-justified text, meaning that the right margin of the text field
	 * remains fixed and any resizing of a single line of the text field is on
	 * the left margin. If the text includes a line break(for example,
	 * <code>"\n" or "\r")</code>, the bottom is also resized to fit the next
	 * line of text. If <code>wordWrap</code> is also set to <code>true</code>,
	 * only the bottom of the text field is resized and the left side remains
	 * fixed.</p>
	 *
	 * <p>If <code>autoSize</code> is set to
	 * <code>TextFieldAutoSize.CENTER</code>, the text is treated as
	 * center-justified text, meaning that any resizing of a single line of the
	 * text field is equally distributed to both the right and left margins. If
	 * the text includes a line break(for example, <code>"\n"</code> or
	 * <code>"\r"</code>), the bottom is also resized to fit the next line of
	 * text. If <code>wordWrap</code> is also set to <code>true</code>, only the
	 * bottom of the text field is resized and the left and right sides remain
	 * fixed.</p>
	 * 
	 * @throws ArgumentError The <code>autoSize</code> specified is not a member
	 *                       of flash.text.TextFieldAutoSize.]]></haxe_doc>
		</autoSize>
		<antiAliasType public="1">
			<e path="flash.text.AntiAliasType"/>
			<haxe_doc><![CDATA[* The type of anti-aliasing used for this text field. Use
	 * <code>flash.text.AntiAliasType</code> constants for this property. You can
	 * control this setting only if the font is embedded(with the
	 * <code>embedFonts</code> property set to <code>true</code>). The default
	 * setting is <code>flash.text.AntiAliasType.NORMAL</code>.
	 *
	 * <p>To set values for this property, use the following string values:</p>]]></haxe_doc>
		</antiAliasType>
		<alwaysShowSelection public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* When set to <code>true</code> and the text field is not in focus, Flash
	 * Player highlights the selection in the text field in gray. When set to
	 * <code>false</code> and the text field is not in focus, Flash Player does
	 * not highlight the selection in the text field.
	 * 
	 * @default false]]></haxe_doc>
		</alwaysShowSelection>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Creates a new TextField instance. After you create the TextField instance,
	 * call the <code>addChild()</code> or <code>addChildAt()</code> method of
	 * the parent DisplayObjectContainer object to add the TextField instance to
	 * the display list.
	 *
	 * <p>The default size for a text field is 100 x 100 pixels.</p>]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The TextField class is used to create display objects for text display and
 * input. <ph outputclass="flexonly">You can use the TextField class to
 * perform low-level text rendering. However, in Flex, you typically use the
 * Label, Text, TextArea, and TextInput controls to process text. <ph
 * outputclass="flashonly">You can give a text field an instance name in the
 * Property inspector and use the methods and properties of the TextField
 * class to manipulate it with ActionScript. TextField instance names are
 * displayed in the Movie Explorer and in the Insert Target Path dialog box in
 * the Actions panel.
 *
 * <p>To create a text field dynamically, use the <code>TextField()</code>
 * constructor.</p>
 *
 * <p>The methods of the TextField class let you set, select, and manipulate
 * text in a dynamic or input text field that you create during authoring or
 * at runtime. </p>
 *
 * <p>ActionScript provides several ways to format your text at runtime. The
 * TextFormat class lets you set character and paragraph formatting for
 * TextField objects. You can apply Cascading Style Sheets(CSS) styles to
 * text fields by using the <code>TextField.styleSheet</code> property and the
 * StyleSheet class. You can use CSS to style built-in HTML tags, define new
 * formatting tags, or apply styles. You can assign HTML formatted text, which
 * optionally uses CSS styles, directly to a text field. HTML text that you
 * assign to a text field can contain embedded media(movie clips, SWF files,
 * GIF files, PNG files, and JPEG files). The text wraps around the embedded
 * media in the same way that a web browser wraps text around media embedded
 * in an HTML document. </p>
 *
 * <p>Flash Player supports a subset of HTML tags that you can use to format
 * text. See the list of supported HTML tags in the description of the
 * <code>htmlText</code> property.</p>
 * 
 * @event change                    Dispatched after a control value is
 *                                  modified, unlike the
 *                                  <code>textInput</code> event, which is
 *                                  dispatched before the value is modified.
 *                                  Unlike the W3C DOM Event Model version of
 *                                  the <code>change</code> event, which
 *                                  dispatches the event only after the
 *                                  control loses focus, the ActionScript 3.0
 *                                  version of the <code>change</code> event
 *                                  is dispatched any time the control
 *                                  changes. For example, if a user types text
 *                                  into a text field, a <code>change</code>
 *                                  event is dispatched after every keystroke.
 * @event link                      Dispatched when a user clicks a hyperlink
 *                                  in an HTML-enabled text field, where the
 *                                  URL begins with "event:". The remainder of
 *                                  the URL after "event:" is placed in the
 *                                  text property of the LINK event.
 *
 *                                  <p><b>Note:</b> The default behavior,
 *                                  adding the text to the text field, occurs
 *                                  only when Flash Player generates the
 *                                  event, which in this case happens when a
 *                                  user attempts to input text. You cannot
 *                                  put text into a text field by sending it
 *                                  <code>textInput</code> events.</p>
 * @event scroll                    Dispatched by a TextField object
 *                                  <i>after</i> the user scrolls.
 * @event textInput                 Flash Player dispatches the
 *                                  <code>textInput</code> event when a user
 *                                  enters one or more characters of text.
 *                                  Various text input methods can generate
 *                                  this event, including standard keyboards,
 *                                  input method editors(IMEs), voice or
 *                                  speech recognition systems, and even the
 *                                  act of pasting plain text with no
 *                                  formatting or style information.
 * @event textInteractionModeChange Flash Player dispatches the
 *                                  <code>textInteractionModeChange</code>
 *                                  event when a user changes the interaction
 *                                  mode of a text field. for example on
 *                                  Android, one can toggle from NORMAL mode
 *                                  to SELECTION mode using context menu
 *                                  options]]></haxe_doc>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/TextFieldAutoSize.hx">
		<CENTER><haxe_doc>* Specifies that the text is to be treated as center-justified text. Any
	 * resizing of a single line of a text field is equally distributed to both
	 * the right and left sides.</haxe_doc></CENTER>
		<LEFT><haxe_doc>* Specifies that the text is to be treated as left-justified text, meaning
	 * that the left side of the text field remains fixed and any resizing of a
	 * single line is on the right side.</haxe_doc></LEFT>
		<NONE><haxe_doc>* Specifies that no resizing is to occur.</haxe_doc></NONE>
		<RIGHT><haxe_doc>* Specifies that the text is to be treated as right-justified text, meaning
	 * that the right side of the text field remains fixed and any resizing of a
	 * single line is on the left side.</haxe_doc></RIGHT>
		<haxe_doc><![CDATA[* The TextFieldAutoSize class is an enumeration of constant values used in
 * setting the <code>autoSize</code> property of the TextField class.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/TextFieldType.hx">
		<DYNAMIC><haxe_doc><![CDATA[* Used to specify a <code>dynamic</code> TextField.]]></haxe_doc></DYNAMIC>
		<INPUT><haxe_doc><![CDATA[* Used to specify an <code>input</code> TextField.]]></haxe_doc></INPUT>
		<haxe_doc><![CDATA[* The TextFieldType class is an enumeration of constant values used in
 * setting the <code>type</code> property of the TextField class.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/TextFormat.hx" extern="1">
		<url public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Indicates the target URL for the text in this text format. If the
	 * <code>url</code> property is an empty string, the text does not have a
	 * hyperlink. The default value is <code>null</code>, which indicates that
	 * the text does not have a hyperlink.
	 *
	 * <p><b>Note:</b> The text with the assigned text format must be set with
	 * the <code>htmlText</code> property for the hyperlink to work.</p>]]></haxe_doc>
		</url>
		<underline public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc><![CDATA[* Indicates whether the text that uses this text format is underlined
	 * (<code>true</code>) or not(<code>false</code>). This underlining is
	 * similar to that produced by the <code><U></code> tag, but the latter is
	 * not true underlining, because it does not skip descenders correctly. The
	 * default value is <code>null</code>, which indicates that underlining is
	 * not used.]]></haxe_doc>
		</underline>
		<target public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Indicates the target window where the hyperlink is displayed. If the
	 * target window is an empty string, the text is displayed in the default
	 * target window <code>_self</code>. You can choose a custom name or one of
	 * the following four names: <code>_self</code> specifies the current frame
	 * in the current window, <code>_blank</code> specifies a new window,
	 * <code>_parent</code> specifies the parent of the current frame, and
	 * <code>_top</code> specifies the top-level frame in the current window. If
	 * the <code>TextFormat.url</code> property is an empty string or
	 * <code>null</code>, you can get or set this property, but the property will
	 * have no effect.]]></haxe_doc>
		</target>
		<tabStops public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc><![CDATA[* Specifies custom tab stops as an array of non-negative integers. Each tab
	 * stop is specified in pixels. If custom tab stops are not specified
	 * (<code>null</code>), the default tab stop is 4(average character width).]]></haxe_doc>
		</tabStops>
		<size public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* The size in pixels of text in this text format. The default value is
	 * <code>null</code>, which means that a size of 12 is used.]]></haxe_doc>
		</size>
		<rightMargin public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* The right margin of the paragraph, in pixels. The default value is
	 * <code>null</code>, which indicates that the right margin is 0 pixels.]]></haxe_doc>
		</rightMargin>
		<letterSpacing public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* A number representing the amount of space that is uniformly distributed
	 * between all characters. The value specifies the number of pixels that are
	 * added to the advance after each character. The default value is
	 * <code>null</code>, which means that 0 pixels of letter spacing is used.
	 * You can use decimal values such as <code>1.75</code>.]]></haxe_doc>
		</letterSpacing>
		<leftMargin public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* The left margin of the paragraph, in pixels. The default value is
	 * <code>null</code>, which indicates that the left margin is 0 pixels.]]></haxe_doc>
		</leftMargin>
		<leading public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* An integer representing the amount of vertical space(called
	 * <i>leading</i>) between lines. The default value is <code>null</code>,
	 * which indicates that the amount of leading used is 0.]]></haxe_doc>
		</leading>
		<kerning public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc><![CDATA[* A Boolean value that indicates whether kerning is enabled
	 * (<code>true</code>) or disabled(<code>false</code>). Kerning adjusts the
	 * pixels between certain character pairs to improve readability, and should
	 * be used only when necessary, such as with headings in large fonts. Kerning
	 * is supported for embedded fonts only.
	 *
	 * <p>Certain fonts such as Verdana and monospaced fonts, such as Courier
	 * New, do not support kerning.</p>
	 *
	 * <p>The default value is <code>null</code>, which means that kerning is not
	 * enabled.</p>]]></haxe_doc>
		</kerning>
		<italic public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc><![CDATA[* Indicates whether text in this text format is italicized. The default
	 * value is <code>null</code>, which means no italics are used.]]></haxe_doc>
		</italic>
		<indent public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* Indicates the indentation from the left margin to the first character in
	 * the paragraph. The default value is <code>null</code>, which indicates
	 * that no indentation is used.]]></haxe_doc>
		</indent>
		<font public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* The name of the font for text in this text format, as a string. The
	 * default value is <code>null</code>, which means that Flash Player uses
	 * Times New Roman font for the text.]]></haxe_doc>
		</font>
		<color public="1">
			<t path="Null"><x path="Int"/></t>
			<haxe_doc><![CDATA[* Indicates the color of the text. A number containing three 8-bit RGB
	 * components; for example, 0xFF0000 is red, and 0x00FF00 is green. The
	 * default value is <code>null</code>, which means that Flash Player uses the
	 * color black(0x000000).]]></haxe_doc>
		</color>
		<bullet public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc><![CDATA[* Indicates that the text is part of a bulleted list. In a bulleted list,
	 * each paragraph of text is indented. To the left of the first line of each
	 * paragraph, a bullet symbol is displayed. The default value is
	 * <code>null</code>, which means no bulleted list is used.]]></haxe_doc>
		</bullet>
		<bold public="1">
			<t path="Null"><x path="Bool"/></t>
			<haxe_doc><![CDATA[* Specifies whether the text is boldface. The default value is
	 * <code>null</code>, which means no boldface is used. If the value is
	 * <code>true</code>, then the text is boldface.]]></haxe_doc>
		</bold>
		<blockIndent public="1">
			<t path="Null"><x path="Float"/></t>
			<haxe_doc><![CDATA[* Indicates the block indentation in pixels. Block indentation is applied to
	 * an entire block of text; that is, to all lines of the text. In contrast,
	 * normal indentation(<code>TextFormat.indent</code>) affects only the first
	 * line of each paragraph. If this property is <code>null</code>, the
	 * TextFormat object does not specify block indentation(block indentation is
	 * 0).]]></haxe_doc>
		</blockIndent>
		<align public="1">
			<e path="flash.text.TextFormatAlign"/>
			<haxe_doc><![CDATA[* Indicates the alignment of the paragraph. Valid values are TextFormatAlign
	 * constants.
	 * 
	 * @default TextFormatAlign.LEFT
	 * @throws ArgumentError The <code>align</code> specified is not a member of
	 *                       flash.text.TextFormatAlign.]]></haxe_doc>
		</align>
		<new public="1" set="method">
			<f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
				<c path="String"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="String"/>
				<e path="flash.text.TextFormatAlign"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a TextFormat object with the specified properties. You can then
	 * change the properties of the TextFormat object to change the formatting of
	 * text fields.
	 *
	 * <p>Any parameter may be set to <code>null</code> to indicate that it is
	 * not defined. All of the parameters are optional; any omitted parameters
	 * are treated as <code>null</code>.</p>
	 * 
	 * @param font        The name of a font for text as a string.
	 * @param size        An integer that indicates the size in pixels.
	 * @param color       The color of text using this text format. A number
	 *                    containing three 8-bit RGB components; for example,
	 *                    0xFF0000 is red, and 0x00FF00 is green.
	 * @param bold        A Boolean value that indicates whether the text is
	 *                    boldface.
	 * @param italic      A Boolean value that indicates whether the text is
	 *                    italicized.
	 * @param underline   A Boolean value that indicates whether the text is
	 *                    underlined.
	 * @param url         The URL to which the text in this text format
	 *                    hyperlinks. If <code>url</code> is an empty string, the
	 *                    text does not have a hyperlink.
	 * @param target      The target window where the hyperlink is displayed. If
	 *                    the target window is an empty string, the text is
	 *                    displayed in the default target window
	 *                    <code>_self</code>. If the <code>url</code> parameter
	 *                    is set to an empty string or to the value
	 *                    <code>null</code>, you can get or set this property,
	 *                    but the property will have no effect.
	 * @param align       The alignment of the paragraph, as a TextFormatAlign
	 *                    value.
	 * @param leftMargin  Indicates the left margin of the paragraph, in pixels.
	 * @param rightMargin Indicates the right margin of the paragraph, in pixels.
	 * @param indent      An integer that indicates the indentation from the left
	 *                    margin to the first character in the paragraph.
	 * @param leading     A number that indicates the amount of leading vertical
	 *                    space between lines.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The TextFormat class represents character formatting information. Use the
 * TextFormat class to create specific text formatting for text fields. You
 * can apply text formatting to both static and dynamic text fields. The
 * properties of the TextFormat class apply to device and embedded fonts.
 * However, for embedded fonts, bold and italic text actually require specific
 * fonts. If you want to display bold or italic text with an embedded font,
 * you need to embed the bold and italic variations of that font.
 *
 * <p> You must use the constructor <code>new TextFormat()</code> to create a
 * TextFormat object before setting its properties. When you apply a
 * TextFormat object to a text field using the
 * <code>TextField.defaultTextFormat</code> property or the
 * <code>TextField.setTextFormat()</code> method, only its defined properties
 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
 * by default because if you don't provide values for the properties, Flash
 * Player uses its own default formatting. The default formatting that Flash
 * Player uses for each property(if property's value is <code>null</code>) is
 * as follows:</p>
 *
 * <p>The default formatting for each property is also described in each
 * property description.</p>]]></haxe_doc>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/TextFormatAlign.hx">
		<CENTER><haxe_doc><![CDATA[* Constant; centers the text in the text field. Use the syntax
	 * <code>TextFormatAlign.CENTER</code>.]]></haxe_doc></CENTER>
		<JUSTIFY><haxe_doc><![CDATA[* Constant; justifies text within the text field. Use the syntax
	 * <code>TextFormatAlign.JUSTIFY</code>.]]></haxe_doc></JUSTIFY>
		<LEFT><haxe_doc><![CDATA[* Constant; aligns text to the left within the text field. Use the syntax
	 * <code>TextFormatAlign.LEFT</code>.]]></haxe_doc></LEFT>
		<RIGHT><haxe_doc><![CDATA[* Constant; aligns text to the right within the text field. Use the syntax
	 * <code>TextFormatAlign.RIGHT</code>.]]></haxe_doc></RIGHT>
		<haxe_doc>* The TextFormatAlign class provides values for text alignment in the
 * TextFormat class.</haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The x value is the left position of the first character in pixels. This
         * value includes the margin, indent (if any), and gutter widths.</haxe_doc>
		</x>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width value is the width of the text of the selected lines (not 
         * necessarily the complete text) in pixels. The width of the text line is
         * not the same as the width of the text field. The width of the text line is
         * relative to the text field width, minus the gutter width of 4 pixels 
         * (2 pixels on each side).</haxe_doc>
		</width>
		<leading public="1">
			<x path="Float"/>
			<haxe_doc>* The leading value is the measurement of the vertical distance between the
         * lines of text.</haxe_doc>
		</leading>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height value of the text of the selected lines (not necessarily the
         * complete text) in pixels. The height of the text line does not include the
         * gutter height.</haxe_doc>
		</height>
		<descent public="1">
			<x path="Float"/>
			<haxe_doc>* The descent value of the text is the length from the baseline to the
	 * bottom depth of the line in pixels.</haxe_doc>
		</descent>
		<ascent public="1">
			<x path="Float"/>
			<haxe_doc>* The ascent value of the text is the length from the baseline to the top of
         * the line height in pixels.</haxe_doc>
		</ascent>
		<new public="1" set="method">
			<f a="?x:?width:?height:?ascent:?descent:?leading">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a TextLineMetrics object. The TextLineMetrics object contains
         * information about the text metrics of a line of text in a text field.
         * Objects of this class are returned by the 
         * flash.text.TextField.getLineMetrics() method.
	 *
	 * @param x           The left position of the first character in pixels.
	 * @param width       The width of the text of the selected lines (not 
         *                    necessarily the complete text) in pixels.
	 * @param height      The height of the text of the selected lines (not
         *                    necessarily the complete text) in pixels.
	 * @param ascent      The length from the baseline to the top of the line
         *                    height in pixels.
	 * @param descent     The length from the baseline to the bottom depth of
         *                    the line in pixels.
	 * @param leading     The measurement of the vertical distance between the
         *                    lines of text.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The TextLineMetrics class contains information about the text position and
 * measurements of a line of text within a text field. All measurements are in
 * pixels. Objects of this class are returned by the 
 * <code>flash.text.TextField.getLineMetrics()</code> method.]]></haxe_doc>
	</class>
	<class path="flash.ui.Keyboard" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/ui/Keyboard.hx" extern="1">
		<BACKSPACE public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Backspace key(8).</haxe_doc>
		</BACKSPACE>
		<CAPS_LOCK public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Caps Lock key(20).</haxe_doc>
		</CAPS_LOCK>
		<CONTROL public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Control key(17).</haxe_doc>
		</CONTROL>
		<DELETE public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Delete key(46).</haxe_doc>
		</DELETE>
		<DOWN public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Down Arrow key(40).</haxe_doc>
		</DOWN>
		<END public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the End key(35).</haxe_doc>
		</END>
		<ENTER public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Enter key(13).</haxe_doc>
		</ENTER>
		<ESCAPE public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Escape key(27).</haxe_doc>
		</ESCAPE>
		<F1 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F1 key(112).</haxe_doc>
		</F1>
		<F10 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F10 key(121).</haxe_doc>
		</F10>
		<F11 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F11 key(122).</haxe_doc>
		</F11>
		<F12 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F12 key(123).</haxe_doc>
		</F12>
		<F13 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F13 key(124).</haxe_doc>
		</F13>
		<F14 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F14 key(125).</haxe_doc>
		</F14>
		<F15 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F15 key(126).</haxe_doc>
		</F15>
		<F2 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F2 key(113).</haxe_doc>
		</F2>
		<F3 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F3 key(114).</haxe_doc>
		</F3>
		<F4 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F4 key(115).</haxe_doc>
		</F4>
		<F5 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F5 key(116).</haxe_doc>
		</F5>
		<F6 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F6 key(117).</haxe_doc>
		</F6>
		<F7 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F7 key(118).</haxe_doc>
		</F7>
		<F8 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F8 key(119).</haxe_doc>
		</F8>
		<F9 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the F9 key(120).</haxe_doc>
		</F9>
		<HOME public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Engage help application or context-sensitive help</haxe_doc>
		</HOME>
		<INSERT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Info button</haxe_doc>
		</INSERT>
		<LEFT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Watch last channel or show watched</haxe_doc>
		</LEFT>
		<NUMPAD_0 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 0 key on the
	 * number pad(96).</haxe_doc>
		</NUMPAD_0>
		<NUMPAD_1 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 1 key on the
	 * number pad(97).</haxe_doc>
		</NUMPAD_1>
		<NUMPAD_2 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 2 key on the
	 * number pad(98).</haxe_doc>
		</NUMPAD_2>
		<NUMPAD_3 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 3 key on the
	 * number pad(99).</haxe_doc>
		</NUMPAD_3>
		<NUMPAD_4 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 4 key on the
	 * number pad(100).</haxe_doc>
		</NUMPAD_4>
		<NUMPAD_5 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 5 key on the
	 * number pad(101).</haxe_doc>
		</NUMPAD_5>
		<NUMPAD_6 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 6 key on the
	 * number pad(102).</haxe_doc>
		</NUMPAD_6>
		<NUMPAD_7 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 7 key on the
	 * number pad(103).</haxe_doc>
		</NUMPAD_7>
		<NUMPAD_8 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 8 key on the
	 * number pad(104).</haxe_doc>
		</NUMPAD_8>
		<NUMPAD_9 public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the number 9 key on the
	 * number pad(105).</haxe_doc>
		</NUMPAD_9>
		<NUMPAD_ADD public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the addition key on the
	 * number pad(107).</haxe_doc>
		</NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the decimal key on the
	 * number pad(110).</haxe_doc>
		</NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the division key on the
	 * number pad(111).</haxe_doc>
		</NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Enter key on the
	 * number pad(108).</haxe_doc>
		</NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the multiplication key on
	 * the number pad(106).</haxe_doc>
		</NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the subtraction key on the
	 * number pad(109).</haxe_doc>
		</NUMPAD_SUBTRACT>
		<PAGE_DOWN public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Page Down key(34).</haxe_doc>
		</PAGE_DOWN>
		<PAGE_UP public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Page Up key(33).</haxe_doc>
		</PAGE_UP>
		<RIGHT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Right Arrow key(39).</haxe_doc>
		</RIGHT>
		<SHIFT public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Shift key(16).</haxe_doc>
		</SHIFT>
		<SPACE public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Spacebar(32).</haxe_doc>
		</SPACE>
		<TAB public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Tab key(9).</haxe_doc>
		</TAB>
		<UP public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Constant associated with the key code value for the Up Arrow key(38).</haxe_doc>
		</UP>
		<haxe_doc>* The Keyboard class is used to build an interface that can be controlled by
 * a user with a standard keyboard. You can use the methods and properties of
 * the Keyboard class without using a constructor. The properties of the
 * Keyboard class are constants representing the keys that are most commonly
 * used to control games.</haxe_doc>
	</class>
	<class path="flash.ui.Mouse" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/ui/Mouse.hx" extern="1">
		<hide public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Indicates whether the current configuration supports native cursors.</haxe_doc>
		</hide>
		<show public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Registers a native cursor under the given name, with the given data.
	 * 
	 * @param name   The name to use as a reference to the native cursor
	 *               instance.
	 * @param cursor The properties for the native cursor, such as icon bitmap,
	 *               specified as a MouseCursorData instance.</haxe_doc>
		</show>
		<haxe_doc><![CDATA[* The methods of the Mouse class are used to hide and show the mouse pointer,
 * or to set the pointer to a specific style. The Mouse class is a top-level
 * class whose properties and methods you can access without using a
 * constructor. <ph outputclass="flashonly">The pointer is visible by default,
 * but you can hide it and implement a custom pointer.]]></haxe_doc>
	</class>
	<class path="flash.ui.MouseCursor" params="" file="/usr/lib/haxe/std/flash/ui/MouseCursor.hx" extern="1">
		<ARROW public="1" static="1"><c path="String"/></ARROW>
		<AUTO public="1" static="1"><c path="String"/></AUTO>
		<BUTTON public="1" static="1"><c path="String"/></BUTTON>
		<HAND public="1" static="1"><c path="String"/></HAND>
		<IBEAM public="1" static="1"><c path="String"/></IBEAM>
	</class>
	<class path="flash.ui.MouseCursorData" params="" file="/usr/lib/haxe/std/flash/ui/MouseCursorData.hx" extern="1">
		<hotSpot public="1"><c path="flash.geom.Point"/></hotSpot>
		<frameRate public="1"><x path="Float"/></frameRate>
		<data public="1"><c path="flash.Vector"><c path="flash.display.BitmapData"/></c></data>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<class path="flash.ui.Multitouch" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/ui/Multitouch.hx" extern="1">
		<haxe_doc><![CDATA[* The Multitouch class manages and provides information about the current
 * environment's support for handling contact from user input devices,
 * including contact that has two or more touch points(such as a user's
 * fingers on a touch screen). When a user interacts with a device such as a
 * mobile phone or tablet with a touch screen, the user typically touches the
 * screen with his or her fingers or a pointing device. While there is a broad
 * range of pointing devices, such as a mouse or a stylus, many of these
 * devices only have a single point of contact with an application. For
 * pointing devices with a single point of contact, user interaction events
 * can be handled as a mouse event, or using a basic set of touch events
 * (called "touch point" events). However, for pointing devices that have
 * several points of contact and perform complex movement, such as the human
 * hand, Flash runtimes support an additional set of event handling API called
 * gesture events. The API for handling user interaction with these gesture
 * events includes the following classes:
 *
 * <p>
 * <ul>
 *   <li>flash.events.TouchEvent</li>
 *   <li>flash.events.GestureEvent</li>
 *   <li>flash.events.GesturePhase</li>
 *   <li>flash.events.TransformGestureEvent</li>
 *   <li>flash.events.PressAndTapGestureEvent</li>
 * </ul>
 * </p>
 *
 * <p>Use the listed classes to write code that handles touch events. Use the
 * Multitouch class to determine the current environment's support for touch
 * interaction, and to manage the support of touch interaction if the current
 * environment supports touch input.</p>
 *
 * <p>You cannot create a Multitouch object directly from ActionScript code.
 * If you call <code>new Multitouch()</code>, an exception is thrown.</p>
 *
 * <p><b>Note:</b> The Multitouch feature is not supported for SWF files
 * embedded in HTML running on Mac OS.</p>]]></haxe_doc>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<enum path="flash.ui.MultitouchInputMode" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/ui/MultitouchInputMode.hx">
		<GESTURE><haxe_doc>* Specifies that TransformGestureEvent, PressAndTapGestureEvent, and
	 * GestureEvent events are dispatched for the related user interaction
	 * supported by the current environment, and other touch events(such as a
	 * simple tap) are interpreted as mouse events.</haxe_doc></GESTURE>
		<NONE><haxe_doc>* Specifies that all user contact with a touch-enabled device is interpreted
	 * as a type of mouse event.</haxe_doc></NONE>
		<TOUCH_POINT/>
		<haxe_doc><![CDATA[* The MultitouchInputMode class provides values for the
 * <code>inputMode</code> property in the flash.ui.Multitouch class. These
 * values set the type of touch events the Flash runtime dispatches when the
 * user interacts with a touch-enabled device.]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<class path="flash.utils.IDataInput" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="Int"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="Int"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><x path="Int"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="Int"/></bytesAvailable>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput"/>
		<defaultObjectEncoding public="1" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Denotes the default object encoding for the ByteArray class to use for a
	 * new ByteArray instance. When you create a new ByteArray instance, the
	 * encoding on that instance starts with the value of
	 * <code>defaultObjectEncoding</code>. The <code>defaultObjectEncoding</code>
	 * property is initialized to <code>ObjectEncoding.AMF3</code>.
	 *
	 * <p>When an object is written to or read from binary data, the
	 * <code>objectEncoding</code> value is used to determine whether the
	 * ActionScript 3.0, ActionScript2.0, or ActionScript 1.0 format should be
	 * used. The value is a constant from the ObjectEncoding class.</p>]]></haxe_doc>
		</defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a 32-bit unsigned integer to the byte stream.
	 * 
	 * @param value An unsigned integer to write to the byte stream.</haxe_doc>
		</writeUnsignedInt>
		<writeUTFBytes public="1" set="method">
			<f a="value">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Writes a UTF-8 string to the byte stream. Similar to the
	 * <code>writeUTF()</code> method, but <code>writeUTFBytes()</code> does not
	 * prefix the string with a 16-bit length word.
	 * 
	 * @param value The string value to be written.]]></haxe_doc>
		</writeUTFBytes>
		<writeUTF public="1" set="method">
			<f a="value">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a UTF-8 string to the byte stream. The length of the UTF-8 string
	 * in bytes is written first, as a 16-bit integer, followed by the bytes
	 * representing the characters of the string.
	 * 
	 * @param value The string value to be written.
	 * @throws RangeError If the length is larger than 65535.</haxe_doc>
		</writeUTF>
		<writeShort public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a 16-bit integer to the byte stream. The low 16 bits of the
	 * parameter are used. The high 16 bits are ignored.
	 * 
	 * @param value 32-bit integer, whose low 16 bits are written to the byte
	 *              stream.</haxe_doc>
		</writeShort>
		<writeObject public="1" set="method">
			<f a="object">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes an object into the byte array in AMF serialized format.
	 * 
	 * @param object The object to serialize.</haxe_doc>
		</writeObject>
		<writeMultiByte public="1" set="method">
			<f a="value:charSet">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Writes a multibyte string to the byte stream using the specified character
	 * set.
	 * 
	 * @param value   The string value to be written.
	 * @param charSet The string denoting the character set to use. Possible
	 *                character set strings include <code>"shift-jis"</code>,
	 *                <code>"cn-gb"</code>, <code>"iso-8859-1"</code>, and
	 *                others. For a complete list, see <a
	 *                href="../../charset-codes.html">Supported Character
	 *                Sets</a>.]]></haxe_doc>
		</writeMultiByte>
		<writeInt public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a 32-bit signed integer to the byte stream.
	 * 
	 * @param value An integer to write to the byte stream.</haxe_doc>
		</writeInt>
		<writeFloat public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes an IEEE 754 single-precision(32-bit) floating-point number to the
	 * byte stream.
	 * 
	 * @param value A single-precision(32-bit) floating-point number.</haxe_doc>
		</writeFloat>
		<writeDouble public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes an IEEE 754 double-precision(64-bit) floating-point number to the
	 * byte stream.
	 * 
	 * @param value A double-precision(64-bit) floating-point number.</haxe_doc>
		</writeDouble>
		<writeBytes public="1" set="method">
			<f a="bytes:?offset:?length">
				<c path="flash.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Writes a sequence of <code>length</code> bytes from the specified byte
	 * array, <code>bytes</code>, starting <code>offset</code>(zero-based index)
	 * bytes into the byte stream.
	 *
	 * <p>If the <code>length</code> parameter is omitted, the default length of
	 * 0 is used; the method writes the entire buffer starting at
	 * <code>offset</code>. If the <code>offset</code> parameter is also omitted,
	 * the entire buffer is written. </p>
	 *
	 * <p>If <code>offset</code> or <code>length</code> is out of range, they are
	 * clamped to the beginning and end of the <code>bytes</code> array.</p>
	 * 
	 * @param bytes  The ByteArray object.
	 * @param offset A zero-based index indicating the position into the array to
	 *               begin writing.
	 * @param length An unsigned integer indicating how far into the buffer to
	 *               write.]]></haxe_doc>
		</writeBytes>
		<writeByte public="1" set="method">
			<f a="value">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Writes a byte to the byte stream.
	 *
	 * <p>The low 8 bits of the parameter are used. The high 24 bits are ignored.
	 * </p>
	 * 
	 * @param value A 32-bit integer. The low 8 bits are written to the byte
	 *              stream.]]></haxe_doc>
		</writeByte>
		<writeBoolean public="1" set="method">
			<f a="value">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Writes a Boolean value. A single byte is written according to the
	 * <code>value</code> parameter, either 1 if <code>true</code> or 0 if
	 * <code>false</code>.
	 * 
	 * @param value A Boolean value determining which byte is written. If the
	 *              parameter is <code>true</code>, the method writes a 1; if
	 *              <code>false</code>, the method writes a 0.]]></haxe_doc>
		</writeBoolean>
		<uncompress public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Decompresses the byte array. For content running in Adobe AIR, you can
	 * specify a compression algorithm by passing a value(defined in the
	 * CompressionAlgorithm class) as the <code>algorithm</code> parameter. The
	 * byte array must have been compressed using the same algorithm. Flash
	 * Player supports only the default algorithm, zlib.
	 *
	 * <p>After the call, the <code>length</code> property of the ByteArray is
	 * set to the new length. The <code>position</code> property is set to 0.</p>
	 *
	 * <p>The zlib compressed data format is described at <a
	 * href="http://www.ietf.org/rfc/rfc1950.txt"
	 * scope="external">http://www.ietf.org/rfc/rfc1950.txt</a>.</p>
	 *
	 * <p>The deflate compression algorithm is described at <a
	 * href="http://www.ietf.org/rfc/rfc1951.txt"
	 * scope="external">http://www.ietf.org/rfc/rfc1951.txt</a>.</p>
	 *
	 * <p>In order to decode data compressed in a format that uses the deflate
	 * compression algorithm, such as data in gzip or zip format, it will not
	 * work to call <code>uncompress(CompressionAlgorithm.DEFLATE)</code> on a
	 * ByteArray containing the compression formation data. First, you must
	 * separate the metadata that is included as part of the compressed data
	 * format from the actual compressed data. For more information, see the
	 * <code>compress()</code> method description.</p>
	 * 
	 * @throws IOError The data is not valid compressed data; it was not
	 *                 compressed with the same compression algorithm used to
	 *                 compress.]]></haxe_doc>
		</uncompress>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Converts the byte array to a string. If the data in the array begins with
	 * a Unicode byte order mark, the application will honor that mark when
	 * converting to a string. If <code>System.useCodePage</code> is set to
	 * <code>true</code>, the application will treat the data in the array as
	 * being in the current system code page when converting.
	 * 
	 * @return The string representation of the byte array.]]></haxe_doc>
		</toString>
		<readUnsignedShort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Reads an unsigned 16-bit integer from the byte stream.
	 *
	 * <p>The returned value is in the range 0 to 65535. </p>
	 * 
	 * @return A 16-bit unsigned integer between 0 and 65535.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readUnsignedShort>
		<readUnsignedInt public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Reads an unsigned 32-bit integer from the byte stream.
	 *
	 * <p>The returned value is in the range 0 to 4294967295. </p>
	 * 
	 * @return A 32-bit unsigned integer between 0 and 4294967295.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readUnsignedInt>
		<readUnsignedByte public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Reads an unsigned byte from the byte stream.
	 *
	 * <p>The returned value is in the range 0 to 255. </p>
	 * 
	 * @return A 32-bit unsigned integer between 0 and 255.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readUnsignedByte>
		<readUTFBytes public="1" set="method">
			<f a="length">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Reads a sequence of UTF-8 bytes specified by the <code>length</code>
	 * parameter from the byte stream and returns a string.
	 * 
	 * @param length An unsigned short indicating the length of the UTF-8 bytes.
	 * @return A string composed of the UTF-8 bytes of the specified length.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readUTFBytes>
		<readUTF public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Reads a UTF-8 string from the byte stream. The string is assumed to be
	 * prefixed with an unsigned short indicating the length in bytes.
	 * 
	 * @return UTF-8 encoded string.
	 * @throws EOFError There is not sufficient data available to read.</haxe_doc>
		</readUTF>
		<readShort public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Reads a signed 16-bit integer from the byte stream.
	 *
	 * <p>The returned value is in the range -32768 to 32767.</p>
	 * 
	 * @return A 16-bit signed integer between -32768 and 32767.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readShort>
		<readObject public="1" set="method">
			<f a=""><d/></f>
			<haxe_doc>* Reads an object from the byte array, encoded in AMF serialized format.
	 * 
	 * @return The deserialized object.
	 * @throws EOFError There is not sufficient data available to read.</haxe_doc>
		</readObject>
		<readMultiByte public="1" set="method">
			<f a="length:charSet">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Reads a multibyte string of specified length from the byte stream using
	 * the specified character set.
	 * 
	 * @param length  The number of bytes from the byte stream to read.
	 * @param charSet The string denoting the character set to use to interpret
	 *                the bytes. Possible character set strings include
	 *                <code>"shift-jis"</code>, <code>"cn-gb"</code>,
	 *                <code>"iso-8859-1"</code>, and others. For a complete list,
	 *                see <a href="../../charset-codes.html">Supported Character
	 *                Sets</a>.
	 *
	 *                <p><b>Note:</b> If the value for the <code>charSet</code>
	 *                parameter is not recognized by the current system, the
	 *                application uses the system's default code page as the
	 *                character set. For example, a value for the
	 *                <code>charSet</code> parameter, as in
	 *                <code>myTest.readMultiByte(22, "iso-8859-01")</code> that
	 *                uses <code>01</code> instead of <code>1</code> might work
	 *                on your development system, but not on another system. On
	 *                the other system, the application will use the system's
	 *                default code page.</p>
	 * @return UTF-8 encoded string.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readMultiByte>
		<readInt public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Reads a signed 32-bit integer from the byte stream.
	 *
	 * <p>The returned value is in the range -2147483648 to 2147483647.</p>
	 * 
	 * @return A 32-bit signed integer between -2147483648 and 2147483647.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readInt>
		<readFloat public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Reads an IEEE 754 single-precision(32-bit) floating-point number from the
	 * byte stream.
	 * 
	 * @return A single-precision(32-bit) floating-point number.
	 * @throws EOFError There is not sufficient data available to read.</haxe_doc>
		</readFloat>
		<readDouble public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Reads an IEEE 754 double-precision(64-bit) floating-point number from the
	 * byte stream.
	 * 
	 * @return A double-precision(64-bit) floating-point number.
	 * @throws EOFError There is not sufficient data available to read.</haxe_doc>
		</readDouble>
		<readBytes public="1" set="method">
			<f a="bytes:?offset:?length">
				<c path="flash.utils.ByteArray"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Reads the number of data bytes, specified by the <code>length</code>
	 * parameter, from the byte stream. The bytes are read into the ByteArray
	 * object specified by the <code>bytes</code> parameter, and the bytes are
	 * written into the destination ByteArray starting at the position specified
	 * by <code>offset</code>.
	 * 
	 * @param bytes  The ByteArray object to read data into.
	 * @param offset The offset(position) in <code>bytes</code> at which the
	 *               read data should be written.
	 * @param length The number of bytes to read. The default value of 0 causes
	 *               all available data to be read.
	 * @throws EOFError   There is not sufficient data available to read.
	 * @throws RangeError The value of the supplied offset and length, combined,
	 *                    is greater than the maximum for a uint.]]></haxe_doc>
		</readBytes>
		<readByte public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Reads a signed byte from the byte stream.
	 *
	 * <p>The returned value is in the range -128 to 127.</p>
	 * 
	 * @return An integer between -128 and 127.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readByte>
		<readBoolean public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* Reads a Boolean value from the byte stream. A single byte is read, and
	 * <code>true</code> is returned if the byte is nonzero, <code>false</code>
	 * otherwise.
	 * 
	 * @return Returns <code>true</code> if the byte is nonzero,
	 *         <code>false</code> otherwise.
	 * @throws EOFError There is not sufficient data available to read.]]></haxe_doc>
		</readBoolean>
		<compress public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Compresses the byte array. The entire byte array is compressed. For
	 * content running in Adobe AIR, you can specify a compression algorithm by
	 * passing a value(defined in the CompressionAlgorithm class) as the
	 * <code>algorithm</code> parameter. Flash Player supports only the default
	 * algorithm, zlib.
	 *
	 * <p>After the call, the <code>length</code> property of the ByteArray is
	 * set to the new length. The <code>position</code> property is set to the
	 * end of the byte array.</p>
	 *
	 * <p>The zlib compressed data format is described at <a
	 * href="http://www.ietf.org/rfc/rfc1950.txt"
	 * scope="external">http://www.ietf.org/rfc/rfc1950.txt</a>.</p>
	 *
	 * <p>The deflate compression algorithm is described at <a
	 * href="http://www.ietf.org/rfc/rfc1951.txt"
	 * scope="external">http://www.ietf.org/rfc/rfc1951.txt</a>.</p>
	 *
	 * <p>The deflate compression algorithm is used in several compression
	 * formats, such as zlib, gzip, some zip implementations, and others. When
	 * data is compressed using one of those compression formats, in addition to
	 * storing the compressed version of the original data, the compression
	 * format data(for example, the .zip file) includes metadata information.
	 * Some examples of the types of metadata included in various file formats
	 * are file name, file modification date/time, original file size, optional
	 * comments, checksum data, and more.</p>
	 *
	 * <p>For example, when a ByteArray is compressed using the zlib algorithm,
	 * the resulting ByteArray is structured in a specific format. Certain bytes
	 * contain metadata about the compressed data, while other bytes contain the
	 * actual compressed version of the original ByteArray data. As defined by
	 * the zlib compressed data format specification, those bytes(that is, the
	 * portion containing the compressed version of the original data) are
	 * compressed using the deflate algorithm. Consequently those bytes are
	 * identical to the result of calling <code>compress(<ph
	 * outputclass="javascript">air.CompressionAlgorithm.DEFLATE)</code> on the
	 * original ByteArray. However, the result from <code>compress(<ph
	 * outputclass="javascript">air.CompressionAlgorithm.ZLIB)</code> includes
	 * the extra metadata, while the
	 * <code>compress(CompressionAlgorithm.DEFLATE)</code> result includes only
	 * the compressed version of the original ByteArray data and nothing
	 * else.</p>
	 *
	 * <p>In order to use the deflate format to compress a ByteArray instance's
	 * data in a specific format such as gzip or zip, you cannot simply call
	 * <code>compress(CompressionAlgorithm.DEFLATE)</code>. You must create a
	 * ByteArray structured according to the compression format's specification,
	 * including the appropriate metadata as well as the compressed data obtained
	 * using the deflate format. Likewise, in order to decode data compressed in
	 * a format such as gzip or zip, you can't simply call
	 * <code>uncompress(CompressionAlgorithm.DEFLATE)</code> on that data. First,
	 * you must separate the metadata from the compressed data, and you can then
	 * use the deflate format to decompress the compressed data.</p>
	 *]]></haxe_doc>
		</compress>
		<position public="1">
			<x path="Int"/>
			<haxe_doc>* Moves, or returns the current position, in bytes, of the file pointer into
	 * the ByteArray object. This is the point at which the next call to a read
	 * method starts reading or a write method starts writing.</haxe_doc>
		</position>
		<objectEncoding public="1">
			<x path="Int"/>
			<haxe_doc>* Used to determine whether the ActionScript 3.0, ActionScript 2.0, or
	 * ActionScript 1.0 format should be used when writing to, or reading from, a
	 * ByteArray instance. The value is a constant from the ObjectEncoding class.</haxe_doc>
		</objectEncoding>
		<length public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The length of the ByteArray object, in bytes.
	 *
	 * <p>If the length is set to a value that is larger than the current length,
	 * the right side of the byte array is filled with zeros.</p>
	 *
	 * <p>If the length is set to a value that is smaller than the current
	 * length, the byte array is truncated.</p>]]></haxe_doc>
		</length>
		<endian public="1">
			<e path="flash.utils.Endian"/>
			<haxe_doc><![CDATA[* Changes or reads the byte order for the data; either
	 * <code>Endian.BIG_ENDIAN</code> or <code>Endian.LITTLE_ENDIAN</code>.]]></haxe_doc>
		</endian>
		<bytesAvailable public="1" set="null">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The number of bytes of data available for reading from the current
	 * position in the byte array to the end of the array.
	 *
	 * <p>Use the <code>bytesAvailable</code> property in conjunction with the
	 * read methods each time you access a ByteArray object to ensure that you
	 * are reading valid data.</p>]]></haxe_doc>
		</bytesAvailable>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a ByteArray instance representing a packed array of bytes, so that
	 * you can use the methods and properties in this class to optimize your data
	 * storage and stream.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The ByteArray class provides methods and properties to optimize reading,
 * writing, and working with binary data.
 *
 * <p><i>Note:</i> The ByteArray class is for advanced developers who need to
 * access data on the byte level.</p>
 *
 * <p>In-memory data is a packed array(the most compact representation for
 * the data type) of bytes, but an instance of the ByteArray class can be
 * manipulated with the standard <code>[]</code>(array access) operators. It
 * also can be read and written to as an in-memory file, using methods similar
 * to those in the URLStream and Socket classes.</p>
 *
 * <p>In addition, zlib compression and decompression are supported, as well
 * as Action Message Format(AMF) object serialization.</p>
 *
 * <p>Possible uses of the ByteArray class include the following:
 * <ul>
 *   <li>Creating a custom protocol to connect to a server.</li>
 *   <li>Writing your own URLEncoder/URLDecoder.</li>
 *   <li>Writing your own AMF/Remoting packet.</li>
 *   <li>Optimizing the size of your data by using data types.</li>
 *   <li>Working with binary data loaded from a file in Adobe<sup>®</sup>
 * AIR<sup>®</sup>.</li>
 * </ul>
 * </p>]]></haxe_doc>
	</class>
	<enum path="flash.utils.Endian" params="" file="/media/psf/Home/projects/repos/public/openfl/flash/utils/Endian.hx">
		<BIG_ENDIAN/>
		<LITTLE_ENDIAN/>
		<haxe_doc><![CDATA[* The Endian class contains values that denote the byte order used to
 * represent multibyte numbers. The byte order is either bigEndian(most
 * significant byte first) or littleEndian(least significant byte first).
 *
 * <p>Content in Flash Player or Adobe<sup>®</sup> AIR™ can interface with
 * a server by using the binary protocol of that server, directly. Some
 * servers use the bigEndian byte order and some servers use the littleEndian
 * byte order. Most servers on the Internet use the bigEndian byte order
 * because "network byte order" is bigEndian. The littleEndian byte order is
 * popular because the Intel x86 architecture uses it. Use the endian byte
 * order that matches the protocol of the server that is sending or receiving
 * data.</p>]]></haxe_doc>
		<meta>
			<m n=":flatEnum"/>
			<m n=":fakeEnum"><e>String</e></m>
		</meta>
	</enum>
	<typedef path="flash.utils.Object" params="" file="/usr/lib/haxe/std/flash/utils/Object.hx"><d/></typedef>
	<class path="flixel.IFlxBasic" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxBasic.hx" module="flixel.FlxBasic" interface="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<revive public="1" set="method"><f a=""><x path="Void"/></f></revive>
		<kill public="1" set="method"><f a=""><x path="Void"/></f></kill>
		<drawDebugOnCamera public="1" set="method"><f a="?Camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawDebugOnCamera>
		<drawDebug public="1" set="method"><f a=""><x path="Void"/></f></drawDebug>
		<draw public="1" set="method"><f a=""><x path="Void"/></f></draw>
		<update public="1" set="method"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<ignoreDrawDebug public="1"><x path="Bool"/></ignoreDrawDebug>
		<cameras public="1"><c path="Array"><c path="flixel.FlxCamera"/></c></cameras>
		<visible public="1"><x path="Bool"/></visible>
		<active public="1"><x path="Bool"/></active>
		<alive public="1"><x path="Bool"/></alive>
		<exists public="1"><x path="Bool"/></exists>
		<ID public="1"><x path="Int"/></ID>
		<haxe_doc><![CDATA[*  This class is for <code>FlxTypedGroup</code> to work with interface instead of <code>FlxBasic</code>, which is needed
 *  so that <code>FlxSpriteGroup</code> could extend <code>FlxTypedGroup</code> and be typed with <code>IFlxSprite</code>]]></haxe_doc>
	</class>
	<class path="flixel.FlxBasic" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxBasic.hx">
		<implements path="flixel.IFlxBasic"/>
		<_ACTIVECOUNT public="1" line="42" static="1"><x path="Int"/></_ACTIVECOUNT>
		<_VISIBLECOUNT public="1" line="43" static="1"><x path="Int"/></_VISIBLECOUNT>
		<toString public="1" set="method" line="173">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name.  Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<revive public="1" set="method" line="164">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Handy function for bringing game objects "back to life". Just sets alive and exists back to true.
	 * In practice, this function is most often called by <code>FlxObject.reset()</code>.]]></haxe_doc>
		</revive>
		<kill public="1" set="method" line="154">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Handy function for "killing" game objects. Use <code>reset()</code> to revive them. Default behavior is to flag them as nonexistent AND dead. However, if you want the 
	 * "corpse" to remain in the game, like to animate an effect or whatever, you should override this, setting only alive to false, and leaving exists true.]]></haxe_doc>
		</kill>
		<drawDebugOnCamera public="1" set="method" line="147">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's visual mode is toggled on.
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebugOnCamera>
		<drawDebug public="1" set="method" line="125"><f a=""><x path="Void"/></f></drawDebug>
		<draw public="1" set="method" line="105">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Override this function to control how the object is drawn.
	 * Overriding <code>draw()</code> is rarely necessary, but can be very useful.]]></haxe_doc>
		</draw>
		<update public="1" set="method" line="94">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="88">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* WARNING: This will remove this object entirely. Use <code>kill()</code> if you want to disable it temporarily only and <code>reset()</code> it later to revive it.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!]]></haxe_doc>
		</destroy>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.</haxe_doc>
		</ignoreDrawDebug>
		<cameras public="1">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc><![CDATA[* An array of camera objects that this object will use during <code>draw()</code>. This value will initialize itself during the first draw to automatically
	 * point at the main camera list out in <code>FlxG</code> unless you already set it. You can also change it afterward too, very flexible!]]></haxe_doc>
		</cameras>
		<alive public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Useful state for many game objects - "dead" (!alive) vs alive.
	 * <code>kill()</code> and <code>revive()</code> both flip this switch (along with exists, but you can override that).]]></haxe_doc>
		</alive>
		<visible public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>draw()</code> is automatically called by FlxState/FlxGroup.]]></haxe_doc>
		</visible>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update()</code> is automatically called by FlxState/FlxGroup.]]></haxe_doc>
		</active>
		<exists public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Controls whether <code>update()</code> and <code>draw()</code> are automatically called by FlxState/FlxGroup.]]></haxe_doc>
		</exists>
		<ID public="1">
			<x path="Int"/>
			<haxe_doc>* IDs seem like they could be pretty useful, huh?
	 * They're not actually used for anything yet though.</haxe_doc>
		</ID>
		<new public="1" set="method" line="82"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* This is a useful "generic" Flixel object. Both <code>FlxObject</code> and 
 * <code>FlxGroup</code> extend this class. Has no size, position or graphical data.]]></haxe_doc>
	</class>
	<class path="flixel.FlxCamera" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxCamera.hx">
		<extends path="flixel.FlxBasic"/>
		<STYLE_LOCKON public="1" get="inline" set="null" line="30" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera has no deadzone, just tracks the focus object directly.</haxe_doc>
		</STYLE_LOCKON>
		<STYLE_PLATFORMER public="1" get="inline" set="null" line="34" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is narrow but tall.</haxe_doc>
		</STYLE_PLATFORMER>
		<STYLE_TOPDOWN public="1" get="inline" set="null" line="38" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is a medium-size square around the focus object.</haxe_doc>
		</STYLE_TOPDOWN>
		<STYLE_TOPDOWN_TIGHT public="1" get="inline" set="null" line="42" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera deadzone is a small square around the focus object.</haxe_doc>
		</STYLE_TOPDOWN_TIGHT>
		<STYLE_SCREEN_BY_SCREEN public="1" get="inline" set="null" line="46" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera will move screenwise.</haxe_doc>
		</STYLE_SCREEN_BY_SCREEN>
		<STYLE_NO_DEAD_ZONE public="1" get="inline" set="null" line="50" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "follow" style preset: camera has no deadzone, just tracks the focus object directly and centers it.</haxe_doc>
		</STYLE_NO_DEAD_ZONE>
		<SHAKE_BOTH_AXES public="1" get="inline" set="null" line="54" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on both the X and Y axes.</haxe_doc>
		</SHAKE_BOTH_AXES>
		<SHAKE_HORIZONTAL_ONLY public="1" get="inline" set="null" line="58" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on the X axis only.</haxe_doc>
		</SHAKE_HORIZONTAL_ONLY>
		<SHAKE_VERTICAL_ONLY public="1" get="inline" set="null" line="62" static="1">
			<x path="Int"/>
			<haxe_doc>* Camera "shake" effect preset: shake camera on the Y axis only.</haxe_doc>
		</SHAKE_VERTICAL_ONLY>
		<defaultZoom public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* While you can alter the zoom of each camera after the fact,
	 * this variable determines what value the camera will start at when created.</haxe_doc>
		</defaultZoom>
		<_storageHead static="1">
			<c path="flixel.system.layer.DrawStackItem"/>
			<haxe_doc>* Draw stack items that can be reused</haxe_doc>
		</_storageHead>
		<setPosition public="1" get="inline" set="null" line="1281">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this camera.
	 * Handy since it only requires one line of code.
	 * @param	X	The new x position
	 * @param	Y	The new y position</haxe_doc>
		</setPosition>
		<setSize public="1" get="inline" set="null" line="1269">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * @param	Width	The new sprite width.
	 * @param	Height	The new sprite height.</haxe_doc>
		</setSize>
		<set_useBgAlphaBlending set="method" line="1236"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useBgAlphaBlending>
		<useBgAlphaBlending public="1" set="accessor">
			<x path="Bool"/>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* Whether to use alpha blending for camera's background fill or not. 
	 * Useful for flash target (and works only on this target). Default value is true.</haxe_doc>
		</useBgAlphaBlending>
		<set_height set="method" line="1199"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_height>
		<set_width set="method" line="1168"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_width>
		<drawFX public="1" set="method" line="1133">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal helper function, handles the actual drawing of all the special effects.</haxe_doc>
		</drawFX>
		<fill public="1" set="method" line="1101">
			<f a="Color:?BlendAlpha:?FxAlpha:?graphics">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Float"/>
				<c path="flash.display.Graphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fill the camera with the specified color.
	 * @param	Color		The color to fill with in 0xAARRGGBB hex format.
	 * @param	BlendAlpha	Whether to blend the alpha value or just wipe the previous contents.  Default is true.</haxe_doc>
		</fill>
		<getContainerSprite public="1" get="inline" set="null" line="1091">
			<f a=""><c path="flash.display.Sprite"/></f>
			<haxe_doc><![CDATA[* Fetches a reference to the Flash <code>Sprite</code> object
	 * that contains the camera display in the Flash display list.
	 * Uses include 3D projection, advanced display list modification, and more.
	 * NOTE: We don't recommend modifying this directly unless you are
	 * fairly experienced.  For simple changes to the camera display,
	 * like scaling, rotation, and color tinting, we recommend
	 * using the existing <code>FlxCamera</code> variables.
	 * @return	A Flash <code>Sprite</code> object containing the camera display.]]></haxe_doc>
		</getContainerSprite>
		<setScale public="1" set="method" line="1071"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setScale>
		<getScale public="1" get="inline" set="null" line="1066">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* The scale of the camera object, irrespective of zoom.
	 * Currently yields weird display results,
	 * since cameras aren't nested in an extra display object yet.</haxe_doc>
		</getScale>
		<set_antialiasing set="method" line="1052"><f a="Antialiasing">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_antialiasing>
		<antialiasing public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the camera display is smooth and filtered, or chunky and pixelated.
	 * Default behavior is chunky-style.</haxe_doc>
		</antialiasing>
		<set_color set="method" line="1023">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</set_color>
		<color public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The color tint of the camera display.
	 * (Internal, help with color transforming the flash bitmap.)</haxe_doc>
		</color>
		<set_angle set="method" line="1007"><f a="Angle">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<angle public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The angle of the camera display (in degrees).
	 * Currently yields weird display results,
	 * since cameras aren't nested in an extra display object yet.</haxe_doc>
		</angle>
		<set_alpha set="method" line="989">
			<f a="Alpha">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</set_alpha>
		<alpha public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* The alpha value of this camera display (a Number between 0.0 and 1.0).</haxe_doc>
		</alpha>
		<set_zoom set="method" line="967">
			<f a="Zoom">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* The zoom level of this camera. 1 = 1:1, 2 = 2x zoom, etc.
	 * Indicates how far the camera is zoomed in.</haxe_doc>
		</set_zoom>
		<zoom public="1" set="accessor"><x path="Float"/></zoom>
		<copyFrom public="1" set="method" line="928">
			<f a="Camera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.FlxCamera"/>
			</f>
			<haxe_doc><![CDATA[* Copy the bounds, focus object, and deadzone info from an existing camera.
	 * @param	Camera	The camera you want to copy from.
	 * @return	A reference to this <code>FlxCamera</code> object.]]></haxe_doc>
		</copyFrom>
		<stopFX public="1" set="method" line="914">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just turns off all the camera effects instantly.</haxe_doc>
		</stopFX>
		<shake public="1" set="method" line="898">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Direction">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A simple screen-shake effect.
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Direction	Whether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).</haxe_doc>
		</shake>
		<fade public="1" set="method" line="864">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The screen is gradually filled with this color.
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param   FadeIn      True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<flash public="1" set="method" line="840">
			<f a="?Color:?Duration:?OnComplete:?Force">
				<x path="Int"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The screen is filled with this color and gradually returns to normal.
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<setBounds public="1" set="method" line="819">
			<f a="?X:?Y:?Width:?Height:?UpdateWorld">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Specify the boundaries of the level or where the camera is allowed to move.
	 * @param	X				The smallest X value of your level (usually 0).
	 * @param	Y				The smallest Y value of your level (usually 0).
	 * @param	Width			The largest X value of your level (usually the level width).
	 * @param	Height			The largest Y value of your level (usually the level height).
	 * @param	UpdateWorld		Whether the global quad-tree's dimensions should be updated to match (default: false).</haxe_doc>
		</setBounds>
		<focusOn public="1" get="inline" set="null" line="806">
			<f a="point">
				<c path="flixel.util.FlxPoint"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Move the camera focus to this location instantly.
	 * @param	Point		Where you want the camera to focus.</haxe_doc>
		</focusOn>
		<followAdjust public="1" get="inline" set="null" line="797">
			<f a="?LeadX:?LeadY">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Specify an additional camera component - the velocity-based "lead",
	 * or amount the camera should track in front of a sprite.
	 * 
	 * @param	LeadX		Percentage of X velocity to add to the camera's motion.
	 * @param	LeadY		Percentage of Y velocity to add to the camera's motion.</haxe_doc>
		</followAdjust>
		<follow public="1" set="method" line="754">
			<f a="Target:?Style:?Offset:?Lerp">
				<c path="flixel.FlxObject"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Tells this camera object what <code>FlxObject</code> to track.
	 * @param	Target		The object you want the camera to track.  Set to null to not follow anything.
	 * @param	Style		Leverage one of the existing "deadzone" presets.  If you use a custom deadzone, ignore this parameter and manually specify the deadzone after calling <code>follow()</code>.
	 * @param	Offset		Offset the follow deadzone by a certain amount. Only applicable for STYLE_PLATFORMER and STYLE_LOCKON styles.
	 * @param	Lerp		How much lag the camera should have (can help smooth out the camera movement).]]></haxe_doc>
		</follow>
		<update public="1" set="method" line="560" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the camera scroll as well as special effects like screen-shake or fades.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="506" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_fxFadeIn>
			<x path="Bool"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeIn>
		<render public="1" set="method" line="354"><f a=""><x path="Void"/></f></render>
		<clearDrawStack public="1" set="method" line="329"><f a=""><x path="Void"/></f></clearDrawStack>
		<getDrawStackItem public="1" set="method" line="267"><f a="ObjGraphics:UseAlpha:?ObjAntialiasing">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="flixel.system.layer.DrawStackItem"/>
</f></getDrawStackItem>
		<_headOfDrawStack>
			<c path="flixel.system.layer.DrawStackItem"/>
			<haxe_doc>* Pointer to head of stack with draw items</haxe_doc>
		</_headOfDrawStack>
		<_currentStackItem>
			<c path="flixel.system.layer.DrawStackItem"/>
			<haxe_doc>* Currently used draw stack item</haxe_doc>
		</_currentStackItem>
		<_debugLayer public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* sprite for visual effects (flash and fade) and visual debug information (bounding boxes are drawn on it) for non-flash targets</haxe_doc>
		</_debugLayer>
		<_canvas public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* sprite for drawing (instead of _flashBitmap in flash)</haxe_doc>
		</_canvas>
		<_fxShakeDirection>
			<x path="Int"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeDirection>
		<_fxShakeOffset>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeOffset>
		<_fxShakeComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeComplete>
		<_fxShakeDuration>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeDuration>
		<_fxShakeIntensity>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "shake" special effect.</haxe_doc>
		</_fxShakeIntensity>
		<_fxFadeAlpha>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeAlpha>
		<_fxFadeComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeComplete>
		<_fxFadeDuration>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeDuration>
		<_scrollTarget>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Helper to calculate follow target current scroll.</haxe_doc>
		</_scrollTarget>
		<_lastTargetPosition>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Used to calculate the following target current velocity.</haxe_doc>
		</_lastTargetPosition>
		<_fxFadeColor>
			<x path="Int"/>
			<haxe_doc>* Internal, used to control the "fade" special effect.</haxe_doc>
		</_fxFadeColor>
		<_fxFlashAlpha>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashAlpha>
		<_fxFlashComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashComplete>
		<_fxFlashDuration>
			<x path="Float"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashDuration>
		<_fxFlashColor>
			<x path="Int"/>
			<haxe_doc>* Internal, used to control the "flash" special effect.</haxe_doc>
		</_fxFlashColor>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashPoint>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashRect>
		<_flashOffsetY public="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashOffsetY>
		<_flashOffsetX public="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashOffsetX>
		<_flashSprite public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Internal, used to render buffer to screen space.</haxe_doc>
		</_flashSprite>
		<_point>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal, to help avoid costly allocations.</haxe_doc>
		</_point>
		<bgColor public="1">
			<x path="Int"/>
			<haxe_doc>* The natural background color of the camera. Defaults to FlxG.cameras.bgColor.
	 * NOTE: can be transparent for crazy FX!</haxe_doc>
		</bgColor>
		<scroll public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Stores the basic parallax scrolling values.</haxe_doc>
		</scroll>
		<bounds public="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc>* The edges of the camera's range, i.e. where to stop scrolling.
	 * Measured in game pixels and world coordinates.</haxe_doc>
		</bounds>
		<deadzone public="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc><![CDATA[* You can assign a "dead zone" to the camera in order to better control its movement. The camera will always keep the focus object inside the dead zone, unless it is bumping up against 
	 * the bounds rectangle's edges. The deadzone's coordinates are measured from the camera's upper left corner in game pixels. For rapid prototyping, you can use the preset deadzones (e.g. <code>STYLE_PLATFORMER</code>) with <code>follow()</code>.]]></haxe_doc>
		</deadzone>
		<followLerp public="1">
			<x path="Float"/>
			<haxe_doc>* Used to smoothly track the camera as it follows.</haxe_doc>
		</followLerp>
		<followLead public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc><![CDATA[* Used to force the camera to look ahead of the <code>followTarget</code>.]]></haxe_doc>
		</followLead>
		<target public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc><![CDATA[* Tells the camera to follow this <code>FlxObject</code> object around.]]></haxe_doc>
		</target>
		<style public="1">
			<x path="Int"/>
			<haxe_doc>* Tells the camera to use this following style.</haxe_doc>
		</style>
		<height public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* How tall the camera display is, in game pixels.</haxe_doc>
		</height>
		<width public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* How wide the camera display is, in game pixels.</haxe_doc>
		</width>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y position of this camera's display.  Zoom does NOT affect this number.
	 * Measured in pixels from the top of the flash window.</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X position of this camera's display.  Zoom does NOT affect this number.
	 * Measured in pixels from the left side of the flash window.</haxe_doc>
		</x>
		<new public="1" set="method" line="404">
			<f a="X:Y:Width:Height:?Zoom">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiates a new camera at the specified location, with the specified size and zoom level.
	 * @param X			X location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param Y			Y location of the camera's display in pixels. Uses native, 1:1 resolution, ignores zoom.
	 * @param Width		The width of the camera display in pixels.
	 * @param Height	The height of the camera display in pixels.
	 * @param Zoom		The initial zoom level of the camera.  A zoom level of 2 will make all pixels display at 2x resolution.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The camera class is used to display the game's visuals in the Flash player.
 * By default one camera is created automatically, that is the same size as the Flash player.
 * You can add more cameras or even replace the main camera using utilities in <code>FlxG</code>.]]></haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.BitmapFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/BitmapFrontEnd.hx">
		<clearCache public="1" set="method" line="311">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps the cache's image references.</haxe_doc>
		</clearCache>
		<remove public="1" set="method" line="298"><f a="key">
	<c path="String"/>
	<x path="Void"/>
</f></remove>
		<getUniqueKey public="1" set="method" line="283">
			<f a="?baseKey">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets unique key for bitmap cache
	 * 
	 * @param	baseKey	key's prefix
	 * @return	unique key</haxe_doc>
		</getUniqueKey>
		<getCacheKeyFor public="1" set="method" line="264">
			<f a="bmd">
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets key from bitmap cache for specified bitmapdata
	 * 
	 * @param	bmd	bitmapdata to find in cache
	 * @return	bitmapdata's key or null if there isn't such bitmapdata in cache</haxe_doc>
		</getCacheKeyFor>
		<get public="1" set="method" line="253"><f a="key">
	<c path="String"/>
	<c path="flixel.util.loaders.CachedGraphics"/>
</f></get>
		<add public="1" set="method" line="129">
			<f a="Graphic:?Unique:?Key">
				<d/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc><![CDATA[* Loads a bitmap from a file, caches it, and generates a horizontally flipped version if necessary.
	 * 
	 * @param	Graphic		The image file that you want to load.
	 * @param	Unique		Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key			Force the cache to use a specific Key to index the bitmap.
	 * @return	The <code>BitmapData</code> we just created.]]></haxe_doc>
		</add>
		<create public="1" set="method" line="102">
			<f a="Width:Height:Color:?Unique:?Key">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</f>
			<haxe_doc><![CDATA[* Generates a new <code>BitmapData</code> object (a colored square) and caches it.
	 * 
	 * @param	Width	How wide the square should be.
	 * @param	Height	How high the square should be.
	 * @param	Color	What color the square should be (0xAARRGGBB)
	 * @param	Unique	Ensures that the bitmap data uses a new slot in the cache.
	 * @param	Key		Force the cache to use a specific Key to index the bitmap.
	 * @return	The <code>BitmapData</code> we just created.]]></haxe_doc>
		</create>
		<checkCache public="1" set="method" line="87">
			<f a="Key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check the local bitmap cache to see if a bitmap with this key has been loaded already.
	 * 
	 * @param	Key		The string key identifying the bitmap.
	 * @return	Whether or not this file can be found in the cache.</haxe_doc>
		</checkCache>
		<dumpCache public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps bits of all cached graphics. This restores memory, but you can't read / write pixels on those graphics anymore.
	 * You can call onContext() method for each CachedGraphic object which will restore it again.</haxe_doc>
		</dumpCache>
		<onContext public="1" set="method" line="40"><f a=""><x path="Void"/></f></onContext>
		<get_whitePixel set="method" line="28"><f a=""><c path="flixel.util.loaders.CachedGraphics"/></f></get_whitePixel>
		<_whitePixel><c path="flixel.util.loaders.CachedGraphics"/></_whitePixel>
		<whitePixel public="1" get="accessor" set="null"><c path="flixel.util.loaders.CachedGraphics"/></whitePixel>
		<_cache>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.util.loaders.CachedGraphics"/>
			</x>
			<haxe_doc>* Internal storage system to prevent graphics from being used repeatedly in memory.</haxe_doc>
		</_cache>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.frontEnds.CameraFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/CameraFrontEnd.hx">
		<set_bgColor set="method" line="279"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColor>
		<get_bgColor get="inline" set="null" line="267">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Get and set the background color of the game.
	 * Get functionality is equivalent to FlxG.camera.bgColor.
	 * Set functionality sets the background color of all the current cameras.</haxe_doc>
		</get_bgColor>
		<bgColor public="1" get="accessor" set="accessor"><x path="Int"/></bgColor>
		<shake public="1" set="method" line="252">
			<f a="?Intensity:?Duration:?OnComplete:?Force:?Direction">
				<x path="Float"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A simple screen-shake effect.
	 * 
	 * @param	Intensity	Percentage of screen size representing the maximum distance that the screen can move while shaking.
	 * @param	Duration	The length in seconds that the shaking effect should last.
	 * @param	OnComplete	A function you want to run when the shake effect finishes.
	 * @param	Force		Force the effect to reset (default = true, unlike flash() and fade()!).
	 * @param	Direction	Whether to shake on both axes, just up and down, or just side to side (use class constants SHAKE_BOTH_AXES, SHAKE_VERTICAL_ONLY, or SHAKE_HORIZONTAL_ONLY).  Default value is SHAKE_BOTH_AXES (0).</haxe_doc>
		</shake>
		<fade public="1" set="method" line="235">
			<f a="?Color:?Duration:?FadeIn:?OnComplete:?Force">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* The screen is gradually filled with this color.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the fade to finish.
	 * @param 	FadeIn 		True fades from a color, false fades to it.
	 * @param	OnComplete	A function you want to run when the fade finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</fade>
		<flash public="1" set="method" line="218">
			<f a="?Color:?Duration:?OnComplete:?Force">
				<x path="Int"/>
				<x path="Float"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* All screens are filled with this color and gradually return to normal.
	 * 
	 * @param	Color		The color you want to use.
	 * @param	Duration	How long it takes for the flash to fade.
	 * @param	OnComplete	A function you want to run when the flash finishes.
	 * @param	Force		Force the effect to reset.</haxe_doc>
		</flash>
		<reset public="1" set="method" line="191">
			<f a="?NewCamera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Dumps all the current cameras and resets to just one camera.
	 * Handy for doing split-screen especially.
	 * 
	 * @param	NewCamera	Optional; specify a specific camera object to be the new main camera.</haxe_doc>
		</reset>
		<remove public="1" set="method" line="155">
			<f a="Camera:?Destroy">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a camera from the game.
	 * 
	 * @param	Camera	The camera you want to remove.
	 * @param	Destroy	Whether to call destroy() on the camera, default value is true.</haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="140">
			<f a="NewCamera">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.FlxCamera"/>
			</f>
			<haxe_doc><![CDATA[* Add a new camera object to the game.
	 * Handy for PiP, split-screen, etc.
	 * 
	 * @param	NewCamera	The camera you want to add.
	 * @return	This <code>FlxCamera</code> instance.]]></haxe_doc>
		</add>
		<update public="1" get="inline" set="null" line="111">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game object to update the cameras and their tracking/special effects logic.</haxe_doc>
		</update>
		<unlock public="1" get="inline" set="null" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game object to draw the special FX and unlock all the camera buffers.</haxe_doc>
		</unlock>
		<render public="1" get="inline" set="null" line="71"><f a=""><x path="Void"/></f></render>
		<lock public="1" get="inline" set="null" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game object to lock all the camera buffers and clear them for the next draw pass.</haxe_doc>
		</lock>
		<_cameraRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal helper variable for clearing the cameras each frame.</haxe_doc>
		</_cameraRect>
		<useBufferLocking public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Allows you to possibly slightly optimize the rendering process IF
	 * you are not doing any pre-processing in your game state's <code>draw()</code> call.
	 * @default false]]></haxe_doc>
		</useBufferLocking>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.FlxCamera"/></c>
			<haxe_doc><![CDATA[* An array listing <code>FlxCamera</code> objects that are used to draw stuff.
	 * By default flixel creates one camera the size of the screen.]]></haxe_doc>
		</list>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.frontEnds.ConsoleFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/ConsoleFrontEnd.hx">
		<addCommand public="1" get="inline" set="null" line="52">
			<f a="Command:AnyObject:Function:?Alt">
				<c path="String"/>
				<d/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a custom command to the console on the debugging screen.
	 * 
	 * @param 	Command		The command's name.
	 * @param 	AnyObject 	Object containing the function (<code>this</code> if function is within the class you're calling this from).
	 * @param 	Function	Function to be called with params when the command is entered.
	 * @param 	Alt			Alternative name for the command, useful as a shortcut.]]></haxe_doc>
		</addCommand>
		<registerObject public="1" get="inline" set="null" line="37">
			<f a="ObjectAlias:AnyObject">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new object to use for the set command.
	 * 
	 * @param 	ObjectAlias		The name with which you want to access the object.
	 * @param 	AnyObject		The object to register.</haxe_doc>
		</registerObject>
		<registerFunction public="1" get="inline" set="null" line="24">
			<f a="FunctionAlias:Function">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new function to use for the call command.
	 * 
	 * @param 	FunctionAlias		The name with which you want to access the function.
	 * @param 	Function			The function to register.</haxe_doc>
		</registerFunction>
		<autoPause public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the console should auto-pause or not when it's focused. Only works for flash atm.
	 * @default true</haxe_doc>
		</autoPause>
		<new public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just needed to create an instance.</haxe_doc>
		</new>
	</class>
	<class path="flixel.system.frontEnds.DebuggerFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/DebuggerFrontEnd.hx">
		<set_visible get="inline" set="null" line="68"><f a="Visible">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_visible>
		<visible public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the debugger is visible or not.
	 * @default false</haxe_doc>
		</visible>
		<resetLayout public="1" get="inline" set="null" line="55">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Just resets the debugger windows to whatever the last selected layout was (<code>STANDARD</code> by default).]]></haxe_doc>
		</resetLayout>
		<setLayout public="1" get="inline" set="null" line="45">
			<f a="Layout">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Change the way the debugger's windows are laid out.
	 * 
	 * @param	Layout	The layout codes can be found in <code>FlxDebugger</code>, for example <code>FlxDebugger.MICRO</code>]]></haxe_doc>
		</setLayout>
		<toggleKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc><![CDATA[* The key codes used to toggle the debugger (see <code>FlxG.keys</code> for the keys available).
	 * Default keys: ` and \. Set to <code>null</code> to deactivate.
	 * @default ["GRAVEACCENT", "BACKSLASH"]]]></haxe_doc>
		</toggleKeys>
		<pointPrecision public="1">
			<x path="Int"/>
			<haxe_doc>* The amount of decimals FlxPoints are rounded to in log / watch.
	 * @default 3</haxe_doc>
		</pointPrecision>
		<visualDebug public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether to show visual debug displays or not. Doesn't exist in <code>FLX_NO_DEBUG</code> mode.
	 * @default false]]></haxe_doc>
		</visualDebug>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Used to instantiate this class and assign a value to <code>toggleKeys</code>]]></haxe_doc>
		</new>
	</class>
	<class path="flixel.system.frontEnds.InputFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/InputFrontEnd.hx">
		<destroy public="1" get="inline" set="null" line="86">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<onFocusLost public="1" get="inline" set="null" line="75">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the inputs from FlxGame FocusLost</haxe_doc>
		</onFocusLost>
		<onFocus public="1" get="inline" set="null" line="64">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the inputs from FlxGame Focus</haxe_doc>
		</onFocus>
		<update public="1" get="inline" set="null" line="53">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the inputs</haxe_doc>
		</update>
		<reset public="1" get="inline" set="null" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the inputs.</haxe_doc>
		</reset>
		<add public="1" set="method" line="24">
			<f a="Input">
				<c path="flixel.system.input.IFlxInput"/>
				<c path="flixel.system.input.IFlxInput"/>
			</f>
			<haxe_doc>* Add an input to the system
	 * 
	 * @param	Input 	The input to add
	 * @return	The input</haxe_doc>
		</add>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.system.input.IFlxInput"/></c>
			<haxe_doc>* A read-only list of all inputs.</haxe_doc>
		</list>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.frontEnds.LogFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/LogFrontEnd.hx">
		<processTraceData set="method" line="156">
			<f a="Data:?Inf">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal function used as a interface between <code>trace()</code> and <code>add()</code>.
	 * @param	Data	The data that has been traced
	 * @param	Inf		Information about the position at which <code>trace()</code> was called]]></haxe_doc>
		</processTraceData>
		<set_redirectTraces set="method" line="137"><f a="Redirect">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_redirectTraces>
		<_oldTrace>
			<d/>
			<haxe_doc>* Internal var used to undo the redirection of traces.</haxe_doc>
		</_oldTrace>
		<redirectTraces public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether everything you <code>trace()</code> is being redirected into the log window.
	 * True by default.]]></haxe_doc>
		</redirectTraces>
		<clear public="1" get="inline" set="null" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the log output.</haxe_doc>
		</clear>
		<advanced public="1" set="method" line="78">
			<f a="Data:?Style:?FireOnce">
				<d/>
				<c path="flixel.system.debug.LogStyle"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add an advanced log message to the debugger by also specifying a <code>LogStyle</code>. Backend to <code>FlxG.log.add(), FlxG.log.warn(), FlxG.log.error() and FlxG.log.notice()</code>.
	 * @param	Data  		Any Data to log.
	 * @param  	Style   	The <code>LogStyle</code> to use, for example <code>LogStyle.WARNING</code>. You can also create your own by importing the <code>LogStyle</code> class.
	 * @param  	FireOnce   	Whether you only want to log the Data in case it hasn't been added already]]></haxe_doc>
		</advanced>
		<_notice get="inline" set="null" line="65"><f a="Data">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_notice>
		<notice public="1">
			<d/>
			<haxe_doc><![CDATA[* Add a notice to the debugger. Example: <code>FlxG.log.notice("Test", "1", "2", "3");</code> - will turn into "[NOTICE] Test 1 2 3".
	 * Infinite amount of arguments allowed, they will be pieced together to one String.]]></haxe_doc>
		</notice>
		<_error get="inline" set="null" line="52"><f a="Data">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_error>
		<error public="1">
			<d/>
			<haxe_doc><![CDATA[* Add an error to the debugger. Example: <code>FlxG.log.error("Test", "1", "2", "3");</code> - will turn into "[ERROR] Test 1 2 3".
	 * Infinite amount of arguments allowed, they will be pieced together to one String.]]></haxe_doc>
		</error>
		<_warn get="inline" set="null" line="39"><f a="Data">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_warn>
		<warn public="1">
			<d/>
			<haxe_doc><![CDATA[* Add a warning to the debugger. Example: <code>FlxG.log.warn("Test", "1", "2", "3");</code> - will turn into "[WARNING] Test 1 2 3".
	 * Infinite amount of arguments allowed, they will be pieced together to one String.]]></haxe_doc>
		</warn>
		<_add get="inline" set="null" line="26"><f a="Data">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></_add>
		<add public="1">
			<d/>
			<haxe_doc><![CDATA[* Log data to the debugger. Example: <code>FlxG.add("Test", "1", "2", "3");</code> - will turn into "Test 1 2 3".
	 * Infinite amount of arguments allowed, they will be pieced together to one String.]]></haxe_doc>
		</add>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flixel.system.frontEnds.PluginFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/PluginFrontEnd.hx">
		<drawDebug public="1" get="inline" set="null" line="184">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* You shouldn't need to call this. Used to draw the debug graphics for any installed plugins.</haxe_doc>
		</drawDebug>
		<onResize public="1" get="inline" set="null" line="169">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Used by the game object to call <code>onResize()</code> on all the plugins.
	 * @param 	Width	The new window width
	 * @param 	Height	The new window Height]]></haxe_doc>
		</onResize>
		<onStateSwitch public="1" get="inline" set="null" line="153">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Used by the game object to call <code>onStateSwitch()</code> on all the plugins.]]></haxe_doc>
		</onStateSwitch>
		<draw public="1" get="inline" set="null" line="139">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Used by the game object to call <code>draw()</code> on all the plugins.]]></haxe_doc>
		</draw>
		<update public="1" get="inline" set="null" line="125">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Used by the game object to call <code>update()</code> on all the plugins.]]></haxe_doc>
		</update>
		<removeType public="1" set="method" line="103">
			<f a="ClassType">
				<x path="Class"><c path="flixel.plugin.FlxPlugin"/></x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes all instances of a plugin from the global plugin array.
	 * 
	 * @param	ClassType	The class name of the plugin type you want removed from the array.
	 * @return	Whether or not at least one instance of this plugin type was removed.</haxe_doc>
		</removeType>
		<remove public="1" set="method" line="79">
			<f a="Plugin">
				<c path="flixel.plugin.FlxPlugin"/>
				<c path="flixel.plugin.FlxPlugin"/>
			</f>
			<haxe_doc><![CDATA[* Removes an instance of a plugin from the global plugin array.
	 * 
	 * @param	Plugin	The plugin instance you want to remove.
	 * @return	The same <code>FlxPlugin</code>-based plugin you passed in.]]></haxe_doc>
		</remove>
		<get public="1" set="method" line="60">
			<f a="ClassType">
				<x path="Class"><c path="flixel.plugin.FlxPlugin"/></x>
				<c path="flixel.plugin.FlxPlugin"/>
			</f>
			<haxe_doc><![CDATA[* Retrieves a plugin based on its class name from the global plugin array.
	 * 
	 * @param	ClassType	The class name of the plugin you want to retrieve. See the <code>FlxPath</code> or <code>FlxTimer</code> constructors for example usage.
	 * @return	The plugin object, or null if no matching plugin was found.]]></haxe_doc>
		</get>
		<add public="1" set="method" line="38">
			<f a="Plugin">
				<c path="flixel.plugin.FlxPlugin"/>
				<c path="flixel.plugin.FlxPlugin"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new plugin to the global plugin array.
	 * 
	 * @param	Plugin	Any object that extends FlxPlugin. Useful for managers and other things. See flixel.plugin for some examples!
	 * @return	The same <code>FlxPlugin</code>-based plugin you passed in.]]></haxe_doc>
		</add>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.plugin.FlxPlugin"/></c>
			<haxe_doc>* An array container for plugins.</haxe_doc>
		</list>
		<new public="1" set="method" line="23">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Sets up two plugins: <code>DebugPathDisplay</code> 
	 * in debugging mode and <code>TimerManager</code>]]></haxe_doc>
		</new>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_FlxTimer" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxPool.hx">
		<get_length get="inline" set="null" line="51"><f a=""><x path="Int"/></f></get_length>
		<clear public="1" get="inline" set="null" line="44"><f a=""><c path="Array"><c path="flixel.util.FlxTimer"/></c></f></clear>
		<putUnsafe public="1" get="inline" set="null" line="35"><f a="obj">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></putUnsafe>
		<put public="1" set="method" line="25"><f a="obj">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></put>
		<get public="1" get="inline" set="null" line="18"><f a=""><c path="flixel.util.FlxTimer"/></f></get>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<_pool><c path="Array"><c path="flixel.util.FlxTimer"/></c></_pool>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.FlxTimer" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxTimer.hx">
		<pool line="14" static="1"><c path="flixel.util.FlxPool_flixel_util_FlxTimer"/></pool>
		<recycle public="1" set="method" line="75" static="1">
			<f a=""><c path="flixel.util.FlxTimer"/></f>
			<haxe_doc>* Returns a recycled timer.</haxe_doc>
		</recycle>
		<start public="1" set="method" line="87" static="1">
			<f a="?Time:?Callback:?Loops">
				<x path="Float"/>
				<f a="">
					<c path="flixel.util.FlxTimer"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<c path="flixel.util.FlxTimer"/>
			</f>
			<haxe_doc>* Returns a recycled timer and starts it.
	 * 
	 * @param	Time		How many seconds it takes for the timer to go off.
	 * @param	Callback	Optional, triggered whenever the time runs out, once for each loop. Callback should be formed "onTimer(Timer:FlxTimer);"
	 * @param	Loops		How many times the timer should go off.  Default is 1, or "just count down once."</haxe_doc>
		</start>
		<put public="1" set="method" line="234" static="1"><f a="timer">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></put>
		<manager public="1" static="1">
			<c path="flixel.plugin.TimerManager"/>
			<haxe_doc><![CDATA[* Read-only: The <code>TimerManager</code> instance.]]></haxe_doc>
		</manager>
		<get_progress get="inline" set="null" line="222"><f a=""><x path="Float"/></f></get_progress>
		<progress public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: how far along the timer is, on a scale of 0.0 to 1.0.</haxe_doc>
		</progress>
		<get_elapsedLoops get="inline" set="null" line="212"><f a=""><x path="Int"/></f></get_elapsedLoops>
		<elapsedLoops public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Read-only: how many loops that have elapsed since the timer was started.</haxe_doc>
		</elapsedLoops>
		<get_loopsLeft get="inline" set="null" line="202"><f a=""><x path="Int"/></f></get_loopsLeft>
		<loopsLeft public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Read-only: check how many loops are left on the timer.</haxe_doc>
		</loopsLeft>
		<get_elapsedTime get="inline" set="null" line="192"><f a=""><x path="Float"/></f></get_elapsedTime>
		<elapsedTime public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: The amount of milliseconds that have elapsed since the timer was started</haxe_doc>
		</elapsedTime>
		<get_timeLeft get="inline" set="null" line="182"><f a=""><x path="Float"/></f></get_timeLeft>
		<timeLeft public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Read-only: check how much time is left on the timer.</haxe_doc>
		</timeLeft>
		<update public="1" set="method" line="156">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Called by the timer manager plugin to update the timer.
	 * If time runs out, the loop counter is advanced, the timer reset, and the callback called if it exists.
	 * If the timer runs out of loops, then the timer calls <code>stop()</code>.
	 * However, callbacks are called AFTER <code>stop()</code> is called.]]></haxe_doc>
		</update>
		<abort public="1" set="method" line="141">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops the timer and removes it from the timer manager.</haxe_doc>
		</abort>
		<reset public="1" set="method" line="128">
			<f a="?NewTime">
				<x path="Float"/>
				<c path="flixel.util.FlxTimer"/>
			</f>
			<haxe_doc>* Restart the timer using the new duration
	 * @param	NewDuration	The duration of this timer in ms.</haxe_doc>
		</reset>
		<run public="1" set="method" line="102">
			<f a="?Time:?Callback:?Loops">
				<x path="Float"/>
				<f a="">
					<c path="flixel.util.FlxTimer"/>
					<x path="Void"/>
				</f>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Starts the timer and adds the timer to the timer manager.
	 * 
	 * @param	Time		How many seconds it takes for the timer to go off.
	 * @param	Callback	Optional, triggered whenever the time runs out, once for each loop. Callback should be formed "onTimer(Timer:FlxTimer);"
	 * @param	Loops		How many times the timer should go off.  Default is 1, or "just count down once."
	 * @return	A reference to itself (handy for chaining or whatever).</haxe_doc>
		</run>
		<destroy public="1" set="method" line="66">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_loopsCounter>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for the loops counting up.</haxe_doc>
		</_loopsCounter>
		<_timeCounter>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for the actual timer counting up.</haxe_doc>
		</_timeCounter>
		<_callback>
			<f a="">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for the time's-up callback function.
	 * Callback should be formed "onTimer(Timer:FlxTimer);"</haxe_doc>
		</_callback>
		<usePooling public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to reset and put this FlxTimer object into internal timers pool automatically after it finishes it's work.</haxe_doc>
		</usePooling>
		<userData public="1">
			<d/>
			<haxe_doc>* Useful to store values you want to access within your callback function, ex:
	 * FlxTimer.start(1, function(t) { trace(t.userData); } ).userData = "Hello World!";</haxe_doc>
		</userData>
		<finished public="1">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the timer is finished.</haxe_doc>
		</finished>
		<paused public="1">
			<x path="Bool"/>
			<haxe_doc>* Pauses or checks the pause state of the timer.</haxe_doc>
		</paused>
		<loops public="1">
			<x path="Int"/>
			<haxe_doc>* How many loops the timer was set for.</haxe_doc>
		</loops>
		<time public="1">
			<x path="Float"/>
			<haxe_doc>* How much time the timer was set for.</haxe_doc>
		</time>
		<new set="method" line="61">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal constructor.
	 * This is private, use recycle() or start() to get timers instead.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A simple timer class, leveraging the new plugins system.
 * Can be used with callbacks or by polling the <code>finished</code> flag.
 * Not intended to be added to a game state or group; the timer manager
 * is responsible for actually calling update(), not the user.]]></haxe_doc>
	</class>
	<class path="flixel.plugin.FlxPlugin" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/plugin/FlxPlugin.hx">
		<extends path="flixel.FlxBasic"/>
		<onResize public="1" set="method" line="23">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called whenever the window size has been changed.
	 * @param 	Width	The new window width
	 * @param 	Height	The new window Height</haxe_doc>
		</onResize>
		<onStateSwitch public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* This function is called whenever the state is switched or reset 
	 * (<code>FlxG.switchState()</code> and <code>FlxG.resetState()</code>).]]></haxe_doc>
		</onStateSwitch>
		<new public="1" set="method" line="10"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* A base class for all flixel plugins that use the flixel plugin system (see <code>FlxG.plugins</code>).
 * Plugins are basically <code>FlxBasic</code>s, but they provide some additional features, like 
 * notifications for certain events like switchting the state or resizing the window.]]></haxe_doc>
	</class>
	<class path="flixel.plugin.TimerManager" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/plugin/TimerManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<onStateSwitch public="1" get="inline" set="null" line="107" override="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<clear public="1" set="method" line="98">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all the timers from the timer manager.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="79">
			<f a="Timer:?ReturnInPool">
				<c path="flixel.util.FlxTimer"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove a timer from the timer manager.
	 * Usually called automatically by <code>FlxTimer</code>'s <code>stop()</code> function.
	 * 
	 * @param	Timer	The <code>FlxTimer</code> you want to remove from the manager.
	 * @param	ReturnInPool Whether to reset and put Timer into internal _pool.]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="64">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a new timer to the timer manager.
	 * Usually called automatically by <code>FlxTimer</code>'s constructor.
	 * 
	 * @param	Timer	The <code>FlxTimer</code> you want to add to the manager.]]></haxe_doc>
		</add>
		<update public="1" set="method" line="42" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Called by <code>FlxG.plugins.update()</code> before the game state has been updated.
	 * Cycles through timers and calls <code>update()</code> on each one.]]></haxe_doc>
		</update>
		<destroy public="1" set="method" line="30" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_timers><c path="Array"><c path="flixel.util.FlxTimer"/></c></_timers>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiates a new timer manager.</haxe_doc>
		</new>
		<haxe_doc>* A simple manager for tracking and updating game timer objects.</haxe_doc>
	</class>
	<class path="flixel.tweens.FlxTween" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/FlxTween.hx">
		<manager public="1" static="1">
			<c path="flixel.plugin.TweenManager"/>
			<haxe_doc>* The tweening plugin that handles all the tweens.</haxe_doc>
		</manager>
		<multiVar public="1" set="method" line="45" static="1">
			<f a="Object:Values:Duration:?Options">
				<d/>
				<d/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.MultiVarTween"/>
			</f>
			<haxe_doc>* Tweens numeric public properties of an Object. Shorthand for creating a MultiVarTween tween, starting it and adding it to the TweenPlugin.
	 * Example: FlxTween.multiVar(Object, { x: 500, y: 350 }, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * @param	Object		The object containing the properties to tween.
	 * @param	Values		An object containing key/value pairs of properties and target values.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * @return	The added MultiVarTween object.</haxe_doc>
		</multiVar>
		<num public="1" set="method" line="72" static="1">
			<f a="FromValue:ToValue:Duration:?Options">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<haxe_doc>* Tweens some numeric value. Shorthand for creating a NumTween objects, starting it and adding it to the TweenPlugin.
	 * Example: FlxTween.num(-1000, 0, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	FromValue	Start value.
	 * @param	ToValue		End value.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * @return	The added NumTween object.</haxe_doc>
		</num>
		<angle public="1" set="method" line="99" static="1">
			<f a="FromAngle:ToAngle:Duration:?Options">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<haxe_doc>* Tweens numeric value which represents angle. Shorthand for creating a AngleTween objects, starting it and adding it to the TweenManager.
	 * Example: FlxTween.angle(-90, 90, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	FromAngle	Start angle.
	 * @param	ToAngle		End angle.
	 * @param	Duration	Duration of the tween.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * @return	The added AngleTween object.</haxe_doc>
		</angle>
		<color public="1" set="method" line="128" static="1">
			<f a="Duration:FromColor:ToColor:?FromAlpha:?ToAlpha:?Options">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<haxe_doc>* Tweens numeric value which represents color. Shorthand for creating a ColorTween objects, starting it and adding it to a TweenPlugin.
	 * Example: FlxTween.color(2.0, 0x000000, 0xffffff, 0.0, 1.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Duration	Duration of the tween.
	 * @param	FromColor	Start color.
	 * @param	ToColor		End color.
	 * @param	FromAlpha	Start alpha
	 * @param	ToAlpha		End alpha.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * @return	The added ColorTween object.</haxe_doc>
		</color>
		<fader public="1" set="method" line="154" static="1">
			<f a="Volume:Duration:?Options">
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.sound.Fader"/>
			</f>
			<haxe_doc><![CDATA[* Tweens <code>FlxG.sound.volume</code> . Shorthand for creating a Fader tweens, starting it and adding it to the TweenManager.
	 * Example: FlxTween.fader(0.5, 2.0, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Volume		The volume to fade to.
	 * @param	Duration	Duration of the fade.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * @return	The added Fader object.]]></haxe_doc>
		</fader>
		<linearMotion public="1" set="method" line="185" static="1">
			<f a="Object:FromX:FromY:ToX:ToY:DurationOrSpeed:?UseDuration:?Options">
				<t path="flixel.tweens.motion.Movable"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<haxe_doc>* Create a new LinearMotion tween.
	 * Example: FlxTween.linearMotion(Object, 0, 0, 500, 20, 5, false, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * @return The LinearMotion object.</haxe_doc>
		</linearMotion>
		<quadMotion public="1" set="method" line="219" static="1">
			<f a="Object:FromX:FromY:ControlX:ControlY:ToX:ToY:DurationOrSpeed:?UseDuration:?Options">
				<t path="flixel.tweens.motion.Movable"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<haxe_doc>* Create a new QuadMotion tween.
	 * Example: FlxTween.quadMotion(Object, 0, 100, 300, 500, 100, 2, 5, false, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * @return The QuadMotion object.</haxe_doc>
		</quadMotion>
		<cubicMotion public="1" set="method" line="254" static="1">
			<f a="Object:FromX:FromY:aX:aY:bX:bY:ToX:ToY:Duration:?Options">
				<t path="flixel.tweens.motion.Movable"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<haxe_doc>* Create a new CubicMotion tween.
	 * Example: FlxTween.cubicMotion(_sprite, 0, 0, 500, 100, 400, 200, 100, 100, 2, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object 		The object to move (FlxObject or FlxSpriteGroup)
	 * @param	FromX		X start.
	 * @param	FromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	ToX			X finish.
	 * @param	ToY			Y finish.
	 * @param	Duration	Duration of the movement.
	 * @param	Options		An object containing key/value pairs of the following optional parameters:
	 * 						type		Tween type.
	 * 						complete	Optional completion callback function.
	 * 						ease		Optional easer function.
	 * @return The CubicMotion object.</haxe_doc>
		</cubicMotion>
		<circularMotion public="1" set="method" line="288" static="1">
			<f a="Object:CenterX:CenterY:Radius:Angle:Clockwise:DurationOrSpeed:?UseDuration:?Options">
				<t path="flixel.tweens.motion.Movable"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<haxe_doc>* Create a new CircularMotion tween.
	 * Example: FlxTween.circularMotion(Object, 250, 250, 50, 0, true, 2, true { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement.
	 * @param	UseDuration		Duration of the movement.
	 * @param	Eease			Optional easer function.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * @return The CircularMotion object.</haxe_doc>
		</circularMotion>
		<linearPath public="1" set="method" line="317" static="1">
			<f a="Object:Points:DurationOrSpeed:?UseDuration:?Options">
				<t path="flixel.tweens.motion.Movable"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<haxe_doc>* Create a new LinearPath tween.
	 * Example: FlxTween.linearPath(Object, [new FlxPoint(0, 0), new FlxPoint(100, 100)], 2, true, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object 			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 2 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * @return	The LinearPath object.</haxe_doc>
		</linearPath>
		<quadPath public="1" set="method" line="355" static="1">
			<f a="Object:Points:DurationOrSpeed:?UseDuration:?Options">
				<t path="flixel.tweens.motion.Movable"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.TweenOptions"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<haxe_doc>* Create a new QuadPath tween.
	 * Example: FlxTween.quadPath(Object, [new FlxPoint(0, 0), new FlxPoint(200, 200), new FlxPoint(400, 0)], 2, true, { ease: easeFunction, complete: onComplete, type: FlxTween.ONESHOT });
	 * 
	 * @param	Object			The object to move (FlxObject or FlxSpriteGroup)
	 * @param	Points			An array of at least 3 FlxPoints defining the path
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Options			An object containing key/value pairs of the following optional parameters:
	 * 							type		Tween type.
	 * 							complete	Optional completion callback function.
	 * 							ease		Optional easer function.
	 * @return	The LinearPath object.</haxe_doc>
		</quadPath>
		<PERSIST public="1" get="inline" set="null" line="382" static="1">
			<x path="Int"/>
			<haxe_doc>* Persistent Tween type, will stop when it finishes.</haxe_doc>
		</PERSIST>
		<LOOPING public="1" get="inline" set="null" line="387" static="1">
			<x path="Int"/>
			<haxe_doc>* Looping Tween type, will restart immediately when it finishes.</haxe_doc>
		</LOOPING>
		<PINGPONG public="1" get="inline" set="null" line="392" static="1">
			<x path="Int"/>
			<haxe_doc>* "To and from" Tween type, will play tween hither and thither</haxe_doc>
		</PINGPONG>
		<ONESHOT public="1" get="inline" set="null" line="397" static="1">
			<x path="Int"/>
			<haxe_doc>* Oneshot Tween type, will stop and remove itself from its core container when it finishes.</haxe_doc>
		</ONESHOT>
		<BACKWARD public="1" get="inline" set="null" line="402" static="1">
			<x path="Int"/>
			<haxe_doc>* Backward Tween type, will play tween in reverse direction</haxe_doc>
		</BACKWARD>
		<_backward><x path="Bool"/></_backward>
		<_target><x path="Float"/></_target>
		<_time><x path="Float"/></_time>
		<_t><x path="Float"/></_t>
		<_ease><t path="flixel.tweens.EaseFunction"/></_ease>
		<_type><x path="Int"/></_type>
		<finished public="1" set="null"><x path="Bool"/></finished>
		<get_scale set="method" line="545"><f a=""><x path="Float"/></f></get_scale>
		<scale public="1" get="accessor" set="null"><x path="Float"/></scale>
		<set_percent set="method" line="542"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_percent>
		<get_percent set="method" line="541"><f a=""><x path="Float"/></f></get_percent>
		<percent public="1" get="accessor" set="accessor"><x path="Float"/></percent>
		<finish public="1" set="method" line="505">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Called when the Tween completes.</haxe_doc>
		</finish>
		<cancel public="1" set="method" line="498">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Immediately stops the Tween and removes it from its Tweener without calling the complete callback.</haxe_doc>
		</cancel>
		<start public="1" set="method" line="483">
			<f a=""><d/></f>
			<haxe_doc>* Starts the Tween, or restarts it if it's currently running.</haxe_doc>
		</start>
		<update public="1" set="method" line="453">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the Tween, called by World.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="443"><f a=""><x path="Void"/></f></destroy>
		<userData public="1">
			<d/>
			<haxe_doc>* Useful to store values you want to access within your callback function.</haxe_doc>
		</userData>
		<executions public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* How many times this tween has been executed / has finished so far - useful to 
	 * stop the LOOPING and PINGPONG types after a certain amount of time</haxe_doc>
		</executions>
		<complete public="1"><t path="flixel.tweens.CompleteCallback"/></complete>
		<active public="1"><x path="Bool"/></active>
		<new public="1" set="method" line="423">
			<f a="duration:?type:?complete:?ease">
				<x path="Float"/>
				<x path="Int"/>
				<t path="flixel.tweens.CompleteCallback"/>
				<t path="flixel.tweens.EaseFunction"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor. Specify basic information about the Tween.
	 * @param	duration	Duration of the tween (in seconds or frames).
	 * @param	type		Tween type, one of Tween.PERSIST (default), Tween.LOOPING, or Tween.ONESHOT.
	 * @param	complete	Optional callback for when the Tween completes.
	 * @param	ease		Optional easer function to apply to the Tweened value.</haxe_doc>
		</new>
	</class>
	<class path="flixel.plugin.TweenManager" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/plugin/TweenManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<onStateSwitch public="1" get="inline" set="null" line="109" override="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<clear public="1" set="method" line="100">
			<f a="?Destroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Removes all <code>FlxTween</code>s.
	 * @param	Destroy		Whether you want to destroy the <code>FlxTween</code>s.]]></haxe_doc>
		</clear>
		<remove public="1" set="method" line="75">
			<f a="Tween:?Destroy">
				<c path="flixel.tweens.FlxTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<haxe_doc><![CDATA[* Remove a <code>FlxTween</code>.
	 * @param	Tween		The <code>FlxTween</code> to remove.
	 * @param	Destroy		Whether you want to destroy the <code>FlxTween</code>.
	 * @return	The added <code>FlxTween</code> object.]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="46">
			<f a="Tween:?Start">
				<c path="flixel.tweens.FlxTween"/>
				<x path="Bool"/>
				<c path="flixel.tweens.FlxTween"/>
			</f>
			<haxe_doc><![CDATA[* Add a <code>FlxTween</code>.
	 * @param	Tween	The <code>FlxTween</code> to add.
	 * @param	Start	Whether you want it to start right away.
	 * @return	The added <code>FlxTween</code> object.]]></haxe_doc>
		</add>
		<update public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></update>
		<list public="1" set="null">
			<c path="Array"><c path="flixel.tweens.FlxTween"/></c>
			<haxe_doc><![CDATA[* A list of all <code>FlxTween</code> objects.]]></haxe_doc>
		</list>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* A manager for <code>FlxTween</code>s.]]></haxe_doc>
	</class>
	<class path="flixel.util.FlxPoint" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxPoint.hx">
		<distanceTo public="1" get="inline" set="null" line="134">
			<f a="AnotherPoint">
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Calculate the distance to another point.
	 * 
	 * @param 	AnotherPoint	A <code>FlxPoint</code> object to calculate the distance to.
	 * @return	The distance between the two points as a Float.]]></haxe_doc>
		</distanceTo>
		<inFlxRect public="1" get="inline" set="null" line="123">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	Rect	The FlxRect to test within
	 * @return	True if pointX/pointY is within the FlxRect, otherwise false</haxe_doc>
		</inFlxRect>
		<inCoords public="1" get="inline" set="null" line="112">
			<f a="RectX:RectY:RectWidth:RectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this point is within the given rectangular block
	 * 
	 * @param	RectX		The X value of the region to test within
	 * @param	RectY		The Y value of the region to test within
	 * @param	RectWidth	The width of the region to test within
	 * @param	RectHeight	The height of the region to test within
	 * @return	True if the point is within the region, otherwise false</haxe_doc>
		</inCoords>
		<toString public="1" get="inline" set="null" line="98">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Convert object to readable string name. Useful for debugging, save games, etc.</haxe_doc>
		</toString>
		<copyToFlash public="1" get="inline" set="null" line="88">
			<f a="FlashPoint">
				<c path="flash.geom.Point"/>
				<c path="flash.geom.Point"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified Flash point.
	 * @param	Point	Any <code>Point</code>.
	 * @return	A reference to the altered point parameter.]]></haxe_doc>
		</copyToFlash>
		<copyFromFlash public="1" get="inline" set="null" line="76">
			<f a="FlashPoint">
				<c path="flash.geom.Point"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified Flash point.
	 * @param	Point	Any <code>Point</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyTo public="1" get="inline" set="null" line="60">
			<f a="?point">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this point to the specified point.
	 * @param	Point	Any <code>FlxPoint</code>.
	 * @return	A reference to the altered point parameter.]]></haxe_doc>
		</copyTo>
		<copyFrom public="1" get="inline" set="null" line="48">
			<f a="point">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified point.
	 * @param	Point	Any <code>FlxPoint</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFrom>
		<set public="1" set="method" line="36">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Set the coordinates of this point object.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</set>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</x>
		<new public="1" set="method" line="25">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new point object.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.</haxe_doc>
		</new>
		<haxe_doc>* Stores a 2D floating point coordinate.</haxe_doc>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_FlxPath" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxPool.hx">
		<get_length get="inline" set="null" line="51"><f a=""><x path="Int"/></f></get_length>
		<clear public="1" get="inline" set="null" line="44"><f a=""><c path="Array"><c path="flixel.util.FlxPath"/></c></f></clear>
		<putUnsafe public="1" get="inline" set="null" line="35"><f a="obj">
	<c path="flixel.util.FlxPath"/>
	<x path="Void"/>
</f></putUnsafe>
		<put public="1" set="method" line="25"><f a="obj">
	<c path="flixel.util.FlxPath"/>
	<x path="Void"/>
</f></put>
		<get public="1" get="inline" set="null" line="18"><f a=""><c path="flixel.util.FlxPath"/></f></get>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<_pool><c path="Array"><c path="flixel.util.FlxPath"/></c></_pool>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.FlxPath" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxPath.hx">
		<pool line="20" static="1"><c path="flixel.util.FlxPool_flixel_util_FlxPath"/></pool>
		<recycle public="1" set="method" line="25" static="1">
			<f a=""><c path="flixel.util.FlxPath"/></f>
			<haxe_doc>* Returns a recycled path.</haxe_doc>
		</recycle>
		<put public="1" set="method" line="30" static="1"><f a="path">
	<c path="flixel.util.FlxPath"/>
	<x path="Void"/>
</f></put>
		<start public="1" set="method" line="45" static="1">
			<f a="Object:Nodes:?Speed:?Mode:?AutoRotate:?UsePooling">
				<c path="flixel.FlxObject"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Call this function to give this object a path to follow.
	 * If the path does not have at least one node in it, this function
	 * will log a warning message and return.
	 * @param	Object		The Object which will follow this path
	 * @param	Nodes		Array of points which will construct path.
	 * @param	Speed		How fast to travel along the path in pixels per second.
	 * @param	Mode		Optional, controls the behavior of the object following the path using the path behavior constants.  Can use multiple flags at once, for example PATH_YOYO|PATH_HORIZONTAL_ONLY will make an object move back and forth along the X axis of the path only.
	 * @param	AutoRotate	Automatically point the object toward the next node.  Assumes the graphic is pointing upward.  Default behavior is false, or no automatic rotation.</haxe_doc>
		</start>
		<FORWARD public="1" get="inline" set="null" line="55" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then stop.</haxe_doc>
		</FORWARD>
		<BACKWARD public="1" get="inline" set="null" line="59" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then stop.</haxe_doc>
		</BACKWARD>
		<LOOP_FORWARD public="1" get="inline" set="null" line="63" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then directly back to the start, and start over.</haxe_doc>
		</LOOP_FORWARD>
		<LOOP_BACKWARD public="1" get="inline" set="null" line="67" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the end of the path to the start then directly back to the end, and start over.</haxe_doc>
		</LOOP_BACKWARD>
		<YOYO public="1" get="inline" set="null" line="71" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: move from the start of the path to the end then turn around and go back to the start, over and over.</haxe_doc>
		</YOYO>
		<HORIZONTAL_ONLY public="1" get="inline" set="null" line="75" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any vertical component to the path data, only follows side to side.</haxe_doc>
		</HORIZONTAL_ONLY>
		<VERTICAL_ONLY public="1" get="inline" set="null" line="79" static="1">
			<x path="Int"/>
			<haxe_doc>* Path behavior controls: ignores any horizontal component to the path data, only follows up and down.</haxe_doc>
		</VERTICAL_ONLY>
		<_point line="158" static="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Internal helper for keeping new variable instantiations under control.</haxe_doc>
		</_point>
		<manager public="1" static="1">
			<c path="flixel.plugin.PathManager"/>
			<haxe_doc><![CDATA[* Read-only: The <code>TimerManager</code> instance.]]></haxe_doc>
		</manager>
		<drawDebug public="1" set="method" line="628">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* While this doesn't override <code>FlxBasic.drawDebug()</code>, the behavior is very similar.
	 * Based on this path data, it draws a simple lines-and-boxes representation of the path
	 * if the visual debug mode was toggled in the debugger overlay.  You can use <code>debugColor</code>
	 * and <code>debugScrollFactor</code> to control the path's appearance.
	 * @param	Camera		The camera object the path will draw to.]]></haxe_doc>
		</drawDebug>
		<tail public="1" set="method" line="611">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* Get the last node in the list.
	 * @return	The last node in the path.</haxe_doc>
		</tail>
		<head public="1" set="method" line="598">
			<f a=""><c path="flixel.util.FlxPoint"/></f>
			<haxe_doc>* Get the first node in the list.
	 * @return	The first node in the path.</haxe_doc>
		</head>
		<removeAt public="1" set="method" line="581">
			<f a="Index">
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Remove a node from the path using the specified position in the list of path nodes.
	 * @param	Index	Where within the list of path nodes you want to remove a node.
	 * @return	The node that was excised.  Returns null if there were no nodes in the path.</haxe_doc>
		</removeAt>
		<remove public="1" set="method" line="563">
			<f a="Node">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Remove a node from the path.
	 * NOTE: only works with points added by reference or with references from <code>nodes</code> itself!
	 * @param	Node	The point object you want to remove from the path.
	 * @return	The node that was excised.  Returns null if the node was not found.]]></haxe_doc>
		</remove>
		<addPointAt public="1" set="method" line="539">
			<f a="Node:Index:?AsReference">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>FlxPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	Index			Where within the list of path nodes to insert this new point.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPointAt>
		<addPoint public="1" set="method" line="518">
			<f a="Node:?AsReference">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc><![CDATA[* Sometimes its easier or faster to just pass a point object instead of separate X and Y coordinates.
	 * This also gives you the option of not creating a new node but actually adding that specific
	 * <code>FlxPoint</code> object to the path.  This allows you to do neat things, like dynamic paths.
	 * @param	Node			The point in world coordinates you want to add to the path.
	 * @param	AsReference		Whether to add the point as a reference, or to create a new point with the specified values.]]></haxe_doc>
		</addPoint>
		<addAt public="1" set="method" line="500">
			<f a="X:Y:Index">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Add a new node to the path at the specified location and index within the path.
	 * @param	X		X position of the new path point in world coordinates.
	 * @param	Y		Y position of the new path point in world coordinates.
	 * @param	Index	Where within the list of path nodes to insert this new point.</haxe_doc>
		</addAt>
		<add public="1" set="method" line="488">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPath"/>
			</f>
			<haxe_doc>* Add a new node to the end of the path at the specified location.
	 * @param	X	X position of the new path point in world coordinates.
	 * @param	Y	Y position of the new path point in world coordinates.</haxe_doc>
		</add>
		<destroy public="1" set="method" line="476">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<abort public="1" set="method" line="457">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Stops path movement and removes this path it from the path manager.</haxe_doc>
		</abort>
		<advancePath set="method" line="354">
			<f a="?Snap">
				<x path="Bool"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Internal function that decides what node in the path to aim for next based on the behavior flags.
	 * @return	The node (a <code>FlxPoint</code> object) we are aiming for next.]]></haxe_doc>
		</advancePath>
		<update public="1" set="method" line="246">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal function for moving the object along the path.
	 * Generally this function is called automatically by <code>preUpdate()</code>.
	 * The first half of the function decides if the object can advance to the next node in the path,
	 * while the second half handles actually picking a velocity toward the next node.]]></haxe_doc>
		</update>
		<setNode public="1" set="method" line="229">
			<f a="NodeIndex">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Change the path node this object is currently at.
	 * @param  NodeIndex    The index of the new node out of <code>path.nodes</code>.]]></haxe_doc>
		</setNode>
		<restart public="1" set="method" line="195"><f a=""><c path="flixel.util.FlxPath"/></f></restart>
		<run public="1" set="method" line="183"><f a="Object:Nodes:?Speed:?Mode:?AutoRotate:?UsePooling">
	<c path="flixel.FlxObject"/>
	<c path="Array"><c path="flixel.util.FlxPoint"/></c>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="flixel.util.FlxPath"/>
</f></run>
		<reset public="1" set="method" line="171">
			<f a=""><c path="flixel.util.FlxPath"/></f>
			<haxe_doc>* 
	 * @param	Object
	 * @param	Nodes	Optional, can specify all the points for the path up front if you want.
	 * @return</haxe_doc>
		</reset>
		<ignoreDrawDebug public="1">
			<x path="Bool"/>
			<haxe_doc>* Setting this to true will prevent the object from appearing
	 * when the visual debug mode in the debugger overlay is toggled on.
	 * @default false</haxe_doc>
		</ignoreDrawDebug>
		<debugScrollY public="1"><x path="Float"/></debugScrollY>
		<debugScrollX public="1">
			<x path="Float"/>
			<haxe_doc>* Specify a debug display scroll factor for the path.  Default is (1,1).
	 * NOTE: does not affect world movement!  Object scroll factors take care of that.</haxe_doc>
		</debugScrollX>
		<debugColor public="1">
			<x path="Int"/>
			<haxe_doc>* Specify a debug display color for the path.  Default is white.</haxe_doc>
		</debugColor>
		<onComplete public="1"><f a="">
	<c path="flixel.util.FlxPath"/>
	<x path="Void"/>
</f></onComplete>
		<finished public="1" set="null"><x path="Bool"/></finished>
		<paused public="1">
			<x path="Bool"/>
			<haxe_doc>* Pauses or checks the pause state of the timer.</haxe_doc>
		</paused>
		<_autoRotate>
			<x path="Bool"/>
			<haxe_doc>* Internal flag for whether the object's angle should be adjusted to the path angle during path follow behavior.</haxe_doc>
		</_autoRotate>
		<_inc>
			<x path="Int"/>
			<haxe_doc>* Internal helper for node navigation, specifically yo-yo and backwards movement.</haxe_doc>
		</_inc>
		<_mode>
			<x path="Int"/>
			<haxe_doc>* Internal tracker for path behavior flags (like looping, horizontal only, etc).</haxe_doc>
		</_mode>
		<_nodeIndex>
			<x path="Int"/>
			<haxe_doc>* Internal helper, tracks which node of the path this object is moving toward.</haxe_doc>
		</_nodeIndex>
		<autoCenter public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the object should auto-center the path or at its origin.
	 * @default true</haxe_doc>
		</autoCenter>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* The angle in degrees between this object and the next node, where 0 is directly upward, and 90 is to the right.</haxe_doc>
		</angle>
		<speed public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The speed at which the object is moving on the path.
	 * When an object completes a non-looping path circuit,
	 * the pathSpeed will be zeroed out, but the <code>path</code> reference
	 * will NOT be nulled out.  So <code>pathSpeed</code> is a good way
	 * to check if this object is currently following a path or not.]]></haxe_doc>
		</speed>
		<usePooling public="1"><x path="Bool"/></usePooling>
		<object public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Object which will follow this path</haxe_doc>
		</object>
		<nodes public="1">
			<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			<haxe_doc><![CDATA[* The list of <code>FlxPoint</code>s that make up the path data.]]></haxe_doc>
		</nodes>
		<new set="method" line="163">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate a new path object.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is a simple path data container.  Basically a list of points that
 * a <code>FlxObject</code> can follow.  Also has code for drawing debug visuals.
 * <code>FlxTilemap.findPath()</code> returns a path object, but you can
 * also just make your own, using the <code>add()</code> functions below
 * or by creating your own array of points.]]></haxe_doc>
	</class>
	<class path="flixel.plugin.PathManager" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/plugin/PathManager.hx">
		<extends path="flixel.plugin.FlxPlugin"/>
		<onStateSwitch public="1" get="inline" set="null" line="152" override="1"><f a=""><x path="Void"/></f></onStateSwitch>
		<clear public="1" set="method" line="143">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes all the paths from the path debug display manager.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="124">
			<f a="Path:?ReturnInPool">
				<c path="flixel.util.FlxPath"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove a path from the path debug display manager.
	 * Usually called automatically by <code>FlxPath</code>'s <code>destroy()</code> function.
	 * 
	 * @param	Path	The <code>FlxPath</code> you want to remove from the manager.]]></haxe_doc>
		</remove>
		<add public="1" set="method" line="110">
			<f a="Path">
				<c path="flixel.util.FlxPath"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a path to the path debug display manager.
	 * Usually called automatically by <code>FlxPath</code>'s constructor.
	 * 
	 * @param	Path	The <code>FlxPath</code> you want to add to the manager.]]></haxe_doc>
		</add>
		<drawDebugOnCamera public="1" set="method" line="82" override="1">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Similar to <code>FlxObject</code>'s <code>drawDebug()</code> functionality,
	 * this function calls <code>drawDebug()</code> on each <code>FlxPath</code> for the specified camera.
	 * Very helpful for debugging!
	 * 
	 * @param	Camera	Which <code>FlxCamera</code> object to draw the debug data to.]]></haxe_doc>
		</drawDebugOnCamera>
		<drawDebug public="1" set="method" line="54" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Called by <code>FlxG.plugins.draw()</code> after the game state has been drawn.
	 * Cycles through cameras and calls <code>drawDebug()</code> on each one.]]></haxe_doc>
		</drawDebug>
		<update public="1" set="method" line="33" override="1"><f a=""><x path="Void"/></f></update>
		<destroy public="1" set="method" line="25" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_paths><c path="Array"><c path="flixel.util.FlxPath"/></c></_paths>
		<new public="1" set="method" line="15">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiates a new debug path display manager.</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.FlxSave" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxSave.hx">
		<SUCCESS line="18" static="1"><x path="Int"/></SUCCESS>
		<PENDING line="19" static="1"><x path="Int"/></PENDING>
		<ERROR line="20" static="1"><x path="Int"/></ERROR>
		<checkBinding set="method" line="208">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Handy utility function for checking and warning if the shared object is bound yet or not.
	 * @return	Whether the shared object was bound yet.</haxe_doc>
		</checkBinding>
		<onDone set="method" line="183">
			<f a="Result">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Event handler for special case storage requests.
	 * @param	E	Flash net status event.</haxe_doc>
		</onDone>
		<erase public="1" set="method" line="155">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Erases everything stored in the local shared object.
	 * Data is immediately erased and the object is saved that way,
	 * so use with caution!
	 * @return	Returns false if the save object is not bound yet.</haxe_doc>
		</erase>
		<flush public="1" set="method" line="110">
			<f a="?MinFileSize:?OnComplete">
				<x path="Int"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Writes the local shared object to disk immediately.  Leaves the object open in memory.
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	Whether or not the data was written immediately.  False could be an error OR a storage request popup.</haxe_doc>
		</flush>
		<close public="1" set="method" line="98">
			<f a="?MinFileSize:?OnComplete">
				<x path="Int"/>
				<f a="">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* A way to safely call <code>flush()</code> and <code>destroy()</code> on your save file.
	 * Will correctly handle storage size popups and all that good stuff.
	 * If you don't want to save your changes first, just call <code>destroy()</code> instead.
	 * @param	MinFileSize		If you need X amount of space for your save, specify it here.
	 * @param	OnComplete		This callback will be triggered when the data is written successfully.
	 * @return	The result of result of the <code>flush()</code> call (see below for more details).]]></haxe_doc>
		</close>
		<bind public="1" set="method" line="72">
			<f a="Name">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Automatically creates or reconnects to locally saved data.
	 * @param	Name	The name of the object (should be the same each time to access old data).
	 * @return	Whether or not you successfully connected to the save data.</haxe_doc>
		</bind>
		<destroy public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_closeRequested>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for save object close request.</haxe_doc>
		</_closeRequested>
		<_onComplete>
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for callback function in case save takes too long.</haxe_doc>
		</_onComplete>
		<_sharedObject>
			<c path="flash.net.SharedObject"/>
			<haxe_doc>* The local shared object itself.
	 * @default null</haxe_doc>
		</_sharedObject>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the local shared object.
	 * @default null</haxe_doc>
		</name>
		<data public="1">
			<d/>
			<haxe_doc>* Allows you to directly access the data container in the local shared object.
	 * @default null</haxe_doc>
		</data>
		<new public="1" set="method" line="50">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Blanks out the containers.</haxe_doc>
		</new>
		<haxe_doc>* A class to help automate and simplify save game functionality.
 * Basicaly a wrapper for the Flash SharedObject thing, but
 * handles some annoying storage request stuff too.</haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.SoundFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/SoundFrontEnd.hx">
		<loadSavedPrefs public="1" set="method" line="337">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by FlxG, you shouldn't need to.
	 * Loads saved sound preferences if they exist.</haxe_doc>
		</loadSavedPrefs>
		<resumeSounds public="1" set="method" line="317">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resume playing existing sounds.</haxe_doc>
		</resumeSounds>
		<pauseSounds public="1" set="method" line="298">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pause all sounds currently playing.</haxe_doc>
		</pauseSounds>
		<updateSounds public="1" set="method" line="282">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the game loop to make sure the sounds get updated each frame.</haxe_doc>
		</updateSounds>
		<destroySounds public="1" set="method" line="262">
			<f a="?ForceDestroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Called by FlxGame on state changes to stop and destroy sounds.
	 * 
	 * @param	ForceDestroy		Kill sounds even if they're flagged <code>survive</code>.]]></haxe_doc>
		</destroySounds>
		<set_volume set="method" line="236">
			<f a="Volume">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</set_volume>
		<volume public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* 
	 * Set <code>volume</code> to a number between 0 and 1 to change the global volume.
	 * 
	 * @default 0.5]]></haxe_doc>
		</volume>
		<stream public="1" get="inline" set="null" line="216">
			<f a="URL:?Volume:?Looped:?AutoDestroy:?OnComplete">
				<c path="String"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound object from a URL.
	 * NOTE: Just calls FlxG.loadSound() with AutoPlay == true.
	 * 
	 * @param	URL		The URL of the sound you want to play.
	 * @param	Volume	How loud to play it (0 to 1).
	 * @param	Looped	Whether or not to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this <code>FlxSound</code> instance.
	 * @return	A FlxSound object.]]></haxe_doc>
		</stream>
		<play public="1" get="inline" set="null" line="196">
			<f a="EmbeddedSound:?Volume:?Looped:?AutoDestroy:?OnComplete">
				<d/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound object from an embedded <code>Class</code> object.
	 * NOTE: Just calls FlxG.loadSound() with AutoPlay == true.
	 * 
	 * @param	EmbeddedSound	The sound you want to play.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this <code>FlxSound</code> instance.
	 * @return	A <code>FlxSound</code> object.]]></haxe_doc>
		</play>
		<load public="1" set="method" line="105">
			<f a="?EmbeddedSound:?Volume:?Looped:?AutoDestroy:?AutoPlay:?URL:?OnComplete">
				<d/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new sound object. 
	 * 
	 * @param	EmbeddedSound	The embedded sound resource you want to play.  To stream, use the optional URL parameter instead.
	 * @param	Volume			How loud to play it (0 to 1).
	 * @param	Looped			Whether to loop this sound.
	 * @param	AutoDestroy		Whether to destroy this sound when it finishes playing.  Leave this value set to "false" if you want to re-use this <code>FlxSound</code> instance.
	 * @param	AutoPlay		Whether to play the sound.
	 * @param	URL				Load a sound from an external web resource instead.  Only used if EmbeddedSound = null.
	 * @return	A <code>FlxSound</code> object.]]></haxe_doc>
		</load>
		<playMusic public="1" set="method" line="75">
			<f a="Music:?Volume">
				<d/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set up and play a looping background soundtrack.
	 * 
	 * @param	Music		The sound file you want to loop in the background.
	 * @param	Volume		How loud the sound should be, from 0 to 1.</haxe_doc>
		</playMusic>
		<muteKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc><![CDATA[* The keys used to mute / unmute the game (see <code>FlxG.keys</code> for the keys available).
	 * Default keys: 0 (and numpad 0). Set to <code>null</code> to deactivate.
	 * @default ["ZERO", "NUMPADZERO"]]]></haxe_doc>
		</muteKeys>
		<volumeDownKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc><![CDATA[* The keys to decrease volume (see <code>FlxG.keys</code> for the keys available).
	 * Default keys: - (and numpad -). Set to <code>null</code> to deactivate.
	 * @default ["MINUS", "NUMPASMINUS"]]]></haxe_doc>
		</volumeDownKeys>
		<volumeUpKeys public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc><![CDATA[* The key codes used to increase volume (see <code>FlxG.keys</code> for the keys available).
	 * Default keys: + (and numpad +). Set to <code>null</code> to deactivate.
	 * @default ["PLUS", "NUMPADPLUS"]]]></haxe_doc>
		</volumeUpKeys>
		<volumeHandler public="1">
			<f a="">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set this hook to get a callback whenever the volume changes.
	 * Function should take the form <code>myVolumeHandler(Volume:Number)</code>.]]></haxe_doc>
		</volumeHandler>
		<muted public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the game sounds are muted.</haxe_doc>
		</muted>
		<list public="1" set="null">
			<c path="flixel.group.FlxTypedGroup"><c path="flixel.system.FlxSound"/></c>
			<haxe_doc>* A list of all the sounds being played in the game.</haxe_doc>
		</list>
		<music public="1">
			<c path="flixel.system.FlxSound"/>
			<haxe_doc>* A handy container for a background music object.</haxe_doc>
		</music>
		<new public="1" set="method" line="51"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.group.FlxTypedGroup" params="T" file="/media/psf/Home/projects/repos/public/flixel/flixel/group/FlxTypedGroup.hx">
		<extends path="flixel.FlxBasic"/>
		<ASCENDING public="1" get="inline" set="null" line="17" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Use with <code>sort()</code> to sort in ascending order.]]></haxe_doc>
		</ASCENDING>
		<DESCENDING public="1" get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Use with <code>sort()</code> to sort in descending order.]]></haxe_doc>
		</DESCENDING>
		<set_maxSize set="method" line="728"><f a="Size">
	<x path="Int"/>
	<x path="Int"/>
</f></set_maxSize>
		<maxSize public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* The maximum capacity of this group. Default is 0, meaning no max capacity, and the group can just grow.</haxe_doc>
		</maxSize>
		<sortHandler set="method" line="706">
			<f a="Obj1:Obj2">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper function for the sort process.
	 * 
	 * @param 	Obj1	The first object being sorted.
	 * @param	Obj2	The second object being sorted.
	 * @return	An integer value: -1 (Obj1 before Obj2), 0 (same), or 1 (Obj1 after Obj2).</haxe_doc>
		</sortHandler>
		<revive public="1" set="method" line="678" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Revives the group itself (and all of it's members if 
	 * <code>autoReviveMembers</code> has been set to true.]]></haxe_doc>
		</revive>
		<kill public="1" set="method" line="656" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Calls kill on the group's members and then on the group itself. 
	 * You can revive this group later via <code>revive()</code> after this.]]></haxe_doc>
		</kill>
		<clear public="1" set="method" line="646">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Remove all instances of <code>FlxBasic</code> subclass (FlxSprite, FlxBlock, etc) from the list.
	 * WARNING: does not destroy() or kill() any of these objects!]]></haxe_doc>
		</clear>
		<getRandom public="1" set="method" line="628">
			<f a="?StartIndex:?Length">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Returns a member at random from the group.
	 * 
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * @return	A <code>FlxBasic</code> from the members list.]]></haxe_doc>
		</getRandom>
		<countDead public="1" set="method" line="595">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Call this function to find out how many members of the group are dead.
	 * 
	 * @return	The number of <code>FlxBasic</code>s flagged as dead.  Returns -1 if group is empty.]]></haxe_doc>
		</countDead>
		<countLiving public="1" set="method" line="564">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Call this function to find out how many members of the group are not dead.
	 * 
	 * @return	The number of <code>FlxBasic</code>s flagged as not dead.  Returns -1 if group is empty.]]></haxe_doc>
		</countLiving>
		<getFirstDead public="1" set="method" line="541">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with dead == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>FlxBasic</code> currently flagged as dead.]]></haxe_doc>
		</getFirstDead>
		<getFirstAlive public="1" set="method" line="517">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with dead == false in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>FlxBasic</code> currently flagged as not dead.]]></haxe_doc>
		</getFirstAlive>
		<getFirstExisting public="1" set="method" line="493">
			<f a=""><c path="flixel.group.FlxTypedGroup.T"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with exists == true in the group.
	 * This is handy for checking if everything's wiped out, or choosing a squad leader, etc.
	 * 
	 * @return	A <code>FlxBasic</code> currently flagged as existing.]]></haxe_doc>
		</getFirstExisting>
		<getFirstNull public="1" set="method" line="467">
			<f a=""><x path="Int"/></f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first index set to 'null'.
	 * Returns -1 if no index stores a null object.
	 * 
	 * @return	An <code>Int</code> indicating the first null slot in the group.]]></haxe_doc>
		</getFirstNull>
		<getFirstAvailable public="1" set="method" line="443">
			<f a="?ObjectClass">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to retrieve the first object with exists == false in the group.
	 * This is handy for recycling in general, e.g. respawning enemies.
	 * 
	 * @param	ObjectClass		An optional parameter that lets you narrow the results to instances of this particular class.
	 * @return	A <code>FlxBasic</code> currently flagged as not existing.]]></haxe_doc>
		</getFirstAvailable>
		<callAll public="1" set="method" line="413">
			<f a="FunctionName:?Recurse">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Go through and call the specified function on all members of the group.
	 * Currently only works on functions that have no required parameters.
	 * 
	 * @param	FunctionName	The string representation of the function you want to call on each object, for example "kill()" or "init()".
	 * @param	Recurse			Default value is true, meaning if <code>callAll()</code> encounters a member that is a group, it will call <code>callAll()</code> on that group rather than calling the group's function.]]></haxe_doc>
		</callAll>
		<setAll public="1" set="method" line="383">
			<f a="VariableName:Value:?Recurse">
				<c path="String"/>
				<d/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Go through and set the specified variable to the specified value on all members of the group.
	 * 
	 * @param	VariableName	The string representation of the variable name you want to modify, for example "visible" or "scrollFactor".
	 * @param	Value			The value you want to assign to that variable.
	 * @param	Recurse			Default value is true, meaning if <code>setAll()</code> encounters a member that is a group, it will call <code>setAll()</code> on that group rather than modifying its variable.]]></haxe_doc>
		</setAll>
		<sort public="1" set="method" line="369">
			<f a="?Index:?Order">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to sort the group according to a particular value and order.
	 * For example, to sort game objects for Zelda-style overlaps you might call
	 * <code>myGroup.sort("y",ASCENDING)</code> at the bottom of your
	 * <code>FlxState.update()</code> override.  To sort all existing objects after
	 * a big explosion or bomb attack, you might call <code>myGroup.sort("exists",DESCENDING)</code>.
	 * 
	 * @param	Index	The <code>String</code> name of the member variable you want to sort on.  Default value is "y".
	 * @param	Order	A <code>FlxGroup</code> constant that defines the sort order.  Possible values are <code>ASCENDING</code> and <code>DESCENDING</code>.  Default value is <code>ASCENDING</code>.]]></haxe_doc>
		</sort>
		<replace public="1" set="method" line="345">
			<f a="OldObject:NewObject">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Replaces an existing <code>FlxBasic</code> with a new one.
	 * 
	 * @param	OldObject	The object you want to replace.
	 * @param	NewObject	The new object you want to use instead.
	 * @return	The new object.]]></haxe_doc>
		</replace>
		<remove public="1" set="method" line="313">
			<f a="Object:?Splice">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Removes an object from the group.
	 * @param	Object	The <code>FlxBasic</code> you want to remove.
	 * @param	Splice	Whether the object should be cut from the array entirely or not.
	 * @return	The removed object.]]></haxe_doc>
		</remove>
		<recycle public="1" set="method" line="258">
			<f a="?ObjectClass:?ContructorArgs">
				<x path="Class"><c path="flixel.group.FlxTypedGroup.T"/></x>
				<c path="Array"><d/></c>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Recycling is designed to help you reuse game objects without always re-allocating or "newing" them.
	 * If you specified a maximum size for this group (like in </code>FlxEmitter</code> ),
	 * then recycle will employ what we're calling "rotating" recycling.
	 * <code>recycle()</code> will first check to see if the group is at capacity yet.
	 * If group is not yet at capacity, recycle() returns a new object.
	 * If the group IS at capacity, then recycle() just returns the next object in line.
	 * If you did NOT specify a maximum size for this group,
	 * then </code>recycle()</code> will employ what we're calling "grow-style" recycling.
	 * </code>recycle()</code> will return either the first object with </code>exists == false()</code>,
	 * or, finding none, add a new object to the array,
	 * doubling the size of the array if necessary.
	 * WARNING: If this function needs to create a new object,
	 * and no object class was provided, it will return null
	 * instead of a valid object!
	 * 
	 * @param	ObjectClass		The class type you want to recycle (e.g. FlxSprite, EvilRobot, etc). Do NOT "new" the class in the parameter!
	 * @param 	ContructorArgs  An array of arguments passed into a newly object if there aren't any dead members to recycle. 
	 * @return	A reference to the object that was created.  Don't forget to cast it back to the Class you want (e.g. myObject = myGroup.recycle(myObjectClass) as myObjectClass;).]]></haxe_doc>
		</recycle>
		<add public="1" set="method" line="175">
			<f a="Object">
				<c path="flixel.group.FlxTypedGroup.T"/>
				<c path="flixel.group.FlxTypedGroup.T"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new <code>FlxBasic</code> subclass (FlxBasic, FlxSprite, Enemy, etc) to the group.
	 * FlxGroup will try to replace a null member of the array first.
	 * Failing that, FlxGroup will add it to the end of the member array,
	 * assuming there is room for it, and doubling the size of the array if necessary.
	 * WARNING: If the group has a maxSize that has already been met,
	 * the object will NOT be added to the group!
	 * 
	 * @param	Object		The object you want to add to the group.
	 * @return	The same <code>FlxBasic</code> object that was passed in.]]></haxe_doc>
		</add>
		<drawDebug public="1" set="method" line="147" override="1"><f a=""><x path="Void"/></f></drawDebug>
		<draw public="1" set="method" line="130" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls render on everything you added.</haxe_doc>
		</draw>
		<update public="1" set="method" line="111" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Automatically goes through and calls update on everything you added.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="82" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* WARNING: This will remove this group entirely. Use <code>kill()</code> if you want to disable it
	 * temporarily only and be able to <code>revive()</code> it later.
	 * Override this function to handle any deleting or "shutdown" type operations you might need,
	 * such as removing traditional Flash children like Sprite objects.]]></haxe_doc>
		</destroy>
		<_sortOrder>
			<x path="Int"/>
			<haxe_doc>* Helper for sort.</haxe_doc>
		</_sortOrder>
		<_sortIndex>
			<c path="String"/>
			<haxe_doc>* Helper for sort.</haxe_doc>
		</_sortIndex>
		<_marker>
			<x path="Int"/>
			<haxe_doc><![CDATA[* Internal helper variable for recycling objects a la <code>FlxEmitter</code>.]]></haxe_doc>
		</_marker>
		<autoReviveMembers public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether <code>revive()</code> also revives all members of this group. 
	 * False by default.]]></haxe_doc>
		</autoReviveMembers>
		<length public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The number of entries in the members array. For performance and safety you should check this 
	 * variable instead of <code>members.length</code> unless you really know what you're doing!]]></haxe_doc>
		</length>
		<_basics><c path="Array"><c path="flixel.FlxBasic"/></c></_basics>
		<_members><c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c></_members>
		<get_members set="method" line="28"><f a=""><c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c></f></get_members>
		<members public="1" get="accessor" set="null">
			<c path="Array"><c path="flixel.group.FlxTypedGroup.T"/></c>
			<haxe_doc><![CDATA[* Array of all the <code>FlxBasic</code>s that exist in this group.]]></haxe_doc>
		</members>
		<new public="1" set="method" line="66">
			<f a="?MaxSize">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new <code>FlxTypedGroup</code>
	 * 
	 * @param	MaxSize		Maximum amount of members allowed]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is an organizational class that can update and render a bunch of <code>FlxBasic</code>s.
 * NOTE: Although <code>FlxGroup</code> extends <code>FlxBasic</code>, it will not automatically
 * add itself to the global collisions quad tree, it will only add its members.]]></haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.WatchFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/WatchFrontEnd.hx">
		<removeMouse public="1" get="inline" set="null" line="82">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Removes the mouse coords from the watch window.</haxe_doc>
		</removeMouse>
		<addMouse public="1" get="inline" set="null" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Add the mouse coords to the watch window. Useful for quickly 
	 * getting coordinates for object placement during prototyping!</haxe_doc>
		</addMouse>
		<removeQuick public="1" get="inline" set="null" line="61">
			<f a="Name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a quickWatch entry from the watch list of the debugger.
	 * 
	 * @param	Name	The name of the quickWatch entry you want to remove.</haxe_doc>
		</removeQuick>
		<addQuick public="1" get="inline" set="null" line="49">
			<f a="Name:NewValue">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add or update a quickWatch entry to the watch list in the debugger.
	 * Extremely useful when called in <code>update()</code> functions when there 
	 * doesn't exist a variable for a value you want to watch - so you won't have to create one.
	 * 
	 * @param	Name		The name of the quickWatch entry, for example "mousePressed".
	 * @param	NewValue	The new value for this entry, for example <code>FlxG.mouse.pressed</code>.]]></haxe_doc>
		</addQuick>
		<remove public="1" get="inline" set="null" line="34">
			<f a="AnyObject:?VariableName">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Remove a variable from the watch list in the debugger.
	 * Don't pass a Variable Name to remove all watched variables for the specified object.
	 * 
	 * @param	AnyObject		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	VariableName	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".</haxe_doc>
		</remove>
		<add public="1" get="inline" set="null" line="20">
			<f a="AnyObject:VariableName:?DisplayName">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a variable to the watch list in the debugger.
	 * This lets you see the value of the variable all the time.
	 * 
	 * @param	AnyObject		A reference to any object in your game, e.g. Player or Robot or this.
	 * @param	VariableName	The name of the variable you want to watch, in quotes, as a string: e.g. "speed" or "health".
	 * @param	DisplayName		Optional, display your own string instead of the class name + variable name: e.g. "enemy count".</haxe_doc>
		</add>
		<new public="1" set="method" line="10">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just needed to create an instance.</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.FlxRect" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxRect.hx">
		<union public="1" get="inline" set="null" line="184">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Add another rectangle to this one by filling in the 
	 * horizontal and vertical space between the two rectangles.
	 * 
	 * @param	Rect	The second FlxRect to add to this one
	 * @return	The changed FlxRect</haxe_doc>
		</union>
		<containsFlxPoint public="1" get="inline" set="null" line="172">
			<f a="Point">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if this FlxRect contains the FlxPoint
	 * 
	 * @param	Point	The FlxPoint to check
	 * @return	True if the FlxPoint is within this FlxRect, otherwise false</haxe_doc>
		</containsFlxPoint>
		<overlaps public="1" get="inline" set="null" line="161">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxRect</code> object overlaps this <code>FlxRect</code> object.
	 * @param	Rect	The rectangle being tested.
	 * @return	Whether or not the two rectangles overlap.]]></haxe_doc>
		</overlaps>
		<copyToFlash public="1" get="inline" set="null" line="147">
			<f a="FlashRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified Flash rectangle.
	 * @param	Point	Any <code>Rectangle</code>.
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyToFlash>
		<copyFromFlash public="1" get="inline" set="null" line="133">
			<f a="FlashRect">
				<c path="flash.geom.Rectangle"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified Flash rectangle.
	 * @param	FlashRect	Any <code>Rectangle</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFromFlash>
		<copyTo public="1" get="inline" set="null" line="119">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from this rectangle to the specified rectangle.
	 * @param	Point	Any <code>FlxRect</code>.
	 * @return	A reference to the altered rectangle parameter.]]></haxe_doc>
		</copyTo>
		<copyFrom public="1" get="inline" set="null" line="105">
			<f a="Rect">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Helper function, just copies the values from the specified rectangle.
	 * @param	Rect	Any <code>FlxRect</code>.
	 * @return	A reference to itself.]]></haxe_doc>
		</copyFrom>
		<set public="1" get="inline" set="null" line="91">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc>* Fill this rectangle with the data provided.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.
	 * @return	A reference to itself.</haxe_doc>
		</set>
		<get_bottom set="method" line="78">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The Y coordinate of the bottom of the rectangle.  Read-only.</haxe_doc>
		</get_bottom>
		<bottom public="1" get="accessor" set="null"><x path="Float"/></bottom>
		<get_top set="method" line="68">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The Y coordinate of the top of the rectangle.  Read-only.</haxe_doc>
		</get_top>
		<top public="1" get="accessor" set="null"><x path="Float"/></top>
		<get_right set="method" line="58">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The X coordinate of the right side of the rectangle.  Read-only.</haxe_doc>
		</get_right>
		<right public="1" get="accessor" set="null"><x path="Float"/></right>
		<get_left set="method" line="48">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* The X coordinate of the left side of the rectangle.  Read-only.</haxe_doc>
		</get_left>
		<left public="1" get="accessor" set="null"><x path="Float"/></left>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</height>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</width>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* @default 0</haxe_doc>
		</x>
		<new public="1" set="method" line="35">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new rectangle.
	 * 
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.</haxe_doc>
		</new>
		<haxe_doc>* Stores a rectangle.</haxe_doc>
	</class>
	<class path="flixel.FlxG" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxG.hx">
		<LIBRARY_NAME public="1" line="51" static="1">
			<c path="String"/>
			<haxe_doc>* If you build and maintain your own version of flixel,
	 * you can give it your own name here.</haxe_doc>
		</LIBRARY_NAME>
		<LIBRARY_MAJOR_VERSION public="1" line="56" static="1">
			<c path="String"/>
			<haxe_doc>* Assign a major version to your library.
	 * Appears before the decimal in the console.</haxe_doc>
		</LIBRARY_MAJOR_VERSION>
		<LIBRARY_MINOR_VERSION public="1" line="61" static="1">
			<c path="String"/>
			<haxe_doc>* Assign a minor version to your library.
	 * Appears after the decimal in the console.</haxe_doc>
		</LIBRARY_MINOR_VERSION>
		<game public="1" set="null" static="1">
			<c path="flixel.FlxGame"/>
			<haxe_doc>* Internal tracker for game object.</haxe_doc>
		</game>
		<paused public="1" line="70" static="1">
			<x path="Bool"/>
			<haxe_doc>* Handy shared variable for implementing your own pause behavior.</haxe_doc>
		</paused>
		<autoPause public="1" line="75" static="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the game should be paused when focus is lost or not. Use FLX_NO_FOCUS_LOST_SCREEN if you only want to get rid of the default
	 * pause screen. Override onFocus() and onFocusLost() for your own behaviour in your state.</haxe_doc>
		</autoPause>
		<autoResize public="1" line="79" static="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether <code>FlxG.resizeGame()</code> should be called whenever the game is resized. False by default.]]></haxe_doc>
		</autoResize>
		<fixedTimestep public="1" line="84" static="1">
			<x path="Bool"/>
			<haxe_doc>* WARNING: Changing this can lead to issues with physcis and the recording system. Setting this to 
	 * false might lead to smoother animations (even at lower fps) at the cost of physics accuracy.</haxe_doc>
		</fixedTimestep>
		<elapsed public="1" line="88" static="1">
			<x path="Float"/>
			<haxe_doc>* Represents the amount of time in seconds that passed since last frame.</haxe_doc>
		</elapsed>
		<timeScale public="1" line="92" static="1">
			<x path="Float"/>
			<haxe_doc>* How fast or slow time should pass in the game; default is 1.0.</haxe_doc>
		</timeScale>
		<width public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The width of the screen in game pixels. Read-only, use <code>resizeGame()</code> to change.]]></haxe_doc>
		</width>
		<height public="1" set="null" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The height of the screen in game pixels. Read-only, use <code>resizeGame()</code> to change.]]></haxe_doc>
		</height>
		<worldBounds public="1" set="null" line="105" static="1">
			<c path="flixel.util.FlxRect"/>
			<haxe_doc><![CDATA[* The dimensions of the game world, used by the quad tree for collisions and overlap checks.
	 * Use <code>.set()</code> instead of creating a new object!]]></haxe_doc>
		</worldBounds>
		<worldDivisions public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times the quad tree should divide the world on each axis. Generally, sparse collisions can have fewer divisons,
	 * while denser collision activity usually profits from more. Default value is 6.</haxe_doc>
		</worldDivisions>
		<camera public="1" static="1">
			<c path="flixel.FlxCamera"/>
			<haxe_doc><![CDATA[* By default this just refers to the first entry in the <code>FlxG.cameras.list</code> 
	 * array but you can do what you like with it.]]></haxe_doc>
		</camera>
		<save public="1" set="null" line="120" static="1">
			<c path="flixel.util.FlxSave"/>
			<haxe_doc><![CDATA[* A <code>FlxSave</code> used internally by flixel to save sound preferences and 
	 * the history of the console window, but no reason you can't use it for your own stuff too!]]></haxe_doc>
		</save>
		<mouse public="1" set="null" static="1">
			<c path="flixel.system.input.mouse.FlxMouse"/>
			<haxe_doc><![CDATA[* A reference to a <code>FlxMouse</code> object. Important for input!]]></haxe_doc>
		</mouse>
		<keyboard public="1" set="null" static="1">
			<c path="flixel.system.input.keyboard.FlxKeyboard"/>
			<haxe_doc><![CDATA[* A reference to a <code>FlxKeyboard</code> object. Important for input!]]></haxe_doc>
		</keyboard>
		<keys public="1" set="null" static="1">
			<c path="flixel.system.input.keyboard.FlxKeyShortcuts"/>
			<haxe_doc><![CDATA[* A reference to a <code>FlxKeyAccess</code> object. Handy for quickly 
	 * getting information about keys pressed / just pressed or just released!]]></haxe_doc>
		</keys>
		<touches public="1" set="null" static="1">
			<c path="flixel.system.input.touch.FlxTouchManager"/>
			<haxe_doc><![CDATA[* A reference to a <code>FlxTouchManager</code> object. Useful for devices with multitouch support]]></haxe_doc>
		</touches>
		<inputs public="1" set="null" line="163" static="1">
			<c path="flixel.system.frontEnds.InputFrontEnd"/>
			<haxe_doc>* From here on: frontEnd classes.</haxe_doc>
		</inputs>
		<console public="1" set="null" line="168" static="1">
			<c path="flixel.system.frontEnds.ConsoleFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>ConsoleFrontEnd</code> object. Use it to register functions and objects
	 * or add new commands to the console window.]]></haxe_doc>
		</console>
		<log public="1" set="null" line="173" static="1">
			<c path="flixel.system.frontEnds.LogFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>LogFrontEnd</code> object. Use it to <code>add</code> messages to the log window. It is recommended 
	 * to use <code>trace()</code> instead of the old <code>FlxG.log()</code>, since traces will be redirected by default.]]></haxe_doc>
		</log>
		<watch public="1" set="null" line="186" static="1">
			<c path="flixel.system.frontEnds.WatchFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>WatchFrontEnd</code> object. Use it to add or remove things to / from the 
	 * watch window.]]></haxe_doc>
		</watch>
		<debugger public="1" set="null" line="191" static="1">
			<c path="flixel.system.frontEnds.DebuggerFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>DebuggerFrontEnd</code> object. Use it to show / hide / toggle the debguger
	 * change its layout, activate visual debugging or change the key used to toggle it.]]></haxe_doc>
		</debugger>
		<bitmap public="1" set="null" line="205" static="1">
			<c path="flixel.system.frontEnds.BitmapFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>BitmapFrontEnd</code> object. Contains things related to bimtaps,
	 * for example regarding the bitmap cache and the cache itself.]]></haxe_doc>
		</bitmap>
		<cameras public="1" set="null" line="210" static="1">
			<c path="flixel.system.frontEnds.CameraFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>CameraFrontEnd</code> object. Contains things related to cameras,
	 * a <code>list</code> of all cameras and the <code>defaultCamera</code> amongst other things.]]></haxe_doc>
		</cameras>
		<plugins public="1" set="null" line="215" static="1">
			<c path="flixel.system.frontEnds.PluginFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>PluginFrontEnd</code> object. Contains a <code>list</code> of all 
	 * plugins and the functions required to <code>add()</code>, <code>remove()</code> them etc.]]></haxe_doc>
		</plugins>
		<sound public="1" set="null" line="220" static="1">
			<c path="flixel.system.frontEnds.SoundFrontEnd"/>
			<haxe_doc><![CDATA[* A reference to the <code>SoundFrontEnd</code> object. Contains a <code>list</code> of all 
	 * sounds and other things to manage or <code>play()</code> sounds.]]></haxe_doc>
		</sound>
		<init get="inline" set="null" line="226" static="1">
			<f a="Game:Width:Height:Zoom">
				<c path="flixel.FlxGame"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc><![CDATA[* Called by <code>FlxGame</code> to set up <code>FlxG</code> during <code>FlxGame</code>'s constructor.]]></haxe_doc>
		</init>
		<reset get="inline" set="null" line="264" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* Called whenever the game is reset, doesn't have to do quite as much work as the basic initialization stuff.</haxe_doc>
		</reset>
		<libraryName public="1" get="accessor" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* The library name, which is "HaxeFlixel v.(major version).(minor version)"</haxe_doc>
		</libraryName>
		<get_libraryName get="inline" set="null" line="284" static="1"><f a=""><c path="String"/></f></get_libraryName>
		<framerate public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times you want your game to update each second. More updates usually means better collisions and smoother motion.
	 * NOTE: This is NOT the same thing as the Flash Player framerate!</haxe_doc>
		</framerate>
		<get_framerate get="inline" set="null" line="295" static="1"><f a=""><x path="Int"/></f></get_framerate>
		<set_framerate set="method" line="300" static="1"><f a="Framerate">
	<x path="Int"/>
	<x path="Int"/>
</f></set_framerate>
		<flashFramerate public="1" get="accessor" set="accessor" static="1">
			<x path="Int"/>
			<haxe_doc>* How many times you want your game to update each second. More updates usually means better collisions and smoother motion.
	 * NOTE: This is NOT the same thing as the Flash Player framerate!</haxe_doc>
		</flashFramerate>
		<get_flashFramerate set="method" line="324" static="1"><f a=""><x path="Int"/></f></get_flashFramerate>
		<set_flashFramerate set="method" line="334" static="1"><f a="Framerate">
	<x path="Int"/>
	<x path="Int"/>
</f></set_flashFramerate>
		<resetGame public="1" get="inline" set="null" line="361" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Like hitting the reset button a game console, this will re-launch the game as if it just started.</haxe_doc>
		</resetGame>
		<resizeGame public="1" get="inline" set="null" line="370" static="1">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Handy helper functions that takes care of all the things to resize the game. 
	 * Use <code>FlxG.autoResize</code> to call this function automtically when the window is resized!]]></haxe_doc>
		</resizeGame>
		<stage public="1" get="accessor" set="null" static="1">
			<c path="flash.display.Stage"/>
			<haxe_doc>* Read-only: retrieves the Flash stage object (required for event listeners)
	 * Will be null if it's not safe/useful yet.</haxe_doc>
		</stage>
		<get_stage get="inline" set="null" line="406" static="1"><f a=""><c path="flash.display.Stage"/></f></get_stage>
		<state public="1" get="accessor" set="null" static="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Read-only: access the current game state from anywhere.</haxe_doc>
		</state>
		<get_state get="inline" set="null" line="416" static="1"><f a=""><c path="flixel.FlxState"/></f></get_state>
		<switchState public="1" get="inline" set="null" line="424" static="1">
			<f a="State">
				<c path="flixel.FlxState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Switch from the current game state to the one specified here.</haxe_doc>
		</switchState>
		<resetState public="1" get="inline" set="null" line="432" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Request a reset of the current game state.</haxe_doc>
		</resetState>
		<overlap public="1" get="inline" set="null" line="457" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<f a=":">
					<d/>
					<d/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to see if one <code>FlxObject</code> overlaps another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a <code>FlxGroup</code> (or even bundling groups together!).
	 * NOTE: does NOT take objects' scrollfactor into account, all overlaps are checked in world space.
	 * 
	 * @param	ObjectOrGroup1	The first object or group you want to check.
	 * @param	ObjectOrGroup2	The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	NotifyCallback	A function with two <code>FlxObject</code> parameters - e.g. <code>myOverlapFunction(Object1:FlxObject,Object2:FlxObject)</code> - that is called if those two objects overlap.
	 * @param	ProcessCallback	A function with two <code>FlxObject</code> parameters - e.g. <code>myOverlapFunction(Object1:FlxObject,Object2:FlxObject)</code> - that is called if those two objects overlap.  If a ProcessCallback is provided, then NotifyCallback will only be called if ProcessCallback returns true for those objects!
	 * @return	Whether any overlaps were detected.]]></haxe_doc>
		</overlap>
		<pixelPerfectOverlap public="1" get="inline" set="null" line="488" static="1">
			<f a="Sprite1:Sprite2:?AlphaTolerance:?Camera">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Pixel Perfect Collision check between two FlxSprites.
	 * It will do a bounds check first, and if that passes it will run a pixel perfect match on the intersecting area.
	 * Works with rotated and animated sprites.
	 * It's extremly slow on cpp targets, so I don't recommend you to use it on them.
	 * Not working on neko target and awfully slows app down
	 * 
	 * @param	Sprite1			The first FlxSprite to test against
	 * @param	Sprite2			The second FlxSprite to test again, sprite order is irrelevant
	 * @param	AlphaTolerance	The tolerance value above which alpha pixels are included. Default to 255 (must be fully opaque for collision).
	 * @param	Camera			If the collision is taking place in a camera other than FlxG.camera (the default/current) then pass it here
	 * @return	Boolean True if the sprites collide, false if not</haxe_doc>
		</pixelPerfectOverlap>
		<collide public="1" get="inline" set="null" line="507" static="1">
			<f a="?ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<d/>
					<d/>
					<x path="Void"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to see if one <code>FlxObject</code> collides with another.
	 * Can be called with one object and one group, or two groups, or two objects,
	 * whatever floats your boat! For maximum performance try bundling a lot of objects
	 * together using a <code>FlxGroup</code> (or even bundling groups together!).
	 * This function just calls FlxG.overlap and presets the ProcessCallback parameter to FlxObject.separate.
	 * To create your own collision logic, write your own ProcessCallback and use FlxG.overlap to set it up.
	 * NOTE: does NOT take objects' scrollfactor into account, all overlaps are checked in world space.
	 * 
	 * @param	ObjectOrGroup1	The first object or group you want to check.
	 * @param	ObjectOrGroup2	The second object or group you want to check.  If it is the same as the first, flixel knows to just do a comparison within that group.
	 * @param	NotifyCallback	A function with two <code>FlxObject</code> parameters - e.g. <code>myOverlapFunction(Object1:FlxObject,Object2:FlxObject)</code> - that is called if those two objects overlap.
	 * @return	Whether any objects were successfully collided/separated.]]></haxe_doc>
		</collide>
		<haxe_doc><![CDATA[* This is a global helper class full of useful functions for audio,
 * input, basic info, and the camera system among other things.
 * Utilities for maths and color and things can be found in the util package.
 * <code>FlxG</code> is specifically for Flixel-specific properties.]]></haxe_doc>
	</class>
	<class path="flixel.FlxGame" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxGame.hx">
		<extends path="flash.display.Sprite"/>
		<draw set="method" line="682">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Goes through the game state and draws all the game objects and special effects.</haxe_doc>
		</draw>
		<updateInput set="method" line="620"><f a=""><x path="Void"/></f></updateInput>
		<update set="method" line="580">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called by step() and updates the actual game state.
	 * May be called multiple times per "frame" or draw call.</haxe_doc>
		</update>
		<step set="method" line="521">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This is the main game update logic section.
	 * The onEnterFrame() handler is in charge of calling this
	 * the appropriate number of times each frame.
	 * This block handles state changes, replays, all that good stuff.</haxe_doc>
		</step>
		<switchState set="method" line="474">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* If there is a state change requested during the update loop,
	 * this function handles actual destroying the old state and related processes,
	 * and calls creates on the new state and plugs it into the game object.</haxe_doc>
		</switchState>
		<requestNewState public="1" get="inline" set="null" line="460">
			<f a="newState">
				<c path="flixel.FlxState"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Notify the game that we're about to switch states. 
	 * INTERNAL, do not use this, call FlxG.switchState instead.</haxe_doc>
		</requestNewState>
		<resetGame get="inline" set="null" line="431">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal method to create a new instance of iState and reset the game.
	 * This gets called when the game is created, as well as when a new state is requested.</haxe_doc>
		</resetGame>
		<onEnterFrame set="method" line="363">
			<f a="?FlashEvent">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handles the onEnterFrame call and figures out how many updates and draw calls to do.
	 * @param	FlashEvent	Flash event.</haxe_doc>
		</onEnterFrame>
		<onResize set="method" line="338"><f a="E">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></onResize>
		<onFocusLost set="method" line="316">
			<f a="?FlashEvent">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash event.</haxe_doc>
		</onFocusLost>
		<onFocus set="method" line="290">
			<f a="?FlashEvent">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param	FlashEvent	Flash event.</haxe_doc>
		</onFocus>
		<create set="method" line="214">
			<f a="FlashEvent">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to instantiate the guts of the flixel game object once we have a valid reference to the root.
	 * 
	 * @param	FlashEvent	Just a Flash system event, not too important for our purposes.</haxe_doc>
		</create>
		<_skipSplash><x path="Bool"/></_skipSplash>
		<_customFocusLostScreen>
			<x path="Class"><c path="flixel.system.ui.FlxFocusLostScreen"/></x>
			<haxe_doc>* Change this afterr calling super() in the FlxGame constructor to use a customized sound tray based on FlxFocusLostScreen.</haxe_doc>
		</_customFocusLostScreen>
		<_customSoundTray>
			<x path="Class"><c path="flixel.system.ui.FlxSoundTray"/></x>
			<haxe_doc>* Change this afterr calling super() in the FlxGame constructor to use a customized sound tray based on FlxSoundTray.</haxe_doc>
		</_customSoundTray>
		<_focusLostScreen>
			<c path="flixel.system.ui.FlxFocusLostScreen"/>
			<haxe_doc><![CDATA[* The "focus lost" screen (see <code>createFocusScreen()</code>).]]></haxe_doc>
		</_focusLostScreen>
		<_lostFocus>
			<x path="Bool"/>
			<haxe_doc>* Whether the Flash player lost focus.</haxe_doc>
		</_lostFocus>
		<_accumulator>
			<x path="Int"/>
			<haxe_doc>* Total number of milliseconds elapsed since last update loop.
	 * Counts down as we step through the game loop.</haxe_doc>
		</_accumulator>
		<_total>
			<x path="Int"/>
			<haxe_doc>* Total number of milliseconds elapsed since game start.</haxe_doc>
		</_total>
		<_iState>
			<x path="Class"><c path="flixel.FlxState"/></x>
			<haxe_doc>* Class type of the initial/first game state for the game, usually MenuState or something like that.</haxe_doc>
		</_iState>
		<soundTray public="1" set="null">
			<c path="flixel.system.ui.FlxSoundTray"/>
			<haxe_doc><![CDATA[* The sound tray display container (see <code>createSoundTray()</code>).]]></haxe_doc>
		</soundTray>
		<debugger public="1" set="null">
			<c path="flixel.system.debug.FlxDebugger"/>
			<haxe_doc>* The debugger overlay object.</haxe_doc>
		</debugger>
		<requestedReset public="1">
			<x path="Bool"/>
			<haxe_doc>* A flag for keeping track of whether a game reset was requested or not.</haxe_doc>
		</requestedReset>
		<requestedState public="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* If a state change was requested, the new state object is stored here until we switch to it.</haxe_doc>
		</requestedState>
		<maxAccumulation public="1">
			<x path="Int"/>
			<haxe_doc>* Max allowable accumulation (see _accumulator).
	 * Should always (and automatically) be set to roughly 2x the flash player framerate.</haxe_doc>
		</maxAccumulation>
		<flashFramerate public="1">
			<x path="Int"/>
			<haxe_doc>* Framerate of the Flash player (NOT the game loop). Default = 60.</haxe_doc>
		</flashFramerate>
		<stepSeconds public="1">
			<x path="Float"/>
			<haxe_doc>* Optimization so we don't have to divide step by 1000 to get its value in seconds every frame. Supposed to be internal.</haxe_doc>
		</stepSeconds>
		<stepMS public="1">
			<x path="Int"/>
			<haxe_doc>* Milliseconds of time per step of the game loop. FlashEvent.g. 60 fps = 16ms. Supposed to be internal.</haxe_doc>
		</stepMS>
		<elapsedMS public="1">
			<x path="Int"/>
			<haxe_doc>* Milliseconds of time since last step. Supposed to be internal.</haxe_doc>
		</elapsedMS>
		<inputContainer public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Mouse cursor.</haxe_doc>
		</inputContainer>
		<state public="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Current game state.</haxe_doc>
		</state>
		<ticks public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Time in milliseconds that has passed (amount of "ticks" passed) since the game has started.</haxe_doc>
		</ticks>
		<new public="1" set="method" line="184">
			<f a="GameSizeX:GameSizeY:InitialState:?Zoom:?GameFramerate:?FlashFramerate:?SkipSplash">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Class"><c path="flixel.FlxState"/></x>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new game object.
	 * @param	GameSizeX		The width of your game in game pixels, not necessarily final display pixels (see Zoom).
	 * @param	GameSizeY		The height of your game in game pixels, not necessarily final display pixels (see Zoom).
	 * @param	InitialState	The class name of the state you want to create and switch to first (e.g. MenuState).
	 * @param	Zoom			The default level of zoom for the game's cameras (e.g. 2 = all pixels are now drawn at 2x).  Default = 1.
	 * @param	GameFramerate	How frequently the game should update (default is 60 times per second).
	 * @param	FlashFramerate	Sets the actual display framerate for Flash player (default is 60 times per second).
	 * @param	SkipSplash		Whether you want to skip the flixel splash screen in FLX_NO_DEBUG or not.</haxe_doc>
		</new>
		<haxe_doc>* FlxGame is the heart of all flixel games, and contains a bunch of basic game loops and things.
 * It is a long and sloppy file that you shouldn't have to worry about too much!
 * It is basically only used to create your game object in the first place,
 * after that FlxG and FlxState have all the useful stuff you actually need.</haxe_doc>
	</class>
	<class path="flixel.FlxObject" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxObject.hx">
		<extends path="flixel.FlxBasic"/>
		<SEPARATE_BIAS public="1" line="27" static="1">
			<x path="Float"/>
			<haxe_doc>* This value dictates the maximum number of pixels two objects have to intersect before collision stops trying to separate them.
	 * Don't modify this unless your objects are passing through eachother.</haxe_doc>
		</SEPARATE_BIAS>
		<LEFT public="1" get="inline" set="null" line="31" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "left" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="35" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "right" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</RIGHT>
		<UP public="1" get="inline" set="null" line="39" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "up" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</UP>
		<DOWN public="1" get="inline" set="null" line="43" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Generic value for "down" Used by <code>facing</code>, <code>allowCollisions</code>, and <code>touching</code>.]]></haxe_doc>
		</DOWN>
		<NONE public="1" get="inline" set="null" line="47" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning no collisions, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</NONE>
		<CEILING public="1" get="inline" set="null" line="51" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning up, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</CEILING>
		<FLOOR public="1" get="inline" set="null" line="55" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning down, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</FLOOR>
		<WALL public="1" get="inline" set="null" line="59" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning only the left and right sides, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</WALL>
		<ANY public="1" get="inline" set="null" line="63" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Special-case constant meaning any direction, used mainly by <code>allowCollisions</code> and <code>touching</code>.]]></haxe_doc>
		</ANY>
		<_firstSeparateFlxRect line="65" static="1"><c path="flixel.util.FlxRect"/></_firstSeparateFlxRect>
		<_secondSeparateFlxRect line="66" static="1"><c path="flixel.util.FlxRect"/></_secondSeparateFlxRect>
		<_pZero line="71" static="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc><![CDATA[* Should always represent (0,0) - useful for different things, for avoiding unnecessary <code>new</code> calls.]]></haxe_doc>
		</_pZero>
		<separate public="1" get="inline" set="null" line="700" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* The main collision resolution function in flixel.
	 * @param	Object1 	Any <code>FlxObject</code>.
	 * @param	Object2		Any other <code>FlxObject</code>.
	 * @return	Whether the objects in fact touched and were separated.]]></haxe_doc>
		</separate>
		<separateX public="1" set="method" line="713" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* The X-axis component of the object separation process.
	 * @param	Object1 	Any <code>FlxObject</code>.
	 * @param	Object2		Any other <code>FlxObject</code>.
	 * @return	Whether the objects in fact touched and were separated along the X axis.]]></haxe_doc>
		</separateX>
		<separateY public="1" set="method" line="825" static="1">
			<f a="Object1:Object2">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* The Y-axis component of the object separation process.
	 * @param	Object1 	Any <code>FlxObject</code>.
	 * @param	Object2		Any other <code>FlxObject</code>.
	 * @return	Whether the objects in fact touched and were separated along the Y axis.]]></haxe_doc>
		</separateY>
		<get_region get="inline" set="null" line="1017"><f a=""><c path="flixel.system.layer.Region"/></f></get_region>
		<region public="1" get="accessor" set="null"><c path="flixel.system.layer.Region"/></region>
		<setCachedGraphics set="method" line="1001">
			<f a="Value">
				<c path="flixel.util.loaders.CachedGraphics"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function for setting cachedGraphics property for this object. 
	 * It changes cachedGraphics' useCount also for better memory tracking.
	 * @param	value</haxe_doc>
		</setCachedGraphics>
		<get_cachedGraphics get="inline" set="null" line="991"><f a=""><c path="flixel.util.loaders.CachedGraphics"/></f></get_cachedGraphics>
		<cachedGraphics public="1" get="accessor" set="null"><c path="flixel.util.loaders.CachedGraphics"/></cachedGraphics>
		<updateFrameData public="1" set="method" line="984"><f a=""><x path="Void"/></f></updateFrameData>
		<_region><c path="flixel.system.layer.Region"/></_region>
		<_cachedGraphics><c path="flixel.util.loaders.CachedGraphics"/></_cachedGraphics>
		<_framesData><c path="flixel.system.layer.frames.FlxSpriteFrames"/></_framesData>
		<set_angle set="method" line="975"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<angle public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Set the angle of a sprite to rotate it. WARNING: rotating sprites decreases rendering
	 * performance for this sprite by a factor of 10x (in Flash target)!</haxe_doc>
		</angle>
		<set_forceComplexRender set="method" line="964"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_forceComplexRender>
		<setSize public="1" get="inline" set="null" line="958">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Shortcut for setting both width and Height.
	 * @param	Width	The new sprite width.
	 * @param	Height	The new sprite height.</haxe_doc>
		</setSize>
		<setPosition public="1" get="inline" set="null" line="947">
			<f a="?X:?Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to set the coordinates of this object.
	 * Handy since it only requires one line of code.
	 * @param	X	The new x position
	 * @param	Y	The new y position</haxe_doc>
		</setPosition>
		<hurt public="1" set="method" line="685">
			<f a="Damage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Reduces the "health" variable of this sprite by the amount specified in Damage.
	 * Calls kill() if health drops to or below zero.
	 * @param	Damage		How much health to take away (use a negative number to give a health bonus).</haxe_doc>
		</hurt>
		<justTouched public="1" get="inline" set="null" line="675">
			<f a="Direction">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is just landed on a particular surface.
	 * @param	Direction	Any of the collision flags (e.g. LEFT, FLOOR, etc).
	 * @return	Whether the object just landed on (any of) the specified surface(s) this frame.</haxe_doc>
		</justTouched>
		<isTouching public="1" get="inline" set="null" line="665">
			<f a="Direction">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Handy function for checking if this object is touching a particular surface.
	 * @param	Direction	Any of the collision flags (e.g. LEFT, FLOOR, etc).
	 * @return	Whether the object is touching an object in (any of) the specified direction(s) this frame.</haxe_doc>
		</isTouching>
		<reset public="1" set="method" line="650">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handy function for reviving game objects.
	 * Resets their existence flags and position.
	 * @param	X	The new X position of this object.
	 * @param	Y	The new Y position of this object.</haxe_doc>
		</reset>
		<getMidpoint public="1" get="inline" set="null" line="635">
			<f a="?point">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Retrieve the midpoint of this object in world coordinates.
	 * @param	point	Allows you to pass in an existing <code>FlxPoint</code> object if you're so inclined.  Otherwise a new one is created.
	 * @return	A <code>FlxPoint</code> object containing the midpoint of this object in world coordinates.]]></haxe_doc>
		</getMidpoint>
		<set_solid get="inline" set="null" line="617"><f a="Solid">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_solid>
		<get_solid get="inline" set="null" line="612"><f a=""><x path="Bool"/></f></get_solid>
		<solid public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the object collides or not.  For more control over what directions the object will collide from, 
	 * use collision constants (like LEFT, FLOOR, etc) to set the value of allowCollisions directly.</haxe_doc>
		</solid>
		<set_height set="method" line="588"><f a="Height">
	<x path="Float"/>
	<x path="Float"/>
</f></set_height>
		<height public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The height of this object's hitbox. For sprites, use <code>offset</code> to control the hitbox position.]]></haxe_doc>
		</height>
		<set_width set="method" line="565"><f a="Width">
	<x path="Float"/>
	<x path="Float"/>
</f></set_width>
		<width public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The width of this object's hitbox. For sprites, use <code>offset</code> to control the hitbox position.]]></haxe_doc>
		</width>
		<getScreenXY public="1" get="inline" set="null" line="547">
			<f a="?point:?Camera">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to figure out the on-screen position of the object.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @param	Point		Takes a <code>FlxPoint</code> object and assigns the post-scrolled X and Y values of this object to it.
	 * @return	The <code>Point</code> you passed in, or a new <code>Point</code> if you didn't pass one, containing the screen X and Y position of this object.]]></haxe_doc>
		</getScreenXY>
		<onScreen public="1" set="method" line="531">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check and see if this object is currently on screen.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.</haxe_doc>
		</onScreen>
		<overlapsPoint public="1" set="method" line="509">
			<f a="point:?InScreenSpace:?Camera">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if a point in 2D world space overlaps this <code>FlxObject</code> object.
	 * @param	Point			The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.]]></haxe_doc>
		</overlapsPoint>
		<overlapsAt public="1" set="method" line="454">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if this <code>FlxObject</code> were located at the given position, would it overlap the <code>FlxObject</code> or <code>FlxGroup</code>?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account. WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlapsAt>
		<overlaps public="1" set="method" line="399">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera">
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxObject</code> overlaps this <code>FlxObject</code> or <code>FlxGroup</code>. If the group has a LOT of things in it, 
	 * it might be faster to use <code>FlxG.overlaps()</code>. WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlaps>
		<drawDebugOnCamera public="1" set="method" line="331" override="1">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override this function to draw custom "debug mode" graphics to the
	 * specified camera while the debugger's visual mode is toggled on.
	 * 
	 * @param	Camera	Which camera to draw the debug visuals to.</haxe_doc>
		</drawDebugOnCamera>
		<draw public="1" set="method" line="301" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Rarely called, and in this case just increments the visible objects count and calls <code>drawDebug()</code> if necessary.]]></haxe_doc>
		</draw>
		<updateMotion get="inline" set="null" line="273">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for updating the position and speed of this object. Useful for cases when you need to update this but are buried down in too many supers.
	 * Does a slightly fancier-than-normal integration to help with higher fidelity framerate-independenct motion.</haxe_doc>
		</updateMotion>
		<update public="1" set="method" line="251" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override this function to update your class's position and appearance.
	 * This is where most of your game rules and behavioral code will go.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="229" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* WARNING: This will remove this object entirely. Use <code>kill()</code> if you want to disable it temporarily only and <code>reset()</code> it later to revive it.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!]]></haxe_doc>
		</destroy>
		<_boundingBoxColorOverritten><x path="Bool"/></_boundingBoxColorOverritten>
		<set_debugBoundingBoxColor set="method" line="191"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_debugBoundingBoxColor>
		<debugBoundingBoxColor public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Overriding this will force a specific color to be used for debug rect.</haxe_doc>
		</debugBoundingBoxColor>
		<forceComplexRender public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether the object should use complex render on flash target (which uses draw() method) or not.
	 * WARNING: setting forceComplexRender to true decreases rendering performance for this object by a factor of 10x!
	 * @default false</haxe_doc>
		</forceComplexRender>
		<last public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc><![CDATA[* Important variable for collision processing.
	 * By default this value is set automatically during <code>preUpdate()</code>.]]></haxe_doc>
		</last>
		<allowCollisions public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating collision directions. Use bitwise operators to check the values stored here.
	 * Useful for things like one-way platforms (e.g. allowCollisions = UP;). The accessor "solid" just flips this variable between NONE and ANY.</haxe_doc>
		</allowCollisions>
		<wasTouching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts from the previous game loop step. Use bitwise operators to check the values 
	 * stored here, or use touching(), justStartedTouching(), etc. You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</wasTouching>
		<touching public="1">
			<x path="Int"/>
			<haxe_doc>* Bit field of flags (use with UP, DOWN, LEFT, RIGHT, etc) indicating surface contacts. Use bitwise operators to check the values 
	 * stored here, or use touching(), justStartedTouching(), etc. You can even use them broadly as boolean values if you're feeling saucy!</haxe_doc>
		</touching>
		<moves public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Set this to false if you want to skip the automatic motion/movement stuff (see <code>updateMotion()</code>).
	 * FlxObject and FlxSprite default to true. FlxText, FlxTileblock and FlxTilemap default to false.]]></haxe_doc>
		</moves>
		<_point>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* This is just a pre-allocated x-y point container used internally for overlapping</haxe_doc>
		</_point>
		<health public="1">
			<x path="Float"/>
			<haxe_doc>* Handy for storing health percentage or armor points or whatever.</haxe_doc>
		</health>
		<scrollFactor public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Controls how much this object is affected by camera scrolling.
	 * 0 = no movement (e.g. a background layer), 1 = same movement speed as the foreground. Default value: 1, 1.</haxe_doc>
		</scrollFactor>
		<maxAngular public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Use in conjunction with <code>angularAcceleration</code> for fluid spin speed control.]]></haxe_doc>
		</maxAngular>
		<angularDrag public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Like <code>drag</code> but for spinning.]]></haxe_doc>
		</angularDrag>
		<angularAcceleration public="1">
			<x path="Float"/>
			<haxe_doc>* How fast the spin speed should change (in degrees per second).</haxe_doc>
		</angularAcceleration>
		<angularVelocity public="1">
			<x path="Float"/>
			<haxe_doc>* This is how fast you want this sprite to spin (in degrees per second).</haxe_doc>
		</angularVelocity>
		<maxVelocity public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc><![CDATA[* If you are using <code>acceleration</code>, you can use <code>maxVelocity</code> with it
	 * to cap the speed automatically (very useful!).]]></haxe_doc>
		</maxVelocity>
		<drag public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* This isn't drag exactly, more like deceleration that is only applied
	 * when acceleration is not affecting the sprite.</haxe_doc>
		</drag>
		<acceleration public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* How fast the speed of this object is changing (in pixels per second).
	 * Useful for smooth movement and gravity.</haxe_doc>
		</acceleration>
		<elasticity public="1">
			<x path="Float"/>
			<haxe_doc>* The bounciness of this object. Only affects collisions. Default value is 0, or "not bouncy at all."</haxe_doc>
		</elasticity>
		<mass public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The virtual mass of the object. Default value is 1. Currently only used with <code>elasticity</code> 
	 * during collision resolution. Change at your own risk; effects seem crazy unpredictable so far!]]></haxe_doc>
		</mass>
		<velocity public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* The basic speed of this object (in pixels per second).</haxe_doc>
		</velocity>
		<immovable public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether an object will move/alter position after a collision.</haxe_doc>
		</immovable>
		<set_y public="1" set="method" line="87"><f a="NewY">
	<x path="Float"/>
	<x path="Float"/>
</f></set_y>
		<y public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Y position of the upper left corner of this object in world space.</haxe_doc>
		</y>
		<set_x public="1" set="method" line="78"><f a="NewX">
	<x path="Float"/>
	<x path="Float"/>
</f></set_x>
		<x public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* X position of the upper left corner of this object in world space.</haxe_doc>
		</x>
		<new public="1" set="method" line="207">
			<f a="?X:?Y:?Width:?Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Instantiates a <code>FlxObject</code>.
	 * @param	X		The X-coordinate of the point in space.
	 * @param	Y		The Y-coordinate of the point in space.
	 * @param	Width	Desired width of the rectangle.
	 * @param	Height	Desired height of the rectangle.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is the base class for most of the display objects (<code>FlxSprite</code>, <code>FlxText</code>, etc).
 * It includes some basic attributes about game objects, basic state information, sizes, scrolling, and basic physics and motion.]]></haxe_doc>
	</class>
	<class path="flixel.IFlxSprite" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxSprite.hx" module="flixel.FlxSprite" interface="1">
		<extends path="flixel.IFlxBasic"/>
		<reset public="1" set="method"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></reset>
		<alpha public="1" set="null"><x path="Float"/></alpha>
		<y public="1" set="null"><x path="Float"/></y>
		<x public="1" set="null"><x path="Float"/></x>
		<haxe_doc><![CDATA[* The interface for properties of <code>FlxSprite</code>
 * It makes possible to add <code>FlxSpriteGroup</code> to <code>FlxSpriteGroup</code>]]></haxe_doc>
	</class>
	<class path="flixel.FlxSprite" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxSprite.hx">
		<extends path="flixel.FlxObject"/>
		<implements path="flixel.IFlxSprite"/>
		<prefixLength line="1872" static="1">
			<x path="Int"/>
			<haxe_doc>* Helper constants used for animation's frame sorting</haxe_doc>
		</prefixLength>
		<postfixLength line="1873" static="1"><x path="Int"/></postfixLength>
		<frameSortFunction set="method" line="1878" static="1">
			<f a="frame1:frame2">
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper frame sorting function used by addAnimationByPrefixFromTexture() method</haxe_doc>
		</frameSortFunction>
		<resetFrameBitmapDatas public="1" get="inline" set="null" line="1923">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function for reseting precalculated FlxFrame bitmapdatas.
	 * Useful when _pixels bitmapdata changes (e.g. after stamp(), FlxSpriteUtil.drawLine() and other similar method calls).</haxe_doc>
		</resetFrameBitmapDatas>
		<getFlxFrameBitmapData public="1" get="inline" set="null" line="1901">
			<f a=""><c path="flash.display.BitmapData"/></f>
			<haxe_doc>* Retrieves BitmapData of current FlxFrame</haxe_doc>
		</getFlxFrameBitmapData>
		<updateFrameData public="1" set="method" line="1848" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method for creating tileSheet for FlxSprite. Must be called after makeGraphic(), loadGraphic or loadRotatedGraphic().
	 * If you forget to call it then you will not see this FlxSprite on c++ target</haxe_doc>
		</updateFrameData>
		<overlapsPoint public="1" set="method" line="1822" override="1"><f a="point:?InScreenSpace:?Camera">
	<c path="flixel.util.FlxPoint"/>
	<x path="Bool"/>
	<c path="flixel.FlxCamera"/>
	<x path="Bool"/>
</f></overlapsPoint>
		<set_blend set="method" line="1793"><f a="Value">
	<e path="flash.display.BlendMode"/>
	<e path="flash.display.BlendMode"/>
</f></set_blend>
		<get_blend get="inline" set="null" line="1788"><f a=""><e path="flash.display.BlendMode"/></f></get_blend>
		<blend public="1" get="accessor" set="accessor"><e path="flash.display.BlendMode"/></blend>
		<get_colorTransform set="method" line="1780"><f a=""><c path="flash.geom.ColorTransform"/></f></get_colorTransform>
		<set_angle set="method" line="1774" override="1"><f a="Value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_angle>
		<_cosAngle><x path="Float"/></_cosAngle>
		<_sinAngle><x path="Float"/></_sinAngle>
		<_angleChanged><x path="Bool"/></_angleChanged>
		<simpleRenderSprite get="inline" set="null" line="1761"><f a=""><x path="Bool"/></f></simpleRenderSprite>
		<get_simpleRender set="method" line="1756"><f a=""><x path="Bool"/></f></get_simpleRender>
		<simpleRender public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* If the Sprite is being rendered in "simple mode" (via copyPixels). True for flash when no angle, bakedRotations, 
	 * scaling or blend modes are used. This enables the sprite to be rendered much faster if true.</haxe_doc>
		</simpleRender>
		<bakedRotation public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* How many frames of "baked" rotation there are (if any).</haxe_doc>
		</bakedRotation>
		<calcFrame set="method" line="1708">
			<f a="?AreYouSure">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function to update the current animation frame.</haxe_doc>
		</calcFrame>
		<pixelsOverlapPoint public="1" set="method" line="1673">
			<f a="point:?Mask:?Camera">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if a point in 2D world space overlaps this <code>FlxSprite</code> object's current displayed pixels.
	 * This check is ALWAYS made in screen space, and always takes scroll factors into account.
	 * @param	Point		The point in world space you want to check.
	 * @param	Mask		Used in the pixel hit test to determine what counts as solid.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.]]></haxe_doc>
		</pixelsOverlapPoint>
		<onScreen public="1" set="method" line="1596" override="1">
			<f a="?Camera">
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Check and see if this object is currently on screen.
	 * Differs from <code>FlxObject</code>'s implementation
	 * in that it takes the actual graphic into account,
	 * not just the hitbox or bounding box or whatever.
	 * @param	Camera		Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether the object is on screen or not.]]></haxe_doc>
		</onScreen>
		<set_curAnim get="inline" set="null" line="1582">
			<f a="AnimName">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Plays a specified animation (same as calling play)
	 * @param	AnimName	The name of the animation you want to play.</haxe_doc>
		</set_curAnim>
		<get_curAnim set="method" line="1571"><f a=""><c path="String"/></f></get_curAnim>
		<curAnim public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* The currently playing animation, or null if no animation is playing</haxe_doc>
		</curAnim>
		<getFrameIndex public="1" get="inline" set="null" line="1561">
			<f a="Frame">
				<c path="flixel.system.layer.frames.FlxFrame"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Helper function used for finding index of FlxFrame in _framesData's frames array
	 * @param	Frame	FlxFrame to find
	 * @return	position of specified FlxFrame object.</haxe_doc>
		</getFrameIndex>
		<set_frameName set="method" line="1538"><f a="Value">
	<c path="String"/>
	<c path="String"/>
</f></set_frameName>
		<get_frameName set="method" line="1528"><f a=""><c path="String"/></f></get_frameName>
		<frameName public="1" get="accessor" set="accessor">
			<c path="String"/>
			<haxe_doc>* Tell the sprite to change to a frame with specific name.
	 * Useful for sprites with loaded TexturePacker atlas.</haxe_doc>
		</frameName>
		<set_frame set="method" line="1507"><f a="Frame">
	<x path="Int"/>
	<x path="Int"/>
</f></set_frame>
		<get_frame set="method" line="1502"><f a=""><x path="Int"/></f></get_frame>
		<frame public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Tell the sprite to change to a specific frame of animation.</haxe_doc>
		</frame>
		<updateColorTransform set="method" line="1465"><f a=""><x path="Void"/></f></updateColorTransform>
		<set_color set="method" line="1445"><f a="Color">
	<x path="Int"/>
	<x path="Int"/>
</f></set_color>
		<color public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Set <code>color</code> to a number in this format: 0xRRGGBB. <code>color</code> IGNORES ALPHA.  
	 * To change the opacity use <code>alpha</code>. Tints the whole sprite to be this color (similar to OpenGL vertex colors).]]></haxe_doc>
		</color>
		<set_alpha set="method" line="1420">
			<f a="Alpha">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</set_alpha>
		<alpha public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Set <code>alpha</code> to a number between 0 and 1 to change the opacity of the sprite.]]></haxe_doc>
		</alpha>
		<set_facing set="method" line="1399">
			<f a="Direction">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</set_facing>
		<set_pixels set="method" line="1374"><f a="Pixels">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
</f></set_pixels>
		<get_pixels set="method" line="1369"><f a=""><c path="flash.display.BitmapData"/></f></get_pixels>
		<pixels public="1" get="accessor" set="accessor">
			<c path="flash.display.BitmapData"/>
			<haxe_doc><![CDATA[* Set <code>pixels</code> to any <code>BitmapData</code> object.
	 * Automatically adjust graphic size and render helpers.]]></haxe_doc>
		</pixels>
		<replaceColor public="1" set="method" line="1328">
			<f a="Color:NewColor:?FetchPositions">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc>* Replaces all pixels with specified Color with NewColor pixels
	 * @param	Color				Color to replace
	 * @param	NewColor			New color
	 * @param	FetchPositions		Whether we need to store positions of pixels which colors were replaced
	 * @return	Array replaced pixels positions</haxe_doc>
		</replaceColor>
		<centerOffsets public="1" set="method" line="1310">
			<f a="?AdjustPosition">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function that adjusts the offset automatically to center the bounding box within the graphic.
	 * @param	AdjustPosition		Adjusts the actual X and Y position just once to match the offset change. Default is false.</haxe_doc>
		</centerOffsets>
		<randomFrame public="1" set="method" line="1292">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Tell the sprite to change to a random frame of animation
	 * Useful for instantiating particles or other weird things.</haxe_doc>
		</randomFrame>
		<get_animations set="method" line="1283"><f a=""><x path="Map">
	<c path="String"/>
	<c path="flixel.system.FlxAnim"/>
</x></f></get_animations>
		<animations public="1" get="accessor" set="null"><x path="Map">
	<c path="String"/>
	<c path="flixel.system.FlxAnim"/>
</x></animations>
		<getAnimation public="1" get="inline" set="null" line="1276">
			<f a="Name">
				<c path="String"/>
				<c path="flixel.system.FlxAnim"/>
			</f>
			<haxe_doc>* Gets the FlxAnim object with the specified name.</haxe_doc>
		</getAnimation>
		<resumeAnimation public="1" get="inline" set="null" line="1267">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resumes current animation if it's exist and not finished</haxe_doc>
		</resumeAnimation>
		<pauseAnimation public="1" get="inline" set="null" line="1259">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Pauses current animation</haxe_doc>
		</pauseAnimation>
		<gotoAndStop public="1" set="method" line="1226">
			<f a="?Frame">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends the playhead to the specified frame in current animation and pauses it there.
	 * @param	Frame	frame number in current animation</haxe_doc>
		</gotoAndStop>
		<gotoAndPlay public="1" set="method" line="1212">
			<f a="?Frame">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sends the playhead to the specified frame in current animation and plays from that frame.
	 * @param	Frame	frame number in current animation</haxe_doc>
		</gotoAndPlay>
		<play public="1" set="method" line="1156">
			<f a="AnimName:?Force:?Frame">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Plays an existing animation (e.g. "run").
	 * If you call an animation that is already playing it will be ignored.
	 * @param	AnimName	The string name of the animation you want to play.
	 * @param	Force		Whether to force the animation to restart.
	 * @param	Frame		The frame number in animation you want to start from (0 by default). If you pass negative value then it will start from random frame</haxe_doc>
		</play>
		<addAnimationCallback public="1" set="method" line="1144">
			<f a="AnimationCallback">
				<f a="::">
					<c path="String"/>
					<x path="Int"/>
					<x path="Int"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>* Pass in a function to be called whenever this sprite's animation changes.
	 * @param	AnimationCallback		A function that has 3 parameters: a string name, a uint frame number, and a uint frame index.</haxe_doc>
		</addAnimationCallback>
		<addAnimationByPrefixFromTexture public="1" set="method" line="1106">
			<f a="Name:Prefix:?FrameRate:?Looped">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new animation to the sprite.
	 * @param	Name			What this animation should be called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	FrameRate		The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the animation is looped or just plays once.</haxe_doc>
		</addAnimationByPrefixFromTexture>
		<addAnimationByIndiciesFromTexture public="1" set="method" line="1076">
			<f a="Name:Prefix:Indicies:Postfix:?FrameRate:?Looped">
				<c path="String"/>
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new animation to the sprite.
	 * @param	Name			What this animation should be called (e.g. "run").
	 * @param	Prefix			Common beginning of image names in atlas (e.g. "tiles-")
	 * @param	Indicies		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	Postfix			Common ending of image names in atlas (e.g. ".png")
	 * @param	FrameRate		The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the animation is looped or just plays once.</haxe_doc>
		</addAnimationByIndiciesFromTexture>
		<addAnimationByNamesFromTexture public="1" set="method" line="1044">
			<f a="Name:FrameNames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new animation to the sprite.
	 * @param	Name			What this animation should be called (e.g. "run").
	 * @param	FrameNames		An array of image names from atlas indicating what frames to play in what order.
	 * @param	FrameRate		The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped			Whether or not the animation is looped or just plays once.</haxe_doc>
		</addAnimationByNamesFromTexture>
		<addAnimation public="1" set="method" line="1021">
			<f a="Name:Frames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds a new animation to the sprite.
	 * @param	Name		What this animation should be called (e.g. "run").
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3).
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40 fps).
	 * @param	Looped		Whether or not the animation is looped or just plays once.</haxe_doc>
		</addAnimation>
		<drawFrame public="1" set="method" line="1002">
			<f a="?Force">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Request (or force) that the sprite update the frame before rendering.
	 * Useful if you are doing procedural generation or other weirdness!
	 * @param	Force	Force the frame to redraw, even if its not flagged as necessary.</haxe_doc>
		</drawFrame>
		<updateAnimation set="method" line="937">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Internal function for updating the sprite's animation.
	 * Useful for cases when you need to update this but are buried down in too many supers.
	 * This function is called automatically by <code>FlxSprite.postUpdate()</code>.]]></haxe_doc>
		</updateAnimation>
		<stamp public="1" set="method" line="891">
			<f a="Brush:?X:?Y">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws or stamps one <code>FlxSprite</code> onto another.
	 * This function is NOT intended to replace <code>draw()</code>!
	 * @param	Brush		The image you want to use as a brush or stamp or pen or whatever.
	 * @param	X			The X coordinate of the brush's top left corner on this sprite.
	 * @param	Y			They Y coordinate of the brush's top left corner on this sprite.]]></haxe_doc>
		</stamp>
		<draw public="1" set="method" line="704" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<update public="1" set="method" line="694" override="1"><f a=""><x path="Void"/></f></update>
		<resetHelpers set="method" line="664">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets some important variables for sprite optimization and rendering.</haxe_doc>
		</resetHelpers>
		<setOriginToCenter public="1" get="inline" set="null" line="656"><f a=""><x path="Void"/></f></setOriginToCenter>
		<resetSizeFromFrame public="1" get="inline" set="null" line="650">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets sprite's size back to frame size</haxe_doc>
		</resetSizeFromFrame>
		<resetFrameSize get="inline" set="null" line="640">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets frame size to _flxFrame dimensions</haxe_doc>
		</resetFrameSize>
		<resetSize get="inline" set="null" line="629">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets _flashRect variable used for frame bitmapData calculation</haxe_doc>
		</resetSize>
		<loadRotatedImageFromTexture public="1" set="method" line="605">
			<f a="Data:Image:?Rotations:?AntiAliasing:?AutoBuffer">
				<d/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Creates a pre-rotated sprite sheet from provided image in atlas.
	 * This can make a huge difference in graphical performance on flash target!
	 * @param	Data			Atlas data holding links to json-data and atlas image
	 * @param	Image			The image from atlas you want to rotate and stamp.
	 * @param	Rotations		The number of rotation frames the final sprite should have.  For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic.  Default is false.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.
	 * 
	 * @return This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadRotatedImageFromTexture>
		<loadImageFromTexture public="1" set="method" line="555">
			<f a="Data:?Reverse:?Unique:?FrameName">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Loads TexturePacker atlas.
	 * @param	Data		Atlas data holding links to json-data and atlas image
	 * @param	Reverse		Whether you need this class to generate horizontally flipped versions of the animation frames. 
	 * @param	Unique		Optional, whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	FrameName	Default frame to show. If null then will be used first available frame.
	 * 
	 * @return This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadImageFromTexture>
		<makeGraphic public="1" set="method" line="530">
			<f a="Width:Height:?Color:?Unique:?Key">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* This function creates a flat colored square image dynamically.
	 * @param	Width		The width of the sprite you want to generate.
	 * @param	Height		The height of the sprite you want to generate.
	 * @param	Color		Specifies the color of the generated block.
	 * @param	Unique		Whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	Key			Optional parameter - specify a string key to identify this graphic in the cache.  Trumps Unique flag.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</makeGraphic>
		<loadRotatedGraphic public="1" set="method" line="379">
			<f a="Graphic:?Rotations:?Frame:?AntiAliasing:?AutoBuffer:?Key">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Create a pre-rotated sprite sheet from a simple sprite.
	 * This can make a huge difference in graphical performance!
	 * @param	Graphic			The image you want to rotate and stamp.
	 * @param	Rotations		The number of rotation frames the final sprite should have.  For small sprites this can be quite a large number (360 even) without any problems.
	 * @param	Frame			If the Graphic has a single row of square animation frames on it, you can specify which of the frames you want to use here.  Default is -1, or "use whole graphic."
	 * @param	AntiAliasing	Whether to use high quality rotations when creating the graphic.  Default is false.
	 * @param	AutoBuffer		Whether to automatically increase the image size to accomodate rotated corners.  Default is false.  Will create frames that are 150% larger on each axis than the original frame or graphic.
	 * @param	Key			Optional, set this parameter if you're loading BitmapData.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadRotatedGraphic>
		<loadGraphic public="1" set="method" line="318">
			<f a="Graphic:?Animated:?Reverse:?Width:?Height:?Unique:?Key">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Load an image from an embedded graphic file.
	 * @param	Graphic		The image you want to use.
	 * @param	Animated	Whether the Graphic parameter is a single sprite or a row of sprites.
	 * @param	Reverse		Whether you need this class to generate horizontally flipped versions of the animation frames.
	 * @param	Width		Optional, specify the width of your sprite (helps FlxSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Height		Optional, specify the height of your sprite (helps FlxSprite figure out what to do with non-square sprites or sprite sheets).
	 * @param	Unique		Optional, whether the graphic should be a unique instance in the graphics cache.  Default is false.
	 * @param	Key			Optional, set this parameter if you're loading BitmapData.
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadGraphic>
		<loadFromSprite public="1" set="method" line="280">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Load graphic from another FlxSprite and copy its tileSheet data. 
	 * This method can useful for non-flash targets (and is used by the FlxTrail effect).
	 * @param	Sprite	The FlxSprite from which you want to load graphic data
	 * @return	This FlxSprite instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</loadFromSprite>
		<destroyAnimations set="method" line="257"><f a=""><x path="Void"/></f></destroyAnimations>
		<destroy public="1" set="method" line="228" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* WARNING: This will remove this object entirely. Use <code>kill()</code> if you want to disable it temporarily only and <code>reset()</code> it later to revive it.
	 * Override this function to null out variables manually or call destroy() on class members if necessary. Don't forget to call super.destroy()!]]></haxe_doc>
		</destroy>
		<_halfHeight><x path="Float"/></_halfHeight>
		<_halfWidth>
			<x path="Float"/>
			<haxe_doc>* These vars are being used for rendering in some of FlxSprite subclasses (FlxTileblock, FlxBar, 
	 * FlxBitmapFont and FlxBitmapTextField) and for checks if the sprite is in camera's view.</haxe_doc>
		</_halfWidth>
		<_facingMult><x path="Int"/></_facingMult>
		<_blue><x path="Float"/></_blue>
		<_green><x path="Float"/></_green>
		<_red><x path="Float"/></_red>
		<_flxFrame>
			<c path="flixel.system.layer.frames.FlxFrame"/>
			<haxe_doc>* Link to current FlxFrame from loaded atlas</haxe_doc>
		</_flxFrame>
		<_matrix>
			<c path="flash.geom.Matrix"/>
			<haxe_doc>* Internal, helps with animation, caching and drawing.</haxe_doc>
		</_matrix>
		<useColorTransform public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Internal, reflects the need to use _colorTransform object</haxe_doc>
		</useColorTransform>
		<_colorTransform>
			<c path="flash.geom.ColorTransform"/>
			<haxe_doc>* Internal, helps with animation, caching and drawing.</haxe_doc>
		</_colorTransform>
		<_flashPointZero>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating. Always contains (0,0).</haxe_doc>
		</_flashPointZero>
		<_flashRect2>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect2>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashRect>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, reused frequently during drawing and animating.</haxe_doc>
		</_flashPoint>
		<_callback>
			<f a="::">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal tracker for the animation callback.  Default is null. If assigned, will be called each time the current frame changes.
	 * A function that has 3 parameters: a string name, a uint frame number, and a uint frame index.</haxe_doc>
		</_callback>
		<_frameTimer>
			<x path="Float"/>
			<haxe_doc>* Internal, used to time each frame of animation.</haxe_doc>
		</_frameTimer>
		<_curIndex>
			<x path="Int"/>
			<haxe_doc>* Internal, keeps track of the current index into the tile sheet based on animation or rotation.</haxe_doc>
		</_curIndex>
		<_curAnim>
			<c path="flixel.system.FlxAnim"/>
			<haxe_doc>* Internal, keeps track of the current animation being played.</haxe_doc>
		</_curAnim>
		<_animations>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.system.FlxAnim"/>
			</x>
			<haxe_doc>* Internal, stores all the animations that were added to this sprite.</haxe_doc>
		</_animations>
		<colorTransform public="1" get="accessor" set="null"><c path="flash.geom.ColorTransform"/></colorTransform>
		<antialiasing public="1">
			<x path="Bool"/>
			<haxe_doc>* Controls whether the object is smoothed when rotated, affects performance.
	 * @default false</haxe_doc>
		</antialiasing>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* Set this flag to true to force the sprite to update during the draw() call.
	 * NOTE: Rarely if ever necessary, most sprite operations will flip this flag automatically.</haxe_doc>
		</dirty>
		<framePixels public="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc><![CDATA[* The actual Flash <code>BitmapData</code> object representing the current display state of the sprite.]]></haxe_doc>
		</framePixels>
		<frames public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The total number of frames in this image.  WARNING: assumes each row in the sprite sheet is full!</haxe_doc>
		</frames>
		<frameHeight public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The height of the actual graphic or image being displayed (not necessarily the game object/bounding box).</haxe_doc>
		</frameHeight>
		<frameWidth public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The width of the actual graphic or image being displayed (not necessarily the game object/bounding box).</haxe_doc>
		</frameWidth>
		<paused public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether the current animation gets updated or not.</haxe_doc>
		</paused>
		<curFrame public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Internal, keeps track of the current frame of animation.
	 * This is NOT an index into the tile sheet, but the frame number in the animation object.</haxe_doc>
		</curFrame>
		<finished public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the current animation has finished its first (or only) loop.</haxe_doc>
		</finished>
		<_blendInt><x path="Int"/></_blendInt>
		<_blend>
			<e path="flash.display.BlendMode"/>
			<haxe_doc>* Blending modes, just like Photoshop or whatever, e.g. "multiply", "screen", etc.
	 * @default null</haxe_doc>
		</_blend>
		<scale public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Change the size of your sprite's graphic. NOTE: Scale doesn't currently affect collisions automatically, you will need to adjust the width, 
	 * height and offset manually. WARNING: scaling sprites decreases rendering performance for this sprite by a factor of 10x!</haxe_doc>
		</scale>
		<offset public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc><![CDATA[* Controls the position of the sprite's hitbox. Likely needs to be adjusted after
     * changing a sprite's <code>width</code> or <code>height</code>.]]></haxe_doc>
		</offset>
		<origin public="1">
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* WARNING: The origin of the sprite will default to its center. If you change this, 
	 * the visuals and the collisions will likely be pretty out-of-sync if you do any rotation.</haxe_doc>
		</origin>
		<flipped public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* If the Sprite is flipped. Shouldn't be changed unless you know what are you doing.</haxe_doc>
		</flipped>
		<isColored public="1" set="null"><x path="Bool"/></isColored>
		<facing public="1" set="accessor">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Set <code>facing</code> using <code>FlxObject.LEFT</code>,<code>RIGHT</code>, <code>UP</code>, 
	 * and <code>DOWN</code> to take advantage of flipped sprites and/or just track player orientation more easily.]]></haxe_doc>
		</facing>
		<new public="1" set="method" line="201">
			<f a="?X:?Y:?SimpleGraphic">
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a white 8x8 square <code>FlxSprite</code> at the specified position. Optionally can load a simple, one-frame graphic instead.
	 * @param	X				The initial X position of the sprite.
	 * @param	Y				The initial Y position of the sprite.
	 * @param	SimpleGraphic	The graphic you want to display (OPTIONAL - for simple stuff only, do NOT use for animated images!).]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* The main "game object" class, the sprite is a <code>FlxObject</code>
 * with a bunch of graphics options and abilities, like animation and stamping.]]></haxe_doc>
	</class>
	<class path="flixel.group.FlxGroup" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/group/FlxGroup.hx">
		<extends path="flixel.group.FlxTypedGroup"><c path="flixel.FlxBasic"/></extends>
		<new public="1" set="method" line="17">
			<f a="?MaxSize">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new <code>FlxGroup</code>
	 * 
	 * @param	MaxSize		Maximum amount of members allowed]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* This is an organizational class that can update and render a bunch of <code>FlxBasic</code>s.
 * NOTE: Although <code>FlxGroup</code> extends <code>FlxBasic</code>, it will not automatically
 * add itself to the global collisions quad tree, it will only add its members.]]></haxe_doc>
	</class>
	<class path="flixel.FlxState" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxState.hx">
		<extends path="flixel.group.FlxGroup"/>
		<onResize public="1" set="method" line="238">
			<f a="Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function is called whenever the window size has been changed.
	 * @param 	Width	The new window width
	 * @param 	Height	The new window Height</haxe_doc>
		</onResize>
		<onFocus public="1" set="method" line="231">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is called after application gets focus.
	 * Can be useful if you using third part libraries, such as tweening engines.</haxe_doc>
		</onFocus>
		<onFocusLost public="1" set="method" line="225">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This method is called after application losts its focus.
	 * Can be useful if you using third part libraries, such as tweening engines.</haxe_doc>
		</onFocusLost>
		<destroy public="1" set="method" line="211" override="1"><f a=""><x path="Void"/></f></destroy>
		<subStateCloseHandler set="method" line="195">
			<f a="?Destroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper method for closing substate
	 * @param	Destroy		Whether to destroy current substate (by default) or leave it as is, so closed substate can be reused many times</haxe_doc>
		</subStateCloseHandler>
		<setSubState public="1" set="method" line="156">
			<f a="RequestedState:?CloseCallback:?DestroyPrevious">
				<c path="flixel.FlxSubState"/>
				<f a=""><x path="Void"/></f>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set substate for this state
	 * @param	RequestedState		The FlxSubState to add
	 * @param	CloseCallback		Close callback function, which will be called after closing requestedState
	 * @param	DestroyPrevious		Whether to destroy previuos substate (if there is one) or not</haxe_doc>
		</setSubState>
		<closeSubState public="1" get="inline" set="null" line="145">
			<f a="?Destroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Manually close the sub-state</haxe_doc>
		</closeSubState>
		<tryUpdate public="1" set="method" line="129"><f a=""><x path="Void"/></f></tryUpdate>
		<drawDebug public="1" set="method" line="115" override="1"><f a=""><x path="Void"/></f></drawDebug>
		<draw public="1" set="method" line="101" override="1"><f a=""><x path="Void"/></f></draw>
		<create public="1" set="method" line="99">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* This function is called after the game engine successfully switches states. Override this function, NOT the constructor, to initialize or set up your game state.
	 * We do NOT recommend overriding the constructor, unless you want some crazy unpredictable things to happen!</haxe_doc>
		</create>
		<updateMouseVisibility set="method" line="69"><f a=""><x path="Void"/></f></updateMouseVisibility>
		<set_useMouse get="inline" set="null" line="63"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useMouse>
		<get_useMouse get="inline" set="null" line="61"><f a=""><x path="Bool"/></f></get_useMouse>
		<useMouse public="1" get="accessor" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Whether to show mouse pointer or not</haxe_doc>
		</useMouse>
		<_useMouse><x path="Bool"/></_useMouse>
		<set_bgColor set="method" line="49"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColor>
		<get_bgColor set="method" line="44"><f a=""><x path="Int"/></f></get_bgColor>
		<bgColor public="1" get="accessor" set="accessor"><x path="Int"/></bgColor>
		<_bgColor>
			<x path="Int"/>
			<haxe_doc>* Background color of this state</haxe_doc>
		</_bgColor>
		<get_subState get="inline" set="null" line="32"><f a=""><c path="flixel.FlxSubState"/></f></get_subState>
		<subState public="1" get="accessor" set="null">
			<c path="flixel.FlxSubState"/>
			<haxe_doc>* Current substate.
	 * Substates also can have substates</haxe_doc>
		</subState>
		<_subState><c path="flixel.FlxSubState"/></_subState>
		<persistentDraw public="1">
			<x path="Bool"/>
			<haxe_doc>* Determines whether or not this state is updated even when it is not the active state. For example, if you have your game state first, and then you push a menu state on top of it, if this is set to true, the game state would continue to be drawn behind the pause state.
	* By default this is true, so background states will continue to be drawn behind the current state. If background states are not visible when you have a different state on top, you should set this to false for improved performance.
	* @default true</haxe_doc>
		</persistentDraw>
		<persistentUpdate public="1">
			<x path="Bool"/>
			<haxe_doc>* Determines whether or not this state is updated even when it is not the active state. For example, if you have your game state first, and then you push a menu state on top of it,
	* if this is set to true, the game state would continue to update in the background. By default this is false, so background states will be "paused" when they are not active.
	* @default false</haxe_doc>
		</persistentUpdate>
		<new public="1" set="method" line="84">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* State constructor</haxe_doc>
		</new>
		<haxe_doc>* This is the basic game "state" object - e.g. in a simple game you might have a menu state and a play state.
 * It is for all intents and purpose a fancy FlxGroup. And really, it's not even that fancy.</haxe_doc>
	</class>
	<class path="flixel.FlxSubState" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/FlxSubState.hx">
		<extends path="flixel.FlxState"/>
		<destroy public="1" set="method" line="120" override="1"><f a=""><x path="Void"/></f></destroy>
		<close public="1" set="method" line="105">
			<f a="?Destroy">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Use this method to close this substate
	 * @param	destroy	whether to destroy this state or leave it in memory</haxe_doc>
		</close>
		<draw public="1" set="method" line="81" override="1"><f a=""><x path="Void"/></f></draw>
		<set_bgColor set="method" line="69" override="1"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_bgColor>
		<get_bgColor set="method" line="64" override="1"><f a=""><x path="Int"/></f></get_bgColor>
		<initialize public="1" get="inline" set="null" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal helper method</haxe_doc>
		</initialize>
		<get_initialized get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_initialized>
		<initialized public="1" get="accessor" set="null"><x path="Bool"/></initialized>
		<_initialized>
			<x path="Bool"/>
			<haxe_doc>* Internal helper for substates which can be reused</haxe_doc>
		</_initialized>
		<_bgSprite>
			<c path="flixel.system.FlxBGSprite"/>
			<haxe_doc>* Helper sprite object for non-flash targets. Draws background</haxe_doc>
		</_bgSprite>
		<closeCallback public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Callback method for state close event</haxe_doc>
		</closeCallback>
		<_parentState public="1">
			<c path="flixel.FlxState"/>
			<haxe_doc>* Internal helper</haxe_doc>
		</_parentState>
		<new public="1" set="method" line="52">
			<f a="?BGColor:?UseMouse">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Substate constructor
	 * @param	BGColor		background color for this substate
	 * @param	UseMouse	whether to show mouse pointer or not</haxe_doc>
		</new>
		<haxe_doc>* This is the basic game "state" object - e.g. in a simple game you might have a menu state and a play state.
 * It is for all intents and purpose a fancy FlxGroup. And really, it's not even that fancy.</haxe_doc>
	</class>
	<class path="flixel.system.FlxAnim" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxAnim.hx">
		<clone public="1" set="method" line="64"><f a=""><c path="flixel.system.FlxAnim"/></f></clone>
		<set_frameRate set="method" line="53"><f a="value">
	<x path="Float"/>
	<x path="Float"/>
</f></set_frameRate>
		<frameRate public="1" set="accessor">
			<x path="Float"/>
			<haxe_doc>* Animation frameRate - the speed in frames per second that the animation should play at.</haxe_doc>
		</frameRate>
		<destroy public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<looped public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the animation is looped</haxe_doc>
		</looped>
		<frames public="1">
			<c path="Array"><x path="Int"/></c>
			<haxe_doc><![CDATA[* A list of frames stored as <code>int</code> objects]]></haxe_doc>
		</frames>
		<delay public="1">
			<x path="Float"/>
			<haxe_doc>* Seconds between frames (basically the framerate)</haxe_doc>
		</delay>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* String name of the animation (e.g. "walk")</haxe_doc>
		</name>
		<new public="1" set="method" line="32">
			<f a="Name:Frames:?FrameRate:?Looped">
				<c path="String"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	Name		What this animation should be called (e.g. "run")
	 * @param	Frames		An array of numbers indicating what frames to play in what order (e.g. 1, 2, 3)
	 * @param	FrameRate	The speed in frames per second that the animation should play at (e.g. 40)
	 * @param	Looped		Whether or not the animation is looped or just plays once</haxe_doc>
		</new>
		<haxe_doc>* Just a helper structure for the FlxSprite animation system.</haxe_doc>
	</class>
	<class path="flixel.system._FlxAssets.FontDefault" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxAssets.hx" private="1" module="flixel.system.FlxAssets">
		<extends path="flash.text.Font"/>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":font"><e>"assets/fonts/nokiafc22.ttf"</e></m></meta>
	</class>
	<class path="flixel.system._FlxAssets.FontDebugger" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxAssets.hx" private="1" module="flixel.system.FlxAssets">
		<extends path="flash.text.Font"/>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<meta><m n=":font"><e>"assets/fonts/arial.ttf"</e></m></meta>
	</class>
	<class path="flixel.system.FlxAssets" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxAssets.hx">
		<IMG_WINDOW_HANDLE public="1" get="inline" set="null" line="17" static="1"><c path="String"/></IMG_WINDOW_HANDLE>
		<IMG_FLIXEL public="1" get="inline" set="null" line="18" static="1"><c path="String"/></IMG_FLIXEL>
		<IMG_VISUAL_DEBUG public="1" get="inline" set="null" line="21" static="1"><c path="String"/></IMG_VISUAL_DEBUG>
		<IMG_OPEN public="1" get="inline" set="null" line="22" static="1"><c path="String"/></IMG_OPEN>
		<IMG_RECORD_OFF public="1" get="inline" set="null" line="23" static="1"><c path="String"/></IMG_RECORD_OFF>
		<IMG_RECORD_ON public="1" get="inline" set="null" line="24" static="1"><c path="String"/></IMG_RECORD_ON>
		<IMG_STOP public="1" get="inline" set="null" line="25" static="1"><c path="String"/></IMG_STOP>
		<IMG_RESTART public="1" get="inline" set="null" line="26" static="1"><c path="String"/></IMG_RESTART>
		<IMG_PAUSE public="1" get="inline" set="null" line="27" static="1"><c path="String"/></IMG_PAUSE>
		<IMG_PLAY public="1" get="inline" set="null" line="28" static="1"><c path="String"/></IMG_PLAY>
		<IMG_STEP public="1" get="inline" set="null" line="29" static="1"><c path="String"/></IMG_STEP>
		<IMG_LOGO public="1" get="inline" set="null" line="32" static="1"><c path="String"/></IMG_LOGO>
		<IMG_DEFAULT public="1" get="inline" set="null" line="33" static="1"><c path="String"/></IMG_DEFAULT>
		<IMG_CORNERS public="1" get="inline" set="null" line="36" static="1"><c path="String"/></IMG_CORNERS>
		<IMG_LIGHT public="1" get="inline" set="null" line="37" static="1"><c path="String"/></IMG_LIGHT>
		<IMG_AUTO public="1" get="inline" set="null" line="40" static="1"><c path="String"/></IMG_AUTO>
		<IMG_AUTO_ALT public="1" get="inline" set="null" line="41" static="1"><c path="String"/></IMG_AUTO_ALT>
		<IMG_BUTTON public="1" get="inline" set="null" line="44" static="1"><c path="String"/></IMG_BUTTON>
		<IMG_CURSOR public="1" get="inline" set="null" line="45" static="1"><c path="String"/></IMG_CURSOR>
		<IMG_BASE public="1" get="inline" set="null" line="48" static="1"><c path="String"/></IMG_BASE>
		<IMG_THUMB public="1" get="inline" set="null" line="49" static="1"><c path="String"/></IMG_THUMB>
		<IMG_BUTTON_A public="1" get="inline" set="null" line="51" static="1"><c path="String"/></IMG_BUTTON_A>
		<IMG_BUTTON_B public="1" get="inline" set="null" line="52" static="1"><c path="String"/></IMG_BUTTON_B>
		<IMG_BUTTON_C public="1" get="inline" set="null" line="53" static="1"><c path="String"/></IMG_BUTTON_C>
		<IMG_BUTTON_X public="1" get="inline" set="null" line="54" static="1"><c path="String"/></IMG_BUTTON_X>
		<IMG_BUTTON_Y public="1" get="inline" set="null" line="55" static="1"><c path="String"/></IMG_BUTTON_Y>
		<IMG_BUTTON_UP public="1" get="inline" set="null" line="56" static="1"><c path="String"/></IMG_BUTTON_UP>
		<IMG_BUTTON_DOWN public="1" get="inline" set="null" line="57" static="1"><c path="String"/></IMG_BUTTON_DOWN>
		<IMG_BUTTON_LEFT public="1" get="inline" set="null" line="58" static="1"><c path="String"/></IMG_BUTTON_LEFT>
		<IMG_BUTTON_RIGHT public="1" get="inline" set="null" line="59" static="1"><c path="String"/></IMG_BUTTON_RIGHT>
		<FONT_DEFAULT public="1" get="inline" set="null" line="62" static="1"><c path="String"/></FONT_DEFAULT>
		<FONT_DEBUGGER public="1" get="inline" set="null" line="63" static="1"><c path="String"/></FONT_DEBUGGER>
		<SND_FLIXEL public="1" get="inline" set="null" line="66" static="1"><c path="String"/></SND_FLIXEL>
		<SND_BEEP public="1" get="inline" set="null" line="69" static="1"><c path="String"/></SND_BEEP>
		<init public="1" set="method" line="74" static="1"><f a=""><x path="Void"/></f></init>
		<drawLogo public="1" set="method" line="83" static="1"><f a="graph">
	<c path="flash.display.Graphics"/>
	<x path="Void"/>
</f></drawLogo>
		<getBitmapData public="1" get="inline" set="null" line="139" static="1"><f a="id">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</f></getBitmapData>
		<cacheSounds public="1" set="method" line="147" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sound caching for android target</haxe_doc>
		</cacheSounds>
	</class>
	<class path="flixel.system.FlxBGSprite" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxBGSprite.hx">
		<extends path="flixel.FlxSprite"/>
		<draw public="1" set="method" line="27" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by game loop, updates then blits or renders current frame of animation to the screen</haxe_doc>
		</draw>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc><![CDATA[* The main "game object" class, the sprite is a <code>FlxObject</code>
 * with a bunch of graphics options and abilities, like animation and stamping.]]></haxe_doc>
	</class>
	<class path="flixel.system.FlxList" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxList.hx">
		<_NUM_CACHED_FLX_LIST public="1" line="15" static="1">
			<x path="Int"/>
			<haxe_doc>* Pooling mechanism, when FlxLists are destroyed, they get added to this collection, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_FLX_LIST>
		<_cachedListsHead static="1"><c path="flixel.system.FlxList"/></_cachedListsHead>
		<recycle public="1" set="method" line="42" static="1">
			<f a=""><c path="flixel.system.FlxList"/></f>
			<haxe_doc>* Recycle a cached Linked List, or creates a new one if needed.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="61" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear cached List nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<destroy public="1" set="method" line="77">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<exists public="1"><x path="Bool"/></exists>
		<next public="1">
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Stores a reference to the next link in the list.</haxe_doc>
		</next>
		<object public="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc><![CDATA[* Stores a reference to a <code>FlxObject</code>.]]></haxe_doc>
		</object>
		<new set="method" line="32">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A miniature linked list class.
 * Useful for optimizing time-critical or highly repetitive tasks!
 * See <code>FlxQuadTree</code> for how to use it, IF YOU DARE.]]></haxe_doc>
	</class>
	<class path="flixel.system.FlxQuadTree" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxQuadTree.hx">
		<extends path="flixel.util.FlxRect"/>
		<A_LIST public="1" get="inline" set="null" line="20" static="1">
			<x path="Int"/>
			<haxe_doc>* Flag for specifying that you want to add an object to the A list.</haxe_doc>
		</A_LIST>
		<B_LIST public="1" get="inline" set="null" line="24" static="1">
			<x path="Int"/>
			<haxe_doc>* Flag for specifying that you want to add an object to the B list.</haxe_doc>
		</B_LIST>
		<divisions public="1" static="1">
			<x path="Int"/>
			<haxe_doc>* Controls the granularity of the quad tree.  Default is 6 (decent performance on large and small worlds).</haxe_doc>
		</divisions>
		<_min static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_min>
		<_object static="1">
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_object>
		<_objectLeftEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectLeftEdge>
		<_objectTopEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectTopEdge>
		<_objectRightEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectRightEdge>
		<_objectBottomEdge static="1">
			<x path="Float"/>
			<haxe_doc>* Internal, used to reduce recursive method parameters during object placement and tree formation.</haxe_doc>
		</_objectBottomEdge>
		<_list static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_list>
		<_useBothLists static="1">
			<x path="Bool"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_useBothLists>
		<_processingCallback static="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_processingCallback>
		<_notifyCallback static="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_notifyCallback>
		<_iterator static="1">
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Internal, used during tree processing and overlap checks.</haxe_doc>
		</_iterator>
		<_objectHullX static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullX>
		<_objectHullY static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullY>
		<_objectHullWidth static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullWidth>
		<_objectHullHeight static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_objectHullHeight>
		<_checkObjectHullX static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullX>
		<_checkObjectHullY static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullY>
		<_checkObjectHullWidth static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullWidth>
		<_checkObjectHullHeight static="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Internal, helpers for comparing actual object-to-object overlap - see <code>overlapNode()</code>.]]></haxe_doc>
		</_checkObjectHullHeight>
		<_NUM_CACHED_QUAD_TREES public="1" line="190" static="1">
			<x path="Int"/>
			<haxe_doc>* Pooling mechanism, turn FlxQuadTree into a linked list, when FlxQuadTrees are destroyed, they get added to the list, and when they get recycled they get removed.</haxe_doc>
		</_NUM_CACHED_QUAD_TREES>
		<_cachedTreesHead static="1"><c path="flixel.system.FlxQuadTree"/></_cachedTreesHead>
		<recycle public="1" set="method" line="211" static="1">
			<f a="X:Y:Width:Height:?Parent">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxQuadTree"/>
				<c path="flixel.system.FlxQuadTree"/>
			</f>
			<haxe_doc>* Recycle a cached Quad Tree node, or creates a new one if needed.
	 * @param	X			The X-coordinate of the point in space.
	 * @param	Y			The Y-coordinate of the point in space.
	 * @param	Width		Desired width of this node.
	 * @param	Height		Desired height of this node.
	 * @param	Parent		The parent branch or node.  Pass null to create a root.</haxe_doc>
		</recycle>
		<clearCache public="1" set="method" line="228" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clear cached Quad Tree nodes. You might want to do this when loading new levels (probably not though, no need to clear cache unless you run into memory problems).</haxe_doc>
		</clearCache>
		<overlapNode set="method" line="642">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* An internal function for comparing an object against the contents of a node.
	 * @return	Whether or not any overlaps were found.</haxe_doc>
		</overlapNode>
		<execute public="1" set="method" line="588">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[* <code>FlxQuadTree</code>'s other main function.  Call this after adding objects
	 * using <code>FlxQuadTree.load()</code> to compare the objects that you loaded.
	 * @return	Whether or not any overlaps were found.]]></haxe_doc>
		</execute>
		<addToList set="method" line="538">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for recursively adding objects to leaf lists.</haxe_doc>
		</addToList>
		<addObject set="method" line="447">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for recursively navigating and creating the tree
	 * while adding objects to the appropriate nodes.</haxe_doc>
		</addObject>
		<add public="1" set="method" line="395">
			<f a="ObjectOrGroup:list">
				<c path="flixel.FlxBasic"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to add an object to the root of the tree.
	 * This function will recursively add all group members, but
	 * not the groups themselves.
	 * @param	ObjectOrGroup	FlxObjects are just added, FlxGroups are recursed and their applicable members added accordingly.
	 * @param	List			A <code>int</code> flag indicating the list to which you want to add the objects.  Options are <code>A_LIST</code> and <code>B_LIST</code>.]]></haxe_doc>
		</add>
		<load public="1" set="method" line="372">
			<f a="ObjectOrGroup1:?ObjectOrGroup2:?NotifyCallback:?ProcessCallback">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxBasic"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Load objects and/or groups into the quad tree, and register notify and processing callbacks.
	 * @param ObjectOrGroup1	Any object that is or extends FlxObject or FlxGroup.
	 * @param ObjectOrGroup2	Any object that is or extends FlxObject or FlxGroup.  If null, the first parameter will be checked against itself.
	 * @param NotifyCallback	A function with the form <code>myFunction(Object1:FlxObject,Object2:FlxObject):void</code> that is called whenever two objects are found to overlap in world space, and either no ProcessCallback is specified, or the ProcessCallback returns true. 
	 * @param ProcessCallback	A function with the form <code>myFunction(Object1:FlxObject,Object2:FlxObject):Boolean</code> that is called whenever two objects are found to overlap in world space.  The NotifyCallback is only called if this function returns true.  See FlxObject.separate().]]></haxe_doc>
		</load>
		<destroy public="1" set="method" line="309">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<reset public="1" set="method" line="240"><f a="X:Y:Width:Height:?Parent">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="flixel.system.FlxQuadTree"/>
	<x path="Void"/>
</f></reset>
		<next><c path="flixel.system.FlxQuadTree"/></next>
		<_midpointY>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointY>
		<_midpointX>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_midpointX>
		<_halfHeight>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfHeight>
		<_halfWidth>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_halfWidth>
		<_bottomEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_bottomEdge>
		<_topEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_topEdge>
		<_rightEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_rightEdge>
		<_leftEdge>
			<x path="Float"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_leftEdge>
		<_southWestTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southWestTree>
		<_southEastTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_southEastTree>
		<_northEastTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northEastTree>
		<_northWestTree>
			<c path="flixel.system.FlxQuadTree"/>
			<haxe_doc>* Internal, governs and assists with the formation of the tree.</haxe_doc>
		</_northWestTree>
		<_tailB>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailB>
		<_headB>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headB>
		<_tailA>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_tailA>
		<_headA>
			<c path="flixel.system.FlxList"/>
			<haxe_doc>* Refers to the internal A and B linked lists,
	 * which are used to store objects in the leaves.</haxe_doc>
		</_headA>
		<_canSubdivide>
			<x path="Bool"/>
			<haxe_doc>* Whether this branch of the tree can be subdivided or not.</haxe_doc>
		</_canSubdivide>
		<exists public="1"><x path="Bool"/></exists>
		<new set="method" line="197">
			<f a="X:Y:Width:Height:?Parent">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.system.FlxQuadTree"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Private, use recycle instead.</haxe_doc>
		</new>
		<haxe_doc>* A fairly generic quad tree structure for rapid overlap checks.
 * FlxQuadTree is also configured for single or dual list operation.
 * You can add items either to its A list or its B list.
 * When you do an overlap check, you can compare the A list to itself,
 * or the A list against the B list.  Handy for different things!</haxe_doc>
	</class>
	<class path="flixel.system.FlxSound" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxSound.hx">
		<extends path="flixel.FlxBasic"/>
		<gotID3 set="method" line="596">
			<f a="?event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal event handler for ID3 info (i.e. fetching the song name).
	 * @param	event	An <code>Event</code> object.]]></haxe_doc>
		</gotID3>
		<cleanup set="method" line="561">
			<f a="destroySound:?resetPosition:?resetFading">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* An internal helper function used to help Flash clean up (and potentially re-use) finished sounds. Will stop the current sound and destroy the associated <code>SoundChannel</code>, plus, any other commands ordered by the passed in parameters.
	 * 
	 * @param  destroySound    Whether or not to destroy the sound. If this is true, the position and fading will be reset as well.
	 * @param  resetPosition    Whether or not to reset the position of the sound.
	 * @param  resetFading    Whether or not to reset the current fading variables of the sound.]]></haxe_doc>
		</cleanup>
		<stopped set="method" line="536">
			<f a="?event">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* An internal helper function used to help Flash clean up finished sounds or restart looped sounds.
	 * @param	event		An <code>Event</code> object.]]></haxe_doc>
		</stopped>
		<startSound set="method" line="514">
			<f a="Position">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* An internal helper function used to attempt to start playing the sound and populate the <code>_channel</code> variable.]]></haxe_doc>
		</startSound>
		<updateTransform set="method" line="502">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call after adjusting the volume to update the sound channel's settings.</haxe_doc>
		</updateTransform>
		<getActualVolume public="1" set="method" line="494">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the currently selected "real" volume of the sound (takes fades and proximity into account).
	 * @return	The adjusted volume of the sound.</haxe_doc>
		</getActualVolume>
		<set_volume set="method" line="475">
			<f a="Volume">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* @private</haxe_doc>
		</set_volume>
		<get_volume set="method" line="468"><f a=""><x path="Float"/></f></get_volume>
		<volume public="1" get="accessor" set="accessor">
			<x path="Float"/>
			<haxe_doc><![CDATA[* Set <code>volume</code> to a value between 0 and 1 to change how this sound is.]]></haxe_doc>
		</volume>
		<get_playing set="method" line="458"><f a=""><x path="Bool"/></f></get_playing>
		<playing public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Whether or not the sound is currently playing.</haxe_doc>
		</playing>
		<fadeIn public="1" set="method" line="436">
			<f a="Seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to make a sound fade in over a certain
	 * time interval (calls <code>play()</code> automatically).
	 * @param	Seconds		The amount of time the fade-in operation should take.]]></haxe_doc>
		</fadeIn>
		<fadeOut public="1" set="method" line="417">
			<f a="Seconds:?PauseInstead">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to make this sound fade out over a certain time interval.
	 * @param	Seconds			The amount of time the fade out operation should take.
	 * @param	PauseInstead	Tells the sound to pause on fadeout, instead of stopping.</haxe_doc>
		</fadeOut>
		<stop public="1" set="method" line="407">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this function to stop this sound.</haxe_doc>
		</stop>
		<pause public="1" set="method" line="393">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Call this function to pause this sound.</haxe_doc>
		</pause>
		<resume public="1" set="method" line="382">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unpause a sound.  Only works on sounds that have been paused.</haxe_doc>
		</resume>
		<play public="1" set="method" line="353">
			<f a="?ForceRestart">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Call this function to play the sound - also works on paused sounds.
	 * @param	ForceRestart	Whether to start the sound over or not.  Default value is false, meaning if the sound is already playing or was paused when you call <code>play()</code>, it will continue playing from its current position, NOT start again from the beginning.]]></haxe_doc>
		</play>
		<proximity public="1" set="method" line="339">
			<f a="X:Y:TargetObject:Radius:?Pan">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc>* Call this function if you want this sound's volume to change
	 * based on distance from a particular FlxCore object.
	 * 
	 * @param	X		The X position of the sound.
	 * @param	Y		The Y position of the sound.
	 * @param	TargetObject	The object you want to track.
	 * @param	Radius	The maximum distance this sound can travel.
	 * @param	Pan		Whether the sound should pan in addition to the volume changes (default: true).
	 * 
	 * @return	This FlxSound instance (nice for chaining stuff together, if you're into that).</haxe_doc>
		</proximity>
		<loadStream public="1" set="method" line="312">
			<f a="SoundURL:?Looped:?AutoDestroy:?OnComplete">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* One of two main setup functions for sounds, this function loads a sound from a URL.
	 * 
	 * @param	EmbeddedSound	A string representing the URL of the MP3 file you want to play.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this <code>FlxSound</code> instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.sound.play() and FlxG.sound.stream() will set it to true by default.
	 * 
	 * @return	This <code>FlxSound</code> instance (nice for chaining stuff together, if you're into that).]]></haxe_doc>
		</loadStream>
		<loadEmbedded public="1" set="method" line="277">
			<f a="EmbeddedSound:?Looped:?AutoDestroy:?OnComplete">
				<d/>
				<x path="Bool"/>
				<x path="Bool"/>
				<f a=""><x path="Void"/></f>
				<c path="flixel.system.FlxSound"/>
			</f>
			<haxe_doc><![CDATA[* One of two main setup functions for sounds, this function loads a sound from an embedded MP3.
	 * 
	 * @param	EmbeddedSound	An embedded Class object representing an MP3 file.
	 * @param	Looped			Whether or not this sound should loop endlessly.
	 * @param	AutoDestroy		Whether or not this <code>FlxSound</code> instance should be destroyed when the sound finishes playing.  Default value is false, but FlxG.sound.play() and FlxG.sound.stream() will set it to true by default.
	 * 
	 * @return	This <code>FlxSound</code> instance (nice for chaining stuff together, if you're into that).]]></haxe_doc>
		</loadEmbedded>
		<kill public="1" set="method" line="262" override="1"><f a=""><x path="Void"/></f></kill>
		<update public="1" set="method" line="193" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Handles fade out, fade in, panning, proximity, and amplitude operations each frame.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="163" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<reset set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* An internal function for clearing all the variables used by sounds.</haxe_doc>
		</reset>
		<_onFadeComplete>
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal flag for what to do when the sound is done fading out.</haxe_doc>
		</_onFadeComplete>
		<_fade>
			<c path="flixel.tweens.misc.NumTween"/>
			<haxe_doc>* Internal helper for fading sounds.</haxe_doc>
		</_fade>
		<_pan>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether to pan the sound left and right.  Default is false.</haxe_doc>
		</_pan>
		<_radius>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for the maximum effective radius of this sound (for proximity and panning).</haxe_doc>
		</_radius>
		<_target>
			<c path="flixel.FlxObject"/>
			<haxe_doc>* Internal tracker for the sound's "target" (for proximity and panning).</haxe_doc>
		</_target>
		<_looped>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is looping or not.</haxe_doc>
		</_looped>
		<_volumeAdjust>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for total volume adjustment.</haxe_doc>
		</_volumeAdjust>
		<_volume>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for how loud the sound is.</haxe_doc>
		</_volume>
		<_position>
			<x path="Float"/>
			<haxe_doc>* Internal tracker for the position in runtime of the music playback.</haxe_doc>
		</_position>
		<_paused>
			<x path="Bool"/>
			<haxe_doc>* Internal tracker for whether the sound is paused or not (not the same as stopped).</haxe_doc>
		</_paused>
		<_transform>
			<c path="flash.media.SoundTransform"/>
			<haxe_doc>* Internal tracker for a Flash sound transform object.</haxe_doc>
		</_transform>
		<_channel>
			<c path="flash.media.SoundChannel"/>
			<haxe_doc>* Internal tracker for a Flash sound channel object.</haxe_doc>
		</_channel>
		<_sound>
			<c path="flash.media.Sound"/>
			<haxe_doc>* Internal tracker for a Flash sound object.</haxe_doc>
		</_sound>
		<onComplete public="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Tracker for sound complete callback. Default is null.
	 * If assigend, will be called each time when sound reaches its end.
	 * Works only on flash and desktop targets.</haxe_doc>
		</onComplete>
		<autoDestroy public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to call destroy() when the sound has finished.</haxe_doc>
		</autoDestroy>
		<amplitudeRight public="1">
			<x path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeRight>
		<amplitudeLeft public="1">
			<x path="Float"/>
			<haxe_doc>* Just the amplitude of the left stereo channel</haxe_doc>
		</amplitudeLeft>
		<amplitude public="1">
			<x path="Float"/>
			<haxe_doc>* Stores the average wave amplitude of both stereo channels</haxe_doc>
		</amplitude>
		<artist public="1">
			<c path="String"/>
			<haxe_doc>* The ID3 artist name.  Defaults to null.  Currently only works for streamed sounds.</haxe_doc>
		</artist>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The ID3 song name.  Defaults to null.  Currently only works for streamed sounds.</haxe_doc>
		</name>
		<survive public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not this sound should be automatically destroyed when you switch states.</haxe_doc>
		</survive>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The Y position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The X position of this sound in world coordinates.
	 * Only really matters if you are doing proximity/panning stuff.</haxe_doc>
		</x>
		<new public="1" set="method" line="120">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The FlxSound constructor gets all the variables initialized, but NOT ready to play a sound yet.</haxe_doc>
		</new>
		<haxe_doc>* This is the universal flixel sound object, used for streaming, music, and sound effects.</haxe_doc>
	</class>
	<class path="flixel.system.FlxSplash" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/FlxSplash.hx">
		<extends path="flixel.FlxState"/>
		<onComplete get="inline" set="null" line="150"><f a="Tween">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></onComplete>
		<drawLightBlue get="inline" set="null" line="138"><f a=""><x path="Void"/></f></drawLightBlue>
		<drawBlue get="inline" set="null" line="126"><f a=""><x path="Void"/></f></drawBlue>
		<drawRed get="inline" set="null" line="114"><f a=""><x path="Void"/></f></drawRed>
		<drawYellow get="inline" set="null" line="102"><f a=""><x path="Void"/></f></drawYellow>
		<drawGreen get="inline" set="null" line="87"><f a=""><x path="Void"/></f></drawGreen>
		<timerCallback get="inline" set="null" line="73"><f a="Timer">
	<c path="flixel.util.FlxTimer"/>
	<x path="Void"/>
</f></timerCallback>
		<create public="1" set="method" line="35" override="1"><f a=""><x path="Void"/></f></create>
		<_curPart><x path="Int"/></_curPart>
		<_functions><c path="Array"><f a=""><x path="Void"/></f></c></_functions>
		<_colors><c path="Array"><x path="Int"/></c></_colors>
		<_times><c path="Array"><x path="Float"/></c></_times>
		<_text><c path="flash.text.TextField"/></_text>
		<_gfx><c path="flash.display.Graphics"/></_gfx>
		<_sprite><c path="flash.display.Sprite"/></_sprite>
		<_nextState><x path="Class"><c path="flixel.FlxState"/></x></_nextState>
		<new public="1" set="method" line="29"><f a="NextState">
	<x path="Class"><c path="flixel.FlxState"/></x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.debug.Window" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/Window.hx">
		<extends path="flash.display.Sprite"/>
		<BG_COLOR public="1" get="inline" set="null" line="24" static="1">
			<x path="Int"/>
			<haxe_doc>* The background color of the window.</haxe_doc>
		</BG_COLOR>
		<TOP_COLOR public="1" get="inline" set="null" line="28" static="1">
			<x path="Int"/>
			<haxe_doc>* The color used for the "handle" at the top of the window.</haxe_doc>
		</TOP_COLOR>
		<updateBounds public="1" set="method" line="359"><f a="Bounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></updateBounds>
		<updateGUI set="method" line="341">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Figure out if the header or handle are highlighted.</haxe_doc>
		</updateGUI>
		<updateSize set="method" line="320">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.</haxe_doc>
		</updateSize>
		<bound set="method" line="308">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Keep the window within the pre-specified bounding rectangle.</haxe_doc>
		</bound>
		<onMouseUp set="method" line="297">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* User let go of header bar or handler (or nothing), so turn off drag and resize behaviors.
	 * @param E		Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="276">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Figure out if window is being repositioned (clicked on header) or resized (clicked on handle).
	 * @param E		Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onMouseMove set="method" line="238">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse movement handler.  Figures out if mouse is over handle or header bar or what.
	 * @param E		Flash mouse event.</haxe_doc>
		</onMouseMove>
		<init set="method" line="217">
			<f a="?E">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Used to set up basic mouse listeners.
	 * @param E		Flash event.</haxe_doc>
		</init>
		<reposition public="1" set="method" line="204">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Change the position of the window.  Subject to pre-specified bounding rectangles.
	 * @param 	X	Desired X position of top left corner of the window.
	 * @param 	Y	Desired Y position of top left corner of the window.</haxe_doc>
		</reposition>
		<resize public="1" set="method" line="192">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resize the window.  Subject to pre-specified minimums, maximums, and bounding rectangles.
	 * @param 	Width	How wide to make the window.
	 * @param 	Height	How tall to make the window.</haxe_doc>
		</resize>
		<destroy public="1" set="method" line="154">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_resizable>
			<x path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_resizable>
		<_resizing>
			<x path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_resizing>
		<_dragging>
			<x path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_dragging>
		<_drag>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_drag>
		<_overHandle>
			<x path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_overHandle>
		<_overHeader>
			<x path="Bool"/>
			<haxe_doc>* Helper for interaction.</haxe_doc>
		</_overHeader>
		<_handle>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_handle>
		<_title>
			<c path="flash.text.TextField"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_title>
		<_shadow>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_shadow>
		<_header>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_header>
		<_background>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* Window display element.</haxe_doc>
		</_background>
		<_bounds>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Controls where the window is allowed to be positioned.</haxe_doc>
		</_bounds>
		<_height>
			<x path="Int"/>
			<haxe_doc>* Height of the window.  Using Sprite.height is super unreliable for some reason!</haxe_doc>
		</_height>
		<_width>
			<x path="Int"/>
			<haxe_doc>* Width of the window.  Using Sprite.width is super unreliable for some reason!</haxe_doc>
		</_width>
		<maxSize public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>* Maximum allowed X and Y dimensions for this window.</haxe_doc>
		</maxSize>
		<minSize public="1">
			<c path="flash.geom.Point"/>
			<haxe_doc>* Minimum allowed X and Y dimensions for this window.</haxe_doc>
		</minSize>
		<new public="1" set="method" line="106">
			<f a="Title:Width:Height:?Resizable:?Bounds">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param	Title		The name of the window, displayed in the header bar.
	 * @param	Width		The initial width of the window.
	 * @param	Height		The initial height of the window.
	 * @param	Resizable	Whether you can change the size of the window with a drag handle.
	 * @param	Bounds		A rectangle indicating the valid screen area for the window.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A generic, Flash-based window class, created for use in <code>FlxDebugger</code>.]]></haxe_doc>
	</class>
	<class path="flixel.system.debug.BmpLog" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/BmpLog.hx">
		<extends path="flixel.system.debug.Window"/>
		<updateSize set="method" line="136" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<clear public="1" set="method" line="112"><f a=""><x path="Void"/></f></clear>
		<add public="1" set="method" line="72">
			<f a="Data:?FireOnce">
				<c path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new image to the log window.
	 * @param 	Data		The image being logged.
	 * @param 	Style		The <code>LogStyle</code> to be used for the log
	 * @param 	FireOnce   	Whether you only want to log the Data in case it hasn't been added already]]></haxe_doc>
		</add>
		<destroy public="1" set="method" line="59" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_bmps><c path="Array"><c path="flash.display.Bitmap"/></c></_bmps>
		<new public="1" set="method" line="35">
			<f a="Title:Width:Height:?Resizable:?Bounds">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param 	Title		The name of the window, displayed in the header bar.
	 * @param 	Width		The initial width of the window.
	 * @param 	Height		The initial height of the window.
	 * @param 	Resizable	Whether you can change the size of the window with a drag handle.
	 * @param 	Bounds		A rectangle indicating the valid screen area for the window.]]></haxe_doc>
		</new>
		<haxe_doc>* A simple trace output window for use in the debugger overlay.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Console" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/Console.hx">
		<extends path="flixel.system.debug.Window"/>
		<updateSize set="method" line="398" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<destroy public="1" set="method" line="374" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<registerFunction public="1" set="method" line="366">
			<f a="FunctionAlias:Function">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new function to use for the call command.
	 * @param FunctionAlias	The name with which you want to access the function.
	 * @param Function		The function to register.</haxe_doc>
		</registerFunction>
		<registerObject public="1" set="method" line="356">
			<f a="ObjectAlias:AnyObject">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Register a new object to use for the set command.
	 * @param ObjectAlias	The name with which you want to access the object.
	 * @param AnyObject		The object to register.</haxe_doc>
		</registerObject>
		<addCommand public="1" set="method" line="340">
			<f a="Command:AnyObject:Function:?Alt">
				<c path="String"/>
				<d/>
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a custom command to the console on the debugging screen.
	 * @param 	Command		The command's name.
	 * @param 	AnyObject 	Object containing the function (<code>this</code> if function is within the class you're calling this from).
	 * @param 	Function	Function to be called with params when the command is entered.
	 * @param 	Alt			Alternative name for the command, useful as a shortcut.]]></haxe_doc>
		</addCommand>
		<getNextCommand set="method" line="322"><f a=""><c path="String"/></f></getNextCommand>
		<getPreviousCommand set="method" line="314"><f a=""><c path="String"/></f></getPreviousCommand>
		<filterDigits set="method" line="304"><f a="str">
	<c path="String"/>
	<c path="String"/>
</f></filterDigits>
		<overrideDefaultSelection set="method" line="298"><f a="e">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></overrideDefaultSelection>
		<callFunction public="1" set="method" line="244"><f a="obj:func:args:?cmd">
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<c path="String"/>
	<x path="Bool"/>
</f></callFunction>
		<processCommand set="method" line="194"><f a=""><x path="Void"/></f></processCommand>
		<onKeyPress set="method" line="158"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<x path="Void"/>
</f></onKeyPress>
		<onFocusLost set="method" line="134"><f a="e">
	<c path="flash.events.FocusEvent"/>
	<x path="Void"/>
</f></onFocusLost>
		<onFocus set="method" line="110"><f a="e">
	<c path="flash.events.FocusEvent"/>
	<x path="Void"/>
</f></onFocus>
		<defaultText><c path="String"/></defaultText>
		<historyMax><x path="Int"/></historyMax>
		<historyIndex><x path="Int"/></historyIndex>
		<cmdHistory public="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Reference to the array containing the command history.</haxe_doc>
		</cmdHistory>
		<objectStack public="1">
			<c path="Array"><c path="flixel.FlxObject"/></c>
			<haxe_doc>* Internal helper var containing all the FlxObjects created via the create command.</haxe_doc>
		</objectStack>
		<registeredFunctions public="1">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>* Hash containing all registered Functions for the call command. You can use the registerFunction() 
	 * helper function to register new ones or add them to this Hash directly.</haxe_doc>
		</registeredFunctions>
		<registeredObjects public="1">
			<x path="Map">
				<c path="String"/>
				<d/>
			</x>
			<haxe_doc>* Hash containing all registered Obejects for the set command. You can use the registerObject() 
	 * helper function to register new ones or add them to this Hash directly.</haxe_doc>
		</registeredObjects>
		<cmdObjects><x path="Map">
	<c path="String"/>
	<d/>
</x></cmdObjects>
		<cmdFunctions><x path="Map">
	<c path="String"/>
	<d/>
</x></cmdFunctions>
		<_input><c path="flash.text.TextField"/></_input>
		<new public="1" set="method" line="64">
			<f a="Title:Width:Height:?Resizable:?Bounds">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param	Title		The name of the window, displayed in the header bar.
	 * @param	Width		The initial width of the window.
	 * @param	Height		The initial height of the window.
	 * @param	Resizable	Whether you can change the size of the window with a drag handle.
	 * @param	Bounds		A rectangle indicating the valid screen area for the window.]]></haxe_doc>
		</new>
		<haxe_doc>* A powerful console for the flixel debugger screen with supports
 * custom commands, registering objects and functions and saves the 
 * last 25 commands used.
 * Inspired by Eric Smith's "CoolConsole".
 * @link http://www.youtube.com/watch?v=QWfpw7elWk8</haxe_doc>
	</class>
	<class path="flixel.system.debug.ConsoleCommands" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/ConsoleCommands.hx">
		<cLog set="method" line="511"><f a="Text">
	<d/>
	<x path="Void"/>
</f></cLog>
		<resolveObjectAndVariable set="method" line="468"><f a="ObjectAndVariable:CommandName">
	<c path="String"/>
	<c path="String"/>
	<c path="Array"><d/></c>
</f></resolveObjectAndVariable>
		<attemptToCreateInstance set="method" line="447">
			<f a="ClassName:_Type:CommandName:?Params">
				<c path="String"/>
				<d/>
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<d/>
			</f>
			<haxe_doc>* Helper functions</haxe_doc>
		</attemptToCreateInstance>
		<unwatch set="method" line="429"><f a="ObjectAndVariable:?VariableName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></unwatch>
		<watch set="method" line="415"><f a="ObjectAndVariable:?DisplayName">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></watch>
		<listFunctions set="method" line="410"><f a=""><x path="Void"/></f></listFunctions>
		<listObjects set="method" line="405"><f a=""><x path="Void"/></f></listObjects>
		<call set="method" line="341"><f a="FunctionAlias:?Params">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></call>
		<set set="method" line="290"><f a="ObjectAndVariable:NewVariableValue:?WatchName">
	<c path="String"/>
	<d/>
	<c path="String"/>
	<x path="Void"/>
</f></set>
		<create set="method" line="261"><f a="ClassName:?MousePos:?Params">
	<c path="String"/>
	<x path="Bool"/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></create>
		<close set="method" line="256"><f a=""><x path="Void"/></f></close>
		<shake set="method" line="241"><f a="?Intensity:?Duration">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></shake>
		<bgColor set="method" line="211"><f a="Color">
	<d/>
	<x path="Void"/>
</f></bgColor>
		<pause set="method" line="199"><f a=""><x path="Void"/></f></pause>
		<visualDebug set="method" line="189"><f a=""><x path="Void"/></f></visualDebug>
		<watchMouse set="method" line="173"><f a=""><x path="Void"/></f></watchMouse>
		<resetGame set="method" line="160"><f a=""><x path="Void"/></f></resetGame>
		<switchState set="method" line="143"><f a="ClassName">
	<c path="String"/>
	<x path="Void"/>
</f></switchState>
		<resetState set="method" line="130"><f a=""><x path="Void"/></f></resetState>
		<clearHistory set="method" line="123"><f a=""><x path="Void"/></f></clearHistory>
		<help set="method" line="49"><f a="?Command">
	<c path="String"/>
	<x path="Void"/>
</f></help>
		<watchingMouse><x path="Bool"/></watchingMouse>
		<_console><c path="flixel.system.debug.Console"/></_console>
		<new public="1" set="method" line="14"><f a="console">
	<c path="flixel.system.debug.Console"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.debug.FlxDebugger" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/FlxDebugger.hx">
		<extends path="flash.display.Sprite"/>
		<STANDARD public="1" get="inline" set="null" line="32" static="1">
			<x path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Wide but low windows at the bottom of the screen.</haxe_doc>
		</STANDARD>
		<MICRO public="1" get="inline" set="null" line="37" static="1">
			<x path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Tiny windows in the screen corners.</haxe_doc>
		</MICRO>
		<BIG public="1" get="inline" set="null" line="42" static="1">
			<x path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Large windows taking up bottom half of screen.</haxe_doc>
		</BIG>
		<TOP public="1" get="inline" set="null" line="47" static="1">
			<x path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Wide but low windows at the top of the screen.</haxe_doc>
		</TOP>
		<LEFT public="1" get="inline" set="null" line="52" static="1">
			<x path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Large windows taking up left third of screen.</haxe_doc>
		</LEFT>
		<RIGHT public="1" get="inline" set="null" line="57" static="1">
			<x path="Int"/>
			<haxe_doc>* Debugger overlay layout preset: Large windows taking up right third of screen.</haxe_doc>
		</RIGHT>
		<GUTTER public="1" get="inline" set="null" line="62" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</GUTTER>
		<TOP_HEIGHT public="1" get="inline" set="null" line="66" static="1">
			<x path="Int"/>
			<haxe_doc>* Internal, used to space out windows from the edges.</haxe_doc>
		</TOP_HEIGHT>
		<onResize public="1" get="inline" set="null" line="345"><f a="Width:Height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></onResize>
		<resetLayout public="1" set="method" line="278">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Forces the debugger windows to reset to the last specified layout.
	 * The default layout is <code>STANDARD</code>.]]></haxe_doc>
		</resetLayout>
		<setLayout public="1" set="method" line="268">
			<f a="Layout">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Change the way the debugger's windows are laid out.
	 * 
	 * @param	Layout	The layout codes can be found in <code>FlxDebugger</code>, for example <code>FlxDebugger.MICRO</code>]]></haxe_doc>
		</setLayout>
		<onMouseOut set="method" line="253">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseOut>
		<onMouseOver set="method" line="240">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Mouse handler that helps with fake "mouse focus" type behavior.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseOver>
		<destroy public="1" set="method" line="186">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_screenBounds>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Stores the bounds in which the windows can move.</haxe_doc>
		</_screenBounds>
		<_screen>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Internal, stores width and height of the Flash Player window.</haxe_doc>
		</_screen>
		<_layout>
			<x path="Int"/>
			<haxe_doc>* Internal, tracks what debugger window layout user has currently selected.</haxe_doc>
		</_layout>
		<hasMouse public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the mouse is currently over one of the debugger windows or not.</haxe_doc>
		</hasMouse>
		<console public="1">
			<c path="flixel.system.debug.Console"/>
			<haxe_doc>* Container for console.</haxe_doc>
		</console>
		<vis public="1">
			<c path="flixel.system.debug.Vis"/>
			<haxe_doc>* Container for the visual debug mode toggle.</haxe_doc>
		</vis>
		<vcr public="1">
			<c path="flixel.system.debug.VCR"/>
			<haxe_doc>* Container for the record, stop and play buttons.</haxe_doc>
		</vcr>
		<watch public="1">
			<c path="flixel.system.debug.Watch"/>
			<haxe_doc>* Container for the watch window widget.</haxe_doc>
		</watch>
		<log public="1">
			<c path="flixel.system.debug.Log"/>
			<haxe_doc>* Container for the trace output widget.</haxe_doc>
		</log>
		<bmpLog public="1">
			<c path="flixel.system.debug.BmpLog"/>
			<haxe_doc>* Container for the bitmap output widget</haxe_doc>
		</bmpLog>
		<stats public="1">
			<c path="flixel.system.debug.Stats"/>
			<haxe_doc>* Container for the performance monitor widget.</haxe_doc>
		</stats>
		<new public="1" set="method" line="120">
			<f a="Width:Height">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiates the debugger overlay.
	 * 
	 * @param 	Width	The width of the screen.
	 * @param 	Height	The height of the screen.</haxe_doc>
		</new>
		<haxe_doc>* Container for the new debugger overlay.
 * Most of the functionality is in the debug folder widgets,
 * but this class instantiates the widgets and handles their basic formatting and arrangement.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Log" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/Log.hx">
		<extends path="flixel.system.debug.Window"/>
		<MAX_LOG_LINES public="1" line="18" static="1"><x path="Int"/></MAX_LOG_LINES>
		<updateSize set="method" line="194" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Adjusts the width and height of the text field accordingly.</haxe_doc>
		</updateSize>
		<clear public="1" set="method" line="182"><f a=""><x path="Void"/></f></clear>
		<add public="1" set="method" line="70">
			<f a="Data:Style:?FireOnce">
				<c path="Array"><d/></c>
				<c path="flixel.system.debug.LogStyle"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Adds a new line to the log window.
	 * @param 	Data		The data being logged.
	 * @param 	Style		The <code>LogStyle</code> to be used for the log
	 * @param 	FireOnce   	Whether you only want to log the Data in case it hasn't been added already]]></haxe_doc>
		</add>
		<destroy public="1" set="method" line="53" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_lines><c path="Array"><c path="String"/></c></_lines>
		<_text><c path="flash.text.TextField"/></_text>
		<new public="1" set="method" line="31">
			<f a="Title:Width:Height:?Resizable:?Bounds">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param 	Title		The name of the window, displayed in the header bar.
	 * @param 	Width		The initial width of the window.
	 * @param 	Height		The initial height of the window.
	 * @param 	Resizable	Whether you can change the size of the window with a drag handle.
	 * @param 	Bounds		A rectangle indicating the valid screen area for the window.]]></haxe_doc>
		</new>
		<haxe_doc>* A simple trace output window for use in the debugger overlay.</haxe_doc>
	</class>
	<class path="flixel.system.debug.LogStyle" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/LogStyle.hx">
		<NORMAL public="1" line="10" static="1"><c path="flixel.system.debug.LogStyle"/></NORMAL>
		<WARNING public="1" line="11" static="1"><c path="flixel.system.debug.LogStyle"/></WARNING>
		<ERROR public="1" line="12" static="1"><c path="flixel.system.debug.LogStyle"/></ERROR>
		<NOTICE public="1" line="13" static="1"><c path="flixel.system.debug.LogStyle"/></NOTICE>
		<CONSOLE public="1" line="14" static="1"><c path="flixel.system.debug.LogStyle"/></CONSOLE>
		<callbackFunction public="1">
			<d/>
			<haxe_doc><![CDATA[* A callback function that is called when this <code>LogStyle</code> is used.
	 * @default null]]></haxe_doc>
		</callbackFunction>
		<openConsole public="1">
			<x path="Bool"/>
			<haxe_doc><![CDATA[* Whether the console should be forced to open when this <code>LogStyle</code> is used.
	 * @default false]]></haxe_doc>
		</openConsole>
		<errorSound public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* A sound to be played when this <code>LogStyle</code> is used.
	 * @default null]]></haxe_doc>
		</errorSound>
		<underlined public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the text is underlined or not.
	 * @default false</haxe_doc>
		</underlined>
		<italic public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the text is italic or not.
	 * @default false</haxe_doc>
		</italic>
		<bold public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the text is bold or not.
	 * @default false</haxe_doc>
		</bold>
		<size public="1">
			<x path="Int"/>
			<haxe_doc>* The text size.
	 * @default 12</haxe_doc>
		</size>
		<color public="1">
			<c path="String"/>
			<haxe_doc>* The text color.
	 * @default "FFFFFF"</haxe_doc>
		</color>
		<prefix public="1">
			<c path="String"/>
			<haxe_doc>* A prefix which is always attached to the start of the logged data.
	 * @default ""</haxe_doc>
		</prefix>
		<new public="1" set="method" line="74">
			<f a="?Prefix:?Color:?Size:?Bold:?Italic:?Underlined:?ErrorSound:?OpenConsole:?CallbackFunction">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
				<x path="Bool"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Create a new <code>LogStyle</code> to be used in conjunction with <code>FlxG.log.advanced()</code>
	 * @param	Prefix				A prefix which is always attached to the start of the logged data.
	 * @param	Color				The text color.
	 * @param	Size				The text size.
	 * @param 	Bold				Whether the text is bold or not.
	 * @param	Italic				Whether the text is italic or not.
	 * @param	Underlined			Whether the text is underlined or not.
	 * @param	ErrorSound			A sound to be played when this <code>LogStyle</code> is used.
	 * @param	OpenConsole			Whether the console should be forced to open when this <code>LogStyle</code> is used.
	 * @param	CallbackFunction	A callback function that is called when this <code>LogStyle</code> is used.]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A class that allows you to create a custom style
 * for <code>FlxG.log.advanced()</code>. Also used 
 * internally for the pre-defined styles.]]></haxe_doc>
	</class>
	<class path="flixel.system.debug.Stats" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/Stats.hx">
		<extends path="flixel.system.debug.Window"/>
		<UPDATE_DELAY get="inline" set="null" line="18" static="1"><x path="Int"/></UPDATE_DELAY>
		<WIDTH get="inline" set="null" line="19" static="1"><x path="Int"/></WIDTH>
		<drawCalls public="1" get="inline" set="null" line="269">
			<f a="Drawcalls">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Keep track of how many times drawTiles() method was called.
	 * @param 	Count	How many times drawTiles() method was called.</haxe_doc>
		</drawCalls>
		<visibleObjects public="1" get="inline" set="null" line="259">
			<f a="Count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Keep track of how many objects were updated.
	 * @param 	Count	How many objects were updated.</haxe_doc>
		</visibleObjects>
		<activeObjects public="1" get="inline" set="null" line="250">
			<f a="Count">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Keep track of how many objects were updated.
	 * @param 	Count	How many objects were updated.</haxe_doc>
		</activeObjects>
		<flash public="1" get="inline" set="null" line="241">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Keep track of how long the Flash player and browser take.
	 * @param 	Time	How long Flash/browser took.</haxe_doc>
		</flash>
		<flixelDraw public="1" get="inline" set="null" line="232">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Keep track of how long renders take.
	 * @param	Time	How long this render took.</haxe_doc>
		</flixelDraw>
		<flixelUpdate public="1" get="inline" set="null" line="223">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Keep track of how long updates take.
	 * @param 	Time	How long this update took.</haxe_doc>
		</flixelUpdate>
		<update public="1" set="method" line="127">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called each frame, but really only updates once every second or so, to save on performance.
	 * Takes all the data in the accumulators and parses it into useful performance data.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="103" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<createTextField set="method" line="85">
			<f a="Alignment:Color">
				<d/>
				<x path="Int"/>
				<c path="flash.text.TextField"/>
			</f>
			<haxe_doc>* Helper function to create a new textfield.
	 * @param	Alignment	The aligment of the textfield
	 * @return 	The created textfield</haxe_doc>
		</createTextField>
		<_drawCallsMarker><x path="Int"/></_drawCallsMarker>
		<_drawCalls><c path="Array"><x path="Int"/></c></_drawCalls>
		<_flashMarker><x path="Int"/></_flashMarker>
		<_flash><c path="Array"><x path="Float"/></c></_flash>
		<_activeObjectMarker><x path="Int"/></_activeObjectMarker>
		<_activeObject><c path="Array"><x path="Int"/></c></_activeObject>
		<_visibleObjectMarker><x path="Int"/></_visibleObjectMarker>
		<_visibleObject><c path="Array"><x path="Int"/></c></_visibleObject>
		<_drawMarker><x path="Int"/></_drawMarker>
		<_draw><c path="Array"><x path="Int"/></c></_draw>
		<_updateMarker><x path="Int"/></_updateMarker>
		<_update><c path="Array"><x path="Int"/></c></_update>
		<_updateTimer><x path="Int"/></_updateTimer>
		<_lastTime><x path="Int"/></_lastTime>
		<_text><c path="flash.text.TextField"/></_text>
		<new public="1" set="method" line="54">
			<f a="Title:Width:Height:?Resizable:?Bounds">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates flashPlayerFramerate new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param 	Title		The name of the window, displayed in the header bar.
	 * @param 	Width		The initial width of the window.
	 * @param 	Height		The initial height of the window.
	 * @param 	Resizable	Whether you can change the size of the window with flashPlayerFramerate drag handle.
	 * @param 	Bounds		A rectangle indicating the valid screen area for the window.]]></haxe_doc>
		</new>
		<haxe_doc>* A simple performance monitor widget, for use in the debugger overlay.</haxe_doc>
	</class>
	<class path="flixel.system.debug.VCR" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/VCR.hx">
		<extends path="flash.display.Sprite"/>
		<DEFAULT_FILE_NAME get="inline" set="null" line="33" static="1"><c path="String"/></DEFAULT_FILE_NAME>
		<updateGUI set="method" line="689">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Figures out what buttons to highlight based on the _overWhatever and _pressingWhatever variables.</haxe_doc>
		</updateGUI>
		<unpress set="method" line="677">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets all the pressed state variables for the buttons to false.</haxe_doc>
		</unpress>
		<checkOver set="method" line="641">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* This function checks to see what button the mouse is currently over.
	 * Has some special behavior based on whether a recording is happening or not.
	 * @return	Whether the mouse was over any buttons or not.</haxe_doc>
		</checkOver>
		<onMouseUp set="method" line="585">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the mouse is released, check to see if it was released over a button that was pressed.
	 * If it was, take the appropriate action based on button state and visibility.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="555">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the mouse is pressed down, check to see if the user started pressing down a specific button.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onMouseMove set="method" line="542">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the mouse moves, check to see if any buttons should be highlighted.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseMove>
		<init set="method" line="521">
			<f a="?E">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Just sets up basic mouse listeners, a la FlxWindow.
	 * @param	E	Flash event.</haxe_doc>
		</init>
		<onStep public="1" set="method" line="506">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the fast-forward-looking button.
	 * Requests a 1-frame step forward in the game loop.</haxe_doc>
		</onStep>
		<onPlay public="1" set="method" line="490">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the Play button.
	 * This is different from user-defined unpause behavior, or focus gained behavior.</haxe_doc>
		</onPlay>
		<onPause public="1" set="method" line="474">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the user presses the Pause button.
	 * This is different from user-defined pause behavior, or focus lost behavior.
	 * Does NOT pause music playback!!</haxe_doc>
		</onPause>
		<onRestart public="1" set="method" line="453">
			<f a="?StandardMode">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when the user presses the Rewind-looking button.
	 * If Alt is pressed, the entire game is reset.
	 * If Alt is NOT pressed, only the current state is reset.
	 * The GUI is updated accordingly.
	 * @param	StandardMode	Whether to reset the current game (== true), or just the current state.  Just resetting the current state can be very handy for debugging.</haxe_doc>
		</onRestart>
		<updateRuntime public="1" set="method" line="255">
			<f a="Time">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Just updates the VCR GUI so the runtime displays roughly the right thing.</haxe_doc>
		</updateRuntime>
		<playing public="1" set="method" line="245">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Usually called by FlxGame when a requested replay has begun.
	 * Just updates the VCR GUI so the buttons are in the right state.</haxe_doc>
		</playing>
		<stopped public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Usually called by FlxGame when a replay has been stopped.
	 * Just updates the VCR GUI so the buttons are in the right state.</haxe_doc>
		</stopped>
		<recording public="1" set="method" line="223">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Usually called by FlxGame when a requested recording has begun.
	 * Just updates the VCR GUI so the buttons are in the right state.</haxe_doc>
		</recording>
		<destroy public="1" set="method" line="159">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_runtime><x path="Int"/></_runtime>
		<_runtimeDisplay><c path="flash.text.TextField"/></_runtimeDisplay>
		<_pressingStep><x path="Bool"/></_pressingStep>
		<_pressingPause><x path="Bool"/></_pressingPause>
		<_pressingRestart><x path="Bool"/></_pressingRestart>
		<_pressingRecord><x path="Bool"/></_pressingRecord>
		<_pressingOpen><x path="Bool"/></_pressingOpen>
		<_overStep><x path="Bool"/></_overStep>
		<_overPause><x path="Bool"/></_overPause>
		<_overRestart><x path="Bool"/></_overRestart>
		<_overRecord><x path="Bool"/></_overRecord>
		<_overOpen><x path="Bool"/></_overOpen>
		<_step><c path="flash.display.Bitmap"/></_step>
		<_play><c path="flash.display.Bitmap"/></_play>
		<_pause><c path="flash.display.Bitmap"/></_pause>
		<_restart><c path="flash.display.Bitmap"/></_restart>
		<_flixel><c path="flash.display.Bitmap"/></_flixel>
		<_stop><c path="flash.display.Bitmap"/></_stop>
		<_recordOn><c path="flash.display.Bitmap"/></_recordOn>
		<_recordOff><c path="flash.display.Bitmap"/></_recordOff>
		<_open><c path="flash.display.Bitmap"/></_open>
		<stepRequested public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether a "1 frame step forward" was requested.</haxe_doc>
		</stepRequested>
		<paused public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the debugger has been paused.</haxe_doc>
		</paused>
		<new public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates the "VCR" control panel for debugger pausing, stepping, and recording.</haxe_doc>
		</new>
		<haxe_doc>* This class contains the record, stop, play, and step 1 frame buttons seen on the top edge of the debugger overlay.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Vis" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/Vis.hx">
		<extends path="flash.display.Sprite"/>
		<updateGUI set="method" line="169">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Figures out what buttons to highlight based on the _overWhatever and _pressingWhatever variables.</haxe_doc>
		</updateGUI>
		<unpress set="method" line="161">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets all the pressed state variables for the buttons to false.</haxe_doc>
		</unpress>
		<checkOver set="method" line="144">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* This function checks to see what button the mouse is currently over.
	 * Has some special behavior based on whether a recording is happening or not.
	 * @return	Whether the mouse was over any buttons or not.</haxe_doc>
		</checkOver>
		<onMouseUp set="method" line="126">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the mouse is released, check to see if it was released over a button that was pressed.
	 * If it was, take the appropriate action based on button state and visibility.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<onMouseDown set="method" line="112">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the mouse is pressed down, check to see if the user started pressing down a specific button.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseDown>
		<onMouseMove set="method" line="99">
			<f a="?E">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If the mouse moves, check to see if any buttons should be highlighted.
	 * @param	E	Flash mouse event.</haxe_doc>
		</onMouseMove>
		<init set="method" line="78">
			<f a="?E">
				<c path="flash.events.Event"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Just sets up basic mouse listeners, a la FlxWindow.
	 * @param	E	Flash event.</haxe_doc>
		</init>
		<onBounds public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when the bounding box toggle is pressed.</haxe_doc>
		</onBounds>
		<destroy public="1" set="method" line="46">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_pressingBounds><x path="Bool"/></_pressingBounds>
		<_overBounds><x path="Bool"/></_overBounds>
		<_bounds><c path="flash.display.Bitmap"/></_bounds>
		<new public="1" set="method" line="27">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate the visual debugger panel.</haxe_doc>
		</new>
		<haxe_doc>* This control panel has all the visual debugger toggles in it, in the debugger overlay.
 * Currently there is only one toggle that flips on all the visual debug settings.
 * This panel is heavily based on the VCR panel.</haxe_doc>
	</class>
	<class path="flixel.system.debug.Watch" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/Watch.hx">
		<extends path="flixel.system.debug.Window"/>
		<MAX_LOG_LINES get="inline" set="null" line="17" static="1"><x path="Int"/></MAX_LOG_LINES>
		<LINE_HEIGHT get="inline" set="null" line="18" static="1"><x path="Int"/></LINE_HEIGHT>
		<updateSize set="method" line="287" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update the Flash shapes to match the new size, and reposition the header, shadow, and handle accordingly.
	 * Also adjusts the width of the entries and stuff, and makes sure there is room for all the entries.</haxe_doc>
		</updateSize>
		<submit public="1" set="method" line="267">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Force any watch entries currently being edited to submit their changes.</haxe_doc>
		</submit>
		<update public="1" set="method" line="248">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Update all the entries in the watch window.</haxe_doc>
		</update>
		<removeAll public="1" set="method" line="228">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Remove everything from the watch window.</haxe_doc>
		</removeAll>
		<removeEntry set="method" line="205">
			<f a="Entry:Index">
				<c path="flixel.system.debug.WatchEntry"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Helper function to acutally remove an entry.</haxe_doc>
		</removeEntry>
		<remove public="1" set="method" line="169">
			<f a="AnyObject:?VariableName:?QuickWatchName">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Remove a variable from the watch window.
	 * @param 	AnyObject		The <code>Object</code> containing the variable you want to remove, e.g. this or Player.velocity.
	 * @param 	VariableName	The <code>String</code> name of the variable you want to remove, e.g. "width" or "x".  If left null, this will remove all variables of that object. 
	 * @param	QuickWatchName	In case you want to remove a quickWatch entry.]]></haxe_doc>
		</remove>
		<updateQuickWatch public="1" set="method" line="134">
			<f a="Name:NewValue">
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add or update a quickWatch entry to the watch list in the debugger.
	 * Extremely useful when called in <code>update()</code> functions when there 
	 * doesn't exist a variable for a value you want to watch - so you won't have to create one.
	 * @param	Name		The name of the quickWatch entry, for example "mousePressed".
	 * @param	NewValue	The new value for this entry, for example <code>FlxG.mouse.pressed</code>.]]></haxe_doc>
		</updateQuickWatch>
		<add public="1" set="method" line="96">
			<f a="AnyObject:VariableName:?DisplayName">
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Add a new variable to the watch window.
	 * Has some simple code in place to prevent
	 * accidentally watching the same variable twice.
	 * @param AnyObject		The <code>Object</code> containing the variable you want to track, e.g. this or Player.velocity.
	 * @param VariableName	The <code>String</code> name of the variable you want to track, e.g. "width" or "x".
	 * @param DisplayName	Optional <code>String</code> that can be displayed in the watch window instead of the basic class-name information.]]></haxe_doc>
		</add>
		<destroy public="1" set="method" line="63" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_quickWatchList><x path="Map">
	<c path="String"/>
	<c path="flixel.system.debug.WatchEntry"/>
</x></_quickWatchList>
		<_watching><c path="Array"><c path="flixel.system.debug.WatchEntry"/></c></_watching>
		<_values><c path="flash.display.Sprite"/></_values>
		<_names><c path="flash.display.Sprite"/></_names>
		<editing public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether a watch entry is currently being edited or not.</haxe_doc>
		</editing>
		<new public="1" set="method" line="38">
			<f a="Title:Width:Height:?Resizable:?Bounds">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new window object.  This Flash-based class is mainly (only?) used by <code>FlxDebugger</code>.
	 * @param 	Title		The name of the window, displayed in the header bar.
	 * @param 	Width		The initial width of the window.
	 * @param 	Height		The initial height of the window.
	 * @param 	Resizable	Whether you can change the size of the window with a drag handle.
	 * @param 	Bounds		A rectangle indicating the valid screen area for the window.]]></haxe_doc>
		</new>
		<haxe_doc>* A Visual Studio-style "watch" window, for use in the debugger overlay.
 * Track the values of any public variable in real-time, and/or edit their values on the fly.</haxe_doc>
	</class>
	<class path="flixel.system.debug.WatchEntry" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/debug/WatchEntry.hx">
		<doneEditing set="method" line="292">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Helper function, switches the text field back to display mode.</haxe_doc>
		</doneEditing>
		<submit public="1" set="method" line="264">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Submit the current edits and stop editing.</haxe_doc>
		</submit>
		<cancel public="1" set="method" line="255">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancel the current edits and stop editing.</haxe_doc>
		</cancel>
		<onKeyUp public="1" set="method" line="237">
			<f a="FlashEvent">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Check to see if Enter, Tab or Escape were just released.
	 * Enter or Tab submit the change, and Escape cancels it.
	 * @param	FlashEvent	Flash keyboard event.</haxe_doc>
		</onKeyUp>
		<onMouseUp public="1" set="method" line="220">
			<f a="FlashEvent">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A watch entry was clicked, so flip into edit mode for that entry.
	 * @param	FlashEvent	Flash mouse event.</haxe_doc>
		</onMouseUp>
		<updateValue public="1" set="method" line="200">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Update the variable value on display with the current in-game value.</haxe_doc>
		</updateValue>
		<updateWidth public="1" set="method" line="178">
			<f a="NameWidth:ValueWidth">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjust the width of the Flash <code>TextField</code> objects.]]></haxe_doc>
		</updateWidth>
		<setY public="1" set="method" line="169">
			<f a="Y">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Set the watch window Y height of the Flash <code>TextField</code> objects.]]></haxe_doc>
		</setY>
		<destroy public="1" set="method" line="151">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<quickWatch public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this entry is a quickWatch or not.</haxe_doc>
		</quickWatch>
		<_blackText><c path="flash.text.TextFormat"/></_blackText>
		<_whiteText><c path="flash.text.TextFormat"/></_whiteText>
		<oldValue public="1">
			<d/>
			<haxe_doc>* The value of the field before it was edited.</haxe_doc>
		</oldValue>
		<editing public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the entry is currently being edited or not.</haxe_doc>
		</editing>
		<valueDisplay public="1">
			<c path="flash.text.TextField"/>
			<haxe_doc><![CDATA[* The Flash <code>TextField</code> object used to display and edit this entry's value.]]></haxe_doc>
		</valueDisplay>
		<nameDisplay public="1">
			<c path="flash.text.TextField"/>
			<haxe_doc><![CDATA[* The Flash <code>TextField</code> object used to display this entry's name.]]></haxe_doc>
		</nameDisplay>
		<custom public="1">
			<c path="String"/>
			<haxe_doc>* A custom display name for this object, if there is any.</haxe_doc>
		</custom>
		<field public="1">
			<c path="String"/>
			<haxe_doc>* The member variable of that object.</haxe_doc>
		</field>
		<object public="1">
			<d/>
			<haxe_doc><![CDATA[* The <code>Object</code> being watched.]]></haxe_doc>
		</object>
		<new public="1" set="method" line="68">
			<f a="Y:NameWidth:ValueWidth:Obj:Field:?Custom">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<d/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new watch entry in the watch window. 
	 * Will be a "quickWatch" when Obj and Field are null, but a Custom name is set.
	 * 
	 * @param Y				The initial height in the Watch window.
	 * @param NameWidth		The initial width of the name field.
	 * @param ValueWidth	The initial width of the value field.
	 * @param Obj			The <code>Object</code> containing the variable we want to watch.
	 * @param Field			The variable name we want to watch.
	 * @param Custom		A custom display name (optional).]]></haxe_doc>
		</new>
		<haxe_doc>* Helper class for the debugger overlay's Watch window.
 * Handles the display and modification of game variables on the fly.</haxe_doc>
	</class>
	<class path="flixel.system.frontEnds.BmpLogFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/BmpLogFrontEnd.hx">
		<add public="1" get="inline" set="null" line="19">
			<f a="Pixels">
				<c path="flash.display.BitmapData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a variable to the bmpLog list in the debugger.
	 * This lets you see the pixels of a bitmapdata
	 * 
	 * @param	Pixels	BitmapData</haxe_doc>
		</add>
		<new public="1" set="method" line="11">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Just needed to create an instance.</haxe_doc>
		</new>
	</class>
	<class path="flixel.system.frontEnds.VCRFrontEnd" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/frontEnds/VCRFrontEnd.hx"><new public="1" set="method" line="11">
	<f a=""><x path="Void"/></f>
	<haxe_doc>* Just needed to create an instance.</haxe_doc>
</new></class>
	<class path="flixel.system.input.IFlxInput" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/IFlxInput.hx" interface="1">
		<destroy public="1" set="method"><f a=""><x path="Void"/></f></destroy>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<onFocusLost public="1" set="method"><f a=""><x path="Void"/></f></onFocusLost>
		<onFocus public="1" set="method"><f a=""><x path="Void"/></f></onFocus>
		<update public="1" set="method"><f a=""><x path="Void"/></f></update>
		<reset public="1" set="method"><f a=""><x path="Void"/></f></reset>
	</class>
	<class path="flixel.system.input.keyboard.FlxKey" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/keyboard/FlxKey.hx">
		<JUST_RELEASED public="1" get="inline" set="null" line="8" static="1"><x path="Int"/></JUST_RELEASED>
		<RELEASED public="1" get="inline" set="null" line="9" static="1"><x path="Int"/></RELEASED>
		<PRESSED public="1" get="inline" set="null" line="10" static="1"><x path="Int"/></PRESSED>
		<JUST_PRESSED public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></JUST_PRESSED>
		<last public="1">
			<x path="Int"/>
			<haxe_doc>* The last state of this key.</haxe_doc>
		</last>
		<current public="1">
			<x path="Int"/>
			<haxe_doc>* The current state of this key.</haxe_doc>
		</current>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of this key.</haxe_doc>
		</name>
		<new public="1" set="method" line="26"><f a="Name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for keyboard input.</haxe_doc>
	</class>
	<class path="flixel.system.input.keyboard.FlxKeyList" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/keyboard/FlxKeyList.hx">
		<get_ANY set="method" line="111"><f a=""><x path="Bool"/></f></get_ANY>
		<ANY public="1" get="accessor" set="null"><x path="Bool"/></ANY>
		<get_RIGHT get="inline" set="null" line="107"><f a=""><x path="Bool"/></f></get_RIGHT>
		<RIGHT public="1" get="accessor" set="null"><x path="Bool"/></RIGHT>
		<get_LEFT get="inline" set="null" line="106"><f a=""><x path="Bool"/></f></get_LEFT>
		<LEFT public="1" get="accessor" set="null"><x path="Bool"/></LEFT>
		<get_DOWN get="inline" set="null" line="105"><f a=""><x path="Bool"/></f></get_DOWN>
		<DOWN public="1" get="accessor" set="null"><x path="Bool"/></DOWN>
		<get_UP get="inline" set="null" line="104"><f a=""><x path="Bool"/></f></get_UP>
		<UP public="1" get="accessor" set="null"><x path="Bool"/></UP>
		<get_SPACE get="inline" set="null" line="103"><f a=""><x path="Bool"/></f></get_SPACE>
		<SPACE public="1" get="accessor" set="null"><x path="Bool"/></SPACE>
		<get_ALT get="inline" set="null" line="102"><f a=""><x path="Bool"/></f></get_ALT>
		<ALT public="1" get="accessor" set="null"><x path="Bool"/></ALT>
		<get_CONTROL get="inline" set="null" line="101"><f a=""><x path="Bool"/></f></get_CONTROL>
		<CONTROL public="1" get="accessor" set="null"><x path="Bool"/></CONTROL>
		<get_NUMPADSLASH get="inline" set="null" line="100"><f a=""><x path="Bool"/></f></get_NUMPADSLASH>
		<NUMPADSLASH public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSLASH>
		<get_SLASH get="inline" set="null" line="99"><f a=""><x path="Bool"/></f></get_SLASH>
		<SLASH public="1" get="accessor" set="null"><x path="Bool"/></SLASH>
		<get_NUMPADPERIOD get="inline" set="null" line="98"><f a=""><x path="Bool"/></f></get_NUMPADPERIOD>
		<NUMPADPERIOD public="1" get="accessor" set="null"><x path="Bool"/></NUMPADPERIOD>
		<get_PERIOD get="inline" set="null" line="97"><f a=""><x path="Bool"/></f></get_PERIOD>
		<PERIOD public="1" get="accessor" set="null"><x path="Bool"/></PERIOD>
		<get_COMMA get="inline" set="null" line="96"><f a=""><x path="Bool"/></f></get_COMMA>
		<COMMA public="1" get="accessor" set="null"><x path="Bool"/></COMMA>
		<get_M get="inline" set="null" line="95"><f a=""><x path="Bool"/></f></get_M>
		<M public="1" get="accessor" set="null"><x path="Bool"/></M>
		<get_N get="inline" set="null" line="94"><f a=""><x path="Bool"/></f></get_N>
		<N public="1" get="accessor" set="null"><x path="Bool"/></N>
		<get_B get="inline" set="null" line="93"><f a=""><x path="Bool"/></f></get_B>
		<B public="1" get="accessor" set="null"><x path="Bool"/></B>
		<get_V get="inline" set="null" line="92"><f a=""><x path="Bool"/></f></get_V>
		<V public="1" get="accessor" set="null"><x path="Bool"/></V>
		<get_C get="inline" set="null" line="91"><f a=""><x path="Bool"/></f></get_C>
		<C public="1" get="accessor" set="null"><x path="Bool"/></C>
		<get_X get="inline" set="null" line="90"><f a=""><x path="Bool"/></f></get_X>
		<X public="1" get="accessor" set="null"><x path="Bool"/></X>
		<get_Z get="inline" set="null" line="89"><f a=""><x path="Bool"/></f></get_Z>
		<Z public="1" get="accessor" set="null"><x path="Bool"/></Z>
		<get_SHIFT get="inline" set="null" line="88"><f a=""><x path="Bool"/></f></get_SHIFT>
		<SHIFT public="1" get="accessor" set="null"><x path="Bool"/></SHIFT>
		<get_ENTER get="inline" set="null" line="87"><f a=""><x path="Bool"/></f></get_ENTER>
		<ENTER public="1" get="accessor" set="null"><x path="Bool"/></ENTER>
		<get_QUOTE get="inline" set="null" line="86"><f a=""><x path="Bool"/></f></get_QUOTE>
		<QUOTE public="1" get="accessor" set="null"><x path="Bool"/></QUOTE>
		<get_SEMICOLON get="inline" set="null" line="85"><f a=""><x path="Bool"/></f></get_SEMICOLON>
		<SEMICOLON public="1" get="accessor" set="null"><x path="Bool"/></SEMICOLON>
		<get_L get="inline" set="null" line="84"><f a=""><x path="Bool"/></f></get_L>
		<L public="1" get="accessor" set="null"><x path="Bool"/></L>
		<get_K get="inline" set="null" line="83"><f a=""><x path="Bool"/></f></get_K>
		<K public="1" get="accessor" set="null"><x path="Bool"/></K>
		<get_J get="inline" set="null" line="82"><f a=""><x path="Bool"/></f></get_J>
		<J public="1" get="accessor" set="null"><x path="Bool"/></J>
		<get_H get="inline" set="null" line="81"><f a=""><x path="Bool"/></f></get_H>
		<H public="1" get="accessor" set="null"><x path="Bool"/></H>
		<get_G get="inline" set="null" line="80"><f a=""><x path="Bool"/></f></get_G>
		<G public="1" get="accessor" set="null"><x path="Bool"/></G>
		<get_F get="inline" set="null" line="79"><f a=""><x path="Bool"/></f></get_F>
		<F public="1" get="accessor" set="null"><x path="Bool"/></F>
		<get_D get="inline" set="null" line="78"><f a=""><x path="Bool"/></f></get_D>
		<D public="1" get="accessor" set="null"><x path="Bool"/></D>
		<get_S get="inline" set="null" line="77"><f a=""><x path="Bool"/></f></get_S>
		<S public="1" get="accessor" set="null"><x path="Bool"/></S>
		<get_A get="inline" set="null" line="76"><f a=""><x path="Bool"/></f></get_A>
		<A public="1" get="accessor" set="null"><x path="Bool"/></A>
		<get_CAPSLOCK get="inline" set="null" line="75"><f a=""><x path="Bool"/></f></get_CAPSLOCK>
		<CAPSLOCK public="1" get="accessor" set="null"><x path="Bool"/></CAPSLOCK>
		<get_BACKSLASH get="inline" set="null" line="74"><f a=""><x path="Bool"/></f></get_BACKSLASH>
		<BACKSLASH public="1" get="accessor" set="null"><x path="Bool"/></BACKSLASH>
		<get_RBRACKET get="inline" set="null" line="73"><f a=""><x path="Bool"/></f></get_RBRACKET>
		<RBRACKET public="1" get="accessor" set="null"><x path="Bool"/></RBRACKET>
		<get_LBRACKET get="inline" set="null" line="72"><f a=""><x path="Bool"/></f></get_LBRACKET>
		<LBRACKET public="1" get="accessor" set="null"><x path="Bool"/></LBRACKET>
		<get_P get="inline" set="null" line="71"><f a=""><x path="Bool"/></f></get_P>
		<P public="1" get="accessor" set="null"><x path="Bool"/></P>
		<get_O get="inline" set="null" line="70"><f a=""><x path="Bool"/></f></get_O>
		<O public="1" get="accessor" set="null"><x path="Bool"/></O>
		<get_I get="inline" set="null" line="69"><f a=""><x path="Bool"/></f></get_I>
		<I public="1" get="accessor" set="null"><x path="Bool"/></I>
		<get_U get="inline" set="null" line="68"><f a=""><x path="Bool"/></f></get_U>
		<U public="1" get="accessor" set="null"><x path="Bool"/></U>
		<get_Y get="inline" set="null" line="67"><f a=""><x path="Bool"/></f></get_Y>
		<Y public="1" get="accessor" set="null"><x path="Bool"/></Y>
		<get_T get="inline" set="null" line="66"><f a=""><x path="Bool"/></f></get_T>
		<T public="1" get="accessor" set="null"><x path="Bool"/></T>
		<get_R get="inline" set="null" line="65"><f a=""><x path="Bool"/></f></get_R>
		<R public="1" get="accessor" set="null"><x path="Bool"/></R>
		<get_E get="inline" set="null" line="64"><f a=""><x path="Bool"/></f></get_E>
		<E public="1" get="accessor" set="null"><x path="Bool"/></E>
		<get_W get="inline" set="null" line="63"><f a=""><x path="Bool"/></f></get_W>
		<W public="1" get="accessor" set="null"><x path="Bool"/></W>
		<get_Q get="inline" set="null" line="62"><f a=""><x path="Bool"/></f></get_Q>
		<Q public="1" get="accessor" set="null"><x path="Bool"/></Q>
		<get_TAB get="inline" set="null" line="61"><f a=""><x path="Bool"/></f></get_TAB>
		<TAB public="1" get="accessor" set="null"><x path="Bool"/></TAB>
		<get_BACKSPACE get="inline" set="null" line="60"><f a=""><x path="Bool"/></f></get_BACKSPACE>
		<BACKSPACE public="1" get="accessor" set="null"><x path="Bool"/></BACKSPACE>
		<get_DELETE get="inline" set="null" line="59"><f a=""><x path="Bool"/></f></get_DELETE>
		<DELETE public="1" get="accessor" set="null"><x path="Bool"/></DELETE>
		<get_NUMPADPLUS get="inline" set="null" line="58"><f a=""><x path="Bool"/></f></get_NUMPADPLUS>
		<NUMPADPLUS public="1" get="accessor" set="null"><x path="Bool"/></NUMPADPLUS>
		<get_PLUS get="inline" set="null" line="57"><f a=""><x path="Bool"/></f></get_PLUS>
		<PLUS public="1" get="accessor" set="null"><x path="Bool"/></PLUS>
		<get_NUMPADMINUS get="inline" set="null" line="56"><f a=""><x path="Bool"/></f></get_NUMPADMINUS>
		<NUMPADMINUS public="1" get="accessor" set="null"><x path="Bool"/></NUMPADMINUS>
		<get_MINUS get="inline" set="null" line="55"><f a=""><x path="Bool"/></f></get_MINUS>
		<MINUS public="1" get="accessor" set="null"><x path="Bool"/></MINUS>
		<get_INSERT get="inline" set="null" line="54"><f a=""><x path="Bool"/></f></get_INSERT>
		<INSERT public="1" get="accessor" set="null"><x path="Bool"/></INSERT>
		<get_END get="inline" set="null" line="53"><f a=""><x path="Bool"/></f></get_END>
		<END public="1" get="accessor" set="null"><x path="Bool"/></END>
		<get_HOME get="inline" set="null" line="52"><f a=""><x path="Bool"/></f></get_HOME>
		<HOME public="1" get="accessor" set="null"><x path="Bool"/></HOME>
		<get_PAGEDOWN get="inline" set="null" line="51"><f a=""><x path="Bool"/></f></get_PAGEDOWN>
		<PAGEDOWN public="1" get="accessor" set="null"><x path="Bool"/></PAGEDOWN>
		<get_PAGEUP get="inline" set="null" line="50"><f a=""><x path="Bool"/></f></get_PAGEUP>
		<PAGEUP public="1" get="accessor" set="null"><x path="Bool"/></PAGEUP>
		<get_NUMPADZERO get="inline" set="null" line="49"><f a=""><x path="Bool"/></f></get_NUMPADZERO>
		<NUMPADZERO public="1" get="accessor" set="null"><x path="Bool"/></NUMPADZERO>
		<get_NUMPADNINE get="inline" set="null" line="48"><f a=""><x path="Bool"/></f></get_NUMPADNINE>
		<NUMPADNINE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADNINE>
		<get_NUMPADEIGHT get="inline" set="null" line="47"><f a=""><x path="Bool"/></f></get_NUMPADEIGHT>
		<NUMPADEIGHT public="1" get="accessor" set="null"><x path="Bool"/></NUMPADEIGHT>
		<get_NUMPADSEVEN get="inline" set="null" line="46"><f a=""><x path="Bool"/></f></get_NUMPADSEVEN>
		<NUMPADSEVEN public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSEVEN>
		<get_NUMPADSIX get="inline" set="null" line="45"><f a=""><x path="Bool"/></f></get_NUMPADSIX>
		<NUMPADSIX public="1" get="accessor" set="null"><x path="Bool"/></NUMPADSIX>
		<get_NUMPADFIVE get="inline" set="null" line="44"><f a=""><x path="Bool"/></f></get_NUMPADFIVE>
		<NUMPADFIVE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADFIVE>
		<get_NUMPADFOUR get="inline" set="null" line="43"><f a=""><x path="Bool"/></f></get_NUMPADFOUR>
		<NUMPADFOUR public="1" get="accessor" set="null"><x path="Bool"/></NUMPADFOUR>
		<get_NUMPADTHREE get="inline" set="null" line="42"><f a=""><x path="Bool"/></f></get_NUMPADTHREE>
		<NUMPADTHREE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADTHREE>
		<get_NUMPADTWO get="inline" set="null" line="41"><f a=""><x path="Bool"/></f></get_NUMPADTWO>
		<NUMPADTWO public="1" get="accessor" set="null"><x path="Bool"/></NUMPADTWO>
		<get_NUMPADONE get="inline" set="null" line="40"><f a=""><x path="Bool"/></f></get_NUMPADONE>
		<NUMPADONE public="1" get="accessor" set="null"><x path="Bool"/></NUMPADONE>
		<get_ZERO get="inline" set="null" line="39"><f a=""><x path="Bool"/></f></get_ZERO>
		<ZERO public="1" get="accessor" set="null"><x path="Bool"/></ZERO>
		<get_NINE get="inline" set="null" line="38"><f a=""><x path="Bool"/></f></get_NINE>
		<NINE public="1" get="accessor" set="null"><x path="Bool"/></NINE>
		<get_EIGHT get="inline" set="null" line="37"><f a=""><x path="Bool"/></f></get_EIGHT>
		<EIGHT public="1" get="accessor" set="null"><x path="Bool"/></EIGHT>
		<get_SEVEN get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></get_SEVEN>
		<SEVEN public="1" get="accessor" set="null"><x path="Bool"/></SEVEN>
		<get_SIX get="inline" set="null" line="35"><f a=""><x path="Bool"/></f></get_SIX>
		<SIX public="1" get="accessor" set="null"><x path="Bool"/></SIX>
		<get_FIVE get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></get_FIVE>
		<FIVE public="1" get="accessor" set="null"><x path="Bool"/></FIVE>
		<get_FOUR get="inline" set="null" line="33"><f a=""><x path="Bool"/></f></get_FOUR>
		<FOUR public="1" get="accessor" set="null"><x path="Bool"/></FOUR>
		<get_THREE get="inline" set="null" line="32"><f a=""><x path="Bool"/></f></get_THREE>
		<THREE public="1" get="accessor" set="null"><x path="Bool"/></THREE>
		<get_TWO get="inline" set="null" line="31"><f a=""><x path="Bool"/></f></get_TWO>
		<TWO public="1" get="accessor" set="null"><x path="Bool"/></TWO>
		<get_ONE get="inline" set="null" line="30"><f a=""><x path="Bool"/></f></get_ONE>
		<ONE public="1" get="accessor" set="null"><x path="Bool"/></ONE>
		<get_F12 get="inline" set="null" line="29"><f a=""><x path="Bool"/></f></get_F12>
		<F12 public="1" get="accessor" set="null"><x path="Bool"/></F12>
		<get_F11 get="inline" set="null" line="28"><f a=""><x path="Bool"/></f></get_F11>
		<F11 public="1" get="accessor" set="null"><x path="Bool"/></F11>
		<get_F10 get="inline" set="null" line="27"><f a=""><x path="Bool"/></f></get_F10>
		<F10 public="1" get="accessor" set="null"><x path="Bool"/></F10>
		<get_F9 get="inline" set="null" line="26"><f a=""><x path="Bool"/></f></get_F9>
		<F9 public="1" get="accessor" set="null"><x path="Bool"/></F9>
		<get_F8 get="inline" set="null" line="25"><f a=""><x path="Bool"/></f></get_F8>
		<F8 public="1" get="accessor" set="null"><x path="Bool"/></F8>
		<get_F7 get="inline" set="null" line="24"><f a=""><x path="Bool"/></f></get_F7>
		<F7 public="1" get="accessor" set="null"><x path="Bool"/></F7>
		<get_F6 get="inline" set="null" line="23"><f a=""><x path="Bool"/></f></get_F6>
		<F6 public="1" get="accessor" set="null"><x path="Bool"/></F6>
		<get_F5 get="inline" set="null" line="22"><f a=""><x path="Bool"/></f></get_F5>
		<F5 public="1" get="accessor" set="null"><x path="Bool"/></F5>
		<get_F4 get="inline" set="null" line="21"><f a=""><x path="Bool"/></f></get_F4>
		<F4 public="1" get="accessor" set="null"><x path="Bool"/></F4>
		<get_F3 get="inline" set="null" line="20"><f a=""><x path="Bool"/></f></get_F3>
		<F3 public="1" get="accessor" set="null"><x path="Bool"/></F3>
		<get_F2 get="inline" set="null" line="19"><f a=""><x path="Bool"/></f></get_F2>
		<F2 public="1" get="accessor" set="null"><x path="Bool"/></F2>
		<get_F1 get="inline" set="null" line="18"><f a=""><x path="Bool"/></f></get_F1>
		<F1 public="1" get="accessor" set="null"><x path="Bool"/></F1>
		<get_ESCAPE get="inline" set="null" line="17"><f a=""><x path="Bool"/></f></get_ESCAPE>
		<ESCAPE public="1" get="accessor" set="null"><x path="Bool"/></ESCAPE>
		<check><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></check>
		<new public="1" set="method" line="10"><f a="CheckFunction">
	<f a="">
		<c path="String"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for keyboard input.</haxe_doc>
	</class>
	<class path="flixel.system.input.keyboard.FlxKeyShortcuts" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/keyboard/FlxKeyShortcuts.hx">
		<justReleased public="1">
			<c path="flixel.system.input.keyboard.FlxKeyList"/>
			<haxe_doc>* Helper class to check if a keys was just released.</haxe_doc>
		</justReleased>
		<justPressed public="1">
			<c path="flixel.system.input.keyboard.FlxKeyList"/>
			<haxe_doc>* Helper class to check if a keys was just pressed.</haxe_doc>
		</justPressed>
		<pressed public="1">
			<c path="flixel.system.input.keyboard.FlxKeyList"/>
			<haxe_doc>* Helper class to check if a keys is pressed.</haxe_doc>
		</pressed>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A helper class for keyboard input.</haxe_doc>
	</class>
	<class path="flixel.system.input.keyboard.FlxKeyboard" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/keyboard/FlxKeyboard.hx">
		<implements path="flixel.system.input.IFlxInput"/>
		<TOTAL get="inline" set="null" line="25" static="1">
			<x path="Int"/>
			<haxe_doc>* Total amount of keys.</haxe_doc>
		</TOTAL>
		<toString public="1" get="inline" set="null" line="536"><f a=""><c path="String"/></f></toString>
		<onFocusLost public="1" get="inline" set="null" line="531"><f a=""><x path="Void"/></f></onFocusLost>
		<onFocus public="1" get="inline" set="null" line="529"><f a=""><x path="Void"/></f></onFocus>
		<updateKeyStates get="inline" set="null" line="498">
			<f a="KeyCode:Down">
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* A helper function to update the key states based on a keycode provided.</haxe_doc>
		</updateKeyStates>
		<inKeyArray set="method" line="475">
			<f a="KeyArray:KeyCode">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Helper function to check whether an array of keycodes contains 
	 * a certain key safely (returns false if the array is null).</haxe_doc>
		</inKeyArray>
		<onKeyDown set="method" line="445">
			<f a="FlashEvent">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * 
	 * @param	FlashEvent	Flash keyboard event.</haxe_doc>
		</onKeyDown>
		<onKeyUp set="method" line="373">
			<f a="FlashEvent">
				<c path="flash.events.KeyboardEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can toggle keys.
	 * 
	 * @param	FlashEvent	A <code>KeyboardEvent</code> object.]]></haxe_doc>
		</onKeyUp>
		<destroy public="1" set="method" line="362">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<getIsDown public="1" set="method" line="345">
			<f a=""><c path="Array"><c path="flixel.system.input.keyboard.FlxKey"/></c></f>
			<haxe_doc><![CDATA[* Get an Array of FlxMapObjects that are in a pressed state
	 * 
	 * @return	Array<FlxMapObject> of keys that are currently pressed.]]></haxe_doc>
		</getIsDown>
		<getKeyCode public="1" get="inline" set="null" line="335">
			<f a="KeyName">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Look up the key code for any given string name of the key or button.
	 * 
	 * @param	KeyName		The <code>String</code> name of the key.
	 * @return	The key code for that key.]]></haxe_doc>
		</getKeyCode>
		<playback public="1" set="method" line="314">
			<f a="Record">
				<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Part of the keystroke recording system.
	 * Takes data about key presses and sets it into array.
	 * 
	 * @param	Record	Array of data about key states.</haxe_doc>
		</playback>
		<record public="1" set="method" line="284">
			<f a=""><c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c></f>
			<haxe_doc>* If any keys are not "released" (0),
	 * this function will return an array indicating
	 * which keys are pressed and what state they are in.
	 * 
	 * @return	An array of key state data.  Null if there is no data.</haxe_doc>
		</record>
		<checkKeyStatus set="method" line="246">
			<f a="KeyArray:Status">
				<c path="Array"><d/></c>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Helper function to check the status of an array of keys
	 * @param	KeyArray	An array of keys as Strings
	 * @param	Status		The key state to check for
	 * @return	Whether at least one of the keys has the specified status</haxe_doc>
		</checkKeyStatus>
		<anyJustReleased public="1" get="inline" set="null" line="235">
			<f a="KeyArray">
				<c path="Array"><d/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Check to see if at least one key from an array of keys was just released. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: <code>FlxG.keyboard.anyJustReleased(["UP", "W", "SPACE"])</code>
	 * @param	KeyArray 	An array of keys as Strings
	 * @return	Whether at least one of the keys passed was just released.]]></haxe_doc>
		</anyJustReleased>
		<justReleased public="1">
			<d/>
			<haxe_doc><![CDATA[* Check to see if a key, or one key from a list of mutliple keys was just released. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: <code>FlxG.keyboard.justReleased("UP", "W", "SPACE")</code>]]></haxe_doc>
		</justReleased>
		<anyJustPressed public="1" get="inline" set="null" line="218">
			<f a="KeyArray">
				<c path="Array"><d/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Check to see if at least one key from an array of keys was just pressed. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: <code>FlxG.keyboard.anyJustPressed(["UP", "W", "SPACE"])</code>
	 * @param	KeyArray 	An array of keys as Strings
	 * @return	Whether at least one of the keys passed was just pressed.]]></haxe_doc>
		</anyJustPressed>
		<justPressed public="1">
			<d/>
			<haxe_doc><![CDATA[* Check to see if a key, or one key from a list of mutliple keys was just pressed. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: <code>FlxG.keyboard.justPressed("UP", "W", "SPACE")</code>]]></haxe_doc>
		</justPressed>
		<anyPressed public="1" get="inline" set="null" line="201">
			<f a="KeyArray">
				<c path="Array"><d/></c>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Check to see if at least one key from an array of keys is pressed. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: <code>FlxG.keyboard.anyPressed(["UP", "W", "SPACE"])</code>
	 * @param	KeyArray 	An array of keys as Strings
	 * @return	Whether at least one of the keys passed in is pressed.]]></haxe_doc>
		</anyPressed>
		<pressed public="1">
			<d/>
			<haxe_doc><![CDATA[* Check to see if a key, or one key from a list of mutliple keys is pressed. See FlxG.keys for the key names, pass them in as Strings.
	 * Example: <code>FlxG.keyboard.pressed("UP", "W", "SPACE")</code>]]></haxe_doc>
		</pressed>
		<reset public="1" set="method" line="177">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all the keys.</haxe_doc>
		</reset>
		<update public="1" set="method" line="152">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the key states (for tracking just pressed, just released, etc).</haxe_doc>
		</update>
		<addKey set="method" line="143">
			<f a="KeyName:KeyCode">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal helper function used to build the key array.
	 * 
	 * @param	KeyName		String name of the key (e.g. "LEFT" or "A")
	 * @param	KeyCode		The numeric Flash code for this key.</haxe_doc>
		</addKey>
		<_keyList>
			<c path="Array"><c path="flixel.system.input.keyboard.FlxKey"/></c>
			<meta><m n=":allow"><e>'???'</e></m></meta>
			<haxe_doc>* An array of FlxKey objects.</haxe_doc>
		</_keyList>
		<_keyLookup>
			<x path="Map">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* A map for key lookup.</haxe_doc>
		</_keyLookup>
		<enabled public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether or not keyboard input is currently enabled.</haxe_doc>
		</enabled>
		<new public="1" set="method" line="37"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Keeps track of what keys are pressed and how with handy Bools or strings.</haxe_doc>
	</class>
	<class path="flixel.system.input.mouse.FlxMouse" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/mouse/FlxMouse.hx">
		<extends path="flixel.util.FlxPoint"/>
		<implements path="flixel.system.input.IFlxInput"/>
		<set_useSystemCursor set="method" line="614"><f a="value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_useSystemCursor>
		<useSystemCursor public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>* Tells flixel to use the default system mouse cursor instead of custom Flixel mouse cursors.
	 * @default false</haxe_doc>
		</useSystemCursor>
		<hideSystemCursor set="method" line="595">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hide the system cursor, if Flash 10.2 return to default</haxe_doc>
		</hideSystemCursor>
		<showSystemCursor set="method" line="582">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Show the default system cursor, if Flash 10.2 return to AUTO</haxe_doc>
		</showSystemCursor>
		<onFocusLost public="1" get="inline" set="null" line="574">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called from the main Event.DEACTIVATE is dispatched in FlxGame</haxe_doc>
		</onFocusLost>
		<onFocus public="1" get="inline" set="null" line="565">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called from the main Event.ACTIVATE is dispatched in FlxGame</haxe_doc>
		</onFocus>
		<playback public="1" set="method" line="553">
			<f a="Record">
				<c path="flixel.system.replay.MouseRecord"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Part of the keystroke recording system.
	 * Takes data about key presses and sets it into array.
	 * @param KeyStates Array of data about key states.</haxe_doc>
		</playback>
		<record public="1" set="method" line="536">
			<f a=""><c path="flixel.system.replay.MouseRecord"/></f>
			<haxe_doc>* If the mouse changed state or is pressed, return that info now
	 * @return An array of key state data. Null if there is no data.</haxe_doc>
		</record>
		<get_justReleased get="inline" set="null" line="474"><f a=""><x path="Bool"/></f></get_justReleased>
		<justReleased public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the mouse was just released.
	 * @return 	Whether the mouse was just released.</haxe_doc>
		</justReleased>
		<get_justPressed get="inline" set="null" line="466"><f a=""><x path="Bool"/></f></get_justPressed>
		<justPressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the mouse was just pressed.
	 * @return 	Whether the mouse was just pressed.</haxe_doc>
		</justPressed>
		<get_pressed get="inline" set="null" line="458"><f a=""><x path="Bool"/></f></get_pressed>
		<pressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the mouse is pressed.
	 * @return 	Whether the mouse is pressed.</haxe_doc>
		</pressed>
		<reset public="1" set="method" line="442">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the just pressed/just released flags and sets mouse to not pressed.</haxe_doc>
		</reset>
		<getScreenPosition public="1" set="method" line="424">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the mouse on any given camera.
	 * NOTE: Mouse.screenX and Mouse.screenY also store the screen position of the mouse cursor on the main camera.
	 * @param 	Camera 	If unspecified, first/main global camera is used instead.
	 * @param 	point 	An existing point object to store the results (if you don't want a new one created).
	 * @return 	The mouse's location in screen space.</haxe_doc>
		</getScreenPosition>
		<getWorldPosition public="1" set="method" line="401">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the mouse on any given camera.
	 * NOTE: Mouse.x and Mouse.y also store the world position of the mouse cursor on the main camera.
	 * @param 	Camera 	If unspecified, first/main global camera is used instead.
	 * @param 	point 	An existing point object to store the results (if you don't want a new one created).
	 * @return 	The mouse's location in world space.</haxe_doc>
		</getWorldPosition>
		<updateCursor set="method" line="376">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for helping to update the mouse cursor and world coordinates.</haxe_doc>
		</updateCursor>
		<update public="1" set="method" line="349">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the mouse pointer's position in the game world.
	 * Also updates the just pressed/just released flags.
	 * @param 	X 	The current X position of the mouse in the window.
	 * @param 	Y 	The current Y position of the mouse in the window.</haxe_doc>
		</update>
		<unload public="1" set="method" line="273">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Unload the current cursor graphic. If the current cursor is visible,
	 * then the default system cursor is loaded up to replace the old one.</haxe_doc>
		</unload>
		<load public="1" set="method" line="226">
			<f a="?Graphic:?Scale:?XOffset:?YOffset">
				<d/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Load a new mouse cursor graphic
	 * @param 	Graphic 	The image you want to use for the cursor.
	 * @param 	Scale 		Change the size of the cursor.
	 * @param 	XOffset 	The number of pixels between the mouse's screen position and the graphic's top left corner.
	 * @param 	YOffset 	The number of pixels between the mouse's screen position and the graphic's top left corner.</haxe_doc>
		</load>
		<get_visible get="inline" set="null" line="214">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Read only, check visibility of mouse cursor.</haxe_doc>
		</get_visible>
		<hide public="1" get="inline" set="null" line="205">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Hides the mouse cursor</haxe_doc>
		</hide>
		<show public="1" set="method" line="183">
			<f a="?Graphic:?Scale:?XOffset:?YOffset">
				<d/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Either show an existing cursor or load a new one.
	 * @param 	Graphic 	The image you want to use for the cursor.
	 * @param 	Scale 		Change the size of the cursor. Default = 1, or native size. 2 = 2x as big, 0.5 = half size, etc.
	 * @param 	XOffset 	The number of pixels between the mouse's screen position and the graphic's top left corner.
	 * @param 	YOffset 	The number of pixels between the mouse's screen position and the graphic's top left corner.</haxe_doc>
		</show>
		<destroy public="1" set="method" line="162">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<onMouseWheel set="method" line="132">
			<f a="FlashEvent">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param FlashEvent Flash mouse event.</haxe_doc>
		</onMouseWheel>
		<_globalScreenPosition><c path="flixel.util.FlxPoint"/></_globalScreenPosition>
		<_point><c path="flixel.util.FlxPoint"/></_point>
		<_lastWheel><x path="Int"/></_lastWheel>
		<_lastY><x path="Int"/></_lastY>
		<_lastX>
			<x path="Int"/>
			<haxe_doc>* Helper variables for recording purposes.</haxe_doc>
		</_lastX>
		<_wheelUsed><x path="Bool"/></_wheelUsed>
		<_cursorBitmapData><c path="flash.display.BitmapData"/></_cursorBitmapData>
		<_cursor>
			<c path="flash.display.Bitmap"/>
			<haxe_doc>* This is just a reference to the current cursor image, if there is one.</haxe_doc>
		</_cursor>
		<_updateCursorContainer>
			<x path="Bool"/>
			<haxe_doc>* Don't update cursor unless we have to (this is essentially a "visible" bool, 
	 * so we avoid checking the visible property in the Sprite which is slow in cpp).</haxe_doc>
		</_updateCursorContainer>
		<cursorContainer public="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* A display container for the mouse cursor.
	 * This container is a child of FlxGame and sits at the right "height".</haxe_doc>
		</cursorContainer>
		<_leftButton>
			<c path="flixel.system.input.mouse.FlxMouseButton"/>
			<haxe_doc>* The left mouse button.</haxe_doc>
		</_leftButton>
		<visible public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Property to check if the cursor is visible or not.</haxe_doc>
		</visible>
		<screenY public="1">
			<x path="Int"/>
			<haxe_doc>* Current Y position of the mouse pointer on the screen.</haxe_doc>
		</screenY>
		<screenX public="1">
			<x path="Int"/>
			<haxe_doc>* Current X position of the mouse pointer on the screen.</haxe_doc>
		</screenX>
		<wheel public="1">
			<x path="Int"/>
			<haxe_doc>* Current "delta" value of mouse wheel. If the wheel was just scrolled up, it will have a positive value. 
	 * If it was just scrolled down, it will have a negative value. If it wasn't just scroll this frame, it will be 0.</haxe_doc>
		</wheel>
		<new public="1" set="method" line="101">
			<f a="CursorContainer">
				<c path="flash.display.Sprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Names for the Native Flash 10.2 Cursors</haxe_doc>
		</new>
		<haxe_doc>* This class helps contain and track the mouse pointer in your game.
* Automatically accounts for parallax scrolling, etc.</haxe_doc>
	</class>
	<class path="flixel.system.input.mouse.FlxMouseButton" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/mouse/FlxMouseButton.hx">
		<FAST_PRESS_RELEASE public="1" get="inline" set="null" line="11" static="1"><x path="Int"/></FAST_PRESS_RELEASE>
		<JUST_RELEASED public="1" get="inline" set="null" line="12" static="1"><x path="Int"/></JUST_RELEASED>
		<RELEASED public="1" get="inline" set="null" line="13" static="1"><x path="Int"/></RELEASED>
		<PRESSED public="1" get="inline" set="null" line="14" static="1"><x path="Int"/></PRESSED>
		<JUST_PRESSED public="1" get="inline" set="null" line="15" static="1"><x path="Int"/></JUST_PRESSED>
		<justReleased public="1" get="inline" set="null" line="164">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if the button was just released.
	 * @return 	Whether the button was just released.</haxe_doc>
		</justReleased>
		<justPressed public="1" get="inline" set="null" line="158">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if the button was just pressed.
	 * @return 	Whether the button was just pressed.</haxe_doc>
		</justPressed>
		<pressed public="1" get="inline" set="null" line="152">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if the button is pressed.
	 * @return 	Whether the button is pressed.</haxe_doc>
		</pressed>
		<reset public="1" get="inline" set="null" line="142">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets the just pressed/just released flags and sets mouse to not pressed.</haxe_doc>
		</reset>
		<onUp public="1" set="method" line="115">
			<f a="?FlashEvent">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param FlashEvent Flash mouse event.</haxe_doc>
		</onUp>
		<onDown public="1" set="method" line="61">
			<f a="FlashEvent">
				<c path="flash.events.MouseEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal event handler for input and focus.
	 * @param 	FlashEvent Flash mouse event.</haxe_doc>
		</onDown>
		<update public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Upates the last and current state of this mouse button.</haxe_doc>
		</update>
		<_isLeftMouse>
			<x path="Bool"/>
			<haxe_doc>* Whether this is the left mouse button.</haxe_doc>
		</_isLeftMouse>
		<last public="1">
			<x path="Int"/>
			<haxe_doc>* The last state of this mouse button.</haxe_doc>
		</last>
		<current public="1">
			<x path="Int"/>
			<haxe_doc>* The current state of this mouse button.</haxe_doc>
		</current>
		<new public="1" set="method" line="31"><f a="?IsLeftMouse">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* A helper class for mouse input</haxe_doc>
	</class>
	<class path="flixel.system.input.touch.FlxTouch" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/touch/FlxTouch.hx">
		<extends path="flixel.util.FlxPoint"/>
		<get_isActive get="inline" set="null" line="258"><f a=""><x path="Bool"/></f></get_isActive>
		<isActive public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the touch is active.
	 * @return	Whether the touch is active.</haxe_doc>
		</isActive>
		<get_justReleased get="inline" set="null" line="250"><f a=""><x path="Bool"/></f></get_justReleased>
		<justReleased public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the touch was just ended.
	 * @return	Whether the touch was just ended.</haxe_doc>
		</justReleased>
		<get_justPressed get="inline" set="null" line="242"><f a=""><x path="Bool"/></f></get_justPressed>
		<justPressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the touch was just began.
	 * @return Whether the touch was just began.</haxe_doc>
		</justPressed>
		<get_pressed get="inline" set="null" line="234"><f a=""><x path="Bool"/></f></get_pressed>
		<pressed public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Check to see if the touch is pressed.
	 * @return	Whether the touch is pressed.</haxe_doc>
		</pressed>
		<deactivate public="1" set="method" line="222"><f a=""><x path="Void"/></f></deactivate>
		<reset public="1" set="method" line="214">
			<f a="X:Y:PointID">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Resets the just pressed/just released flags and sets touch to not pressed.</haxe_doc>
		</reset>
		<overlaps public="1" set="method" line="188">
			<f a="ObjectOrGroup:?Camera">
				<c path="flixel.FlxBasic"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxObject</code> overlaps this <code>FlxObject</code> or <code>FlxGroup</code>.
	 * If the group has a LOT of things in it, it might be faster to use <code>FlxG.overlaps()</code>.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * @param ObjectOrGroup The object or group being tested.
	 * @param Camera Specify which game camera you want. If null getScreenXY() will just grab the first global camera.
	 * @return Whether or not the two objects overlap.]]></haxe_doc>
		</overlaps>
		<getScreenPosition public="1" set="method" line="165">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the screen position of the touch on any given camera.
	 * NOTE: Touch.screenX and Touch.screenY also store the screen position of the touch point on the main camera.
	 * @param Camera	If unspecified, first/main global camera is used instead.
	 * @param point		An existing point object to store the results (if you don't want a new one created). 
	 * @return The touch point's location in screen space.</haxe_doc>
		</getScreenPosition>
		<getWorldPosition public="1" set="method" line="142">
			<f a="?Camera:?point">
				<c path="flixel.FlxCamera"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Fetch the world position of the touch on any given camera.
	 * NOTE: Touch.x and Touch.y also store the world position of the touch point on the main camera.
	 * @param Camera	If unspecified, first/main global camera is used instead.
	 * @param point		An existing point object to store the results (if you don't want a new one created). 
	 * @return The touch point's location in world space.</haxe_doc>
		</getWorldPosition>
		<updateCursor set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function for helping to update world coordinates.</haxe_doc>
		</updateCursor>
		<updateTouchPosition public="1" set="method" line="110">
			<f a="X:Y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Function for updating touch coordinates. Called by the TouchManager.
	 * @param	X	stageX touch coordinate
	 * @param	Y	stageY touch coordinate</haxe_doc>
		</updateTouchPosition>
		<update public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the just pressed/just released flags.</haxe_doc>
		</update>
		<get_touchPointID set="method" line="84"><f a=""><x path="Int"/></f></get_touchPointID>
		<touchPointID public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* A unique identification number (as an Int) assigned to the touch point.</haxe_doc>
		</touchPointID>
		<destroy public="1" set="method" line="72">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_flashPoint public="1"><c path="flash.geom.Point"/></_flashPoint>
		<_globalScreenPosition><c path="flixel.util.FlxPoint"/></_globalScreenPosition>
		<_point>
			<c path="flixel.util.FlxPoint"/>
			<haxe_doc>* Helper variables for recording purposes.</haxe_doc>
		</_point>
		<_last public="1">
			<x path="Int"/>
			<haxe_doc>* Helper variable for tracking whether the touch was just began or just ended.</haxe_doc>
		</_last>
		<_current public="1">
			<x path="Int"/>
			<haxe_doc>* Helper variable for tracking whether the touch was just began or just ended.</haxe_doc>
		</_current>
		<screenY public="1">
			<x path="Int"/>
			<haxe_doc>* Current Y position of the touch point on the screen.</haxe_doc>
		</screenY>
		<screenX public="1">
			<x path="Int"/>
			<haxe_doc>* Current X position of the touch point on the screen.</haxe_doc>
		</screenX>
		<_touchPointID>
			<x path="Int"/>
			<haxe_doc>* A unique identification number (as an Int) assigned to the touch point.</haxe_doc>
		</_touchPointID>
		<new public="1" set="method" line="54">
			<f a="?X:?Y:?PointID">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * @param	X			stageX touch coordinate
	 * @param	Y			stageX touch coordinate
	 * @param	PointID		touchPointID of the touch</haxe_doc>
		</new>
		<haxe_doc>* Helper class, contains and track touch points in your game.
 * Automatically accounts for parallax scrolling, etc.</haxe_doc>
	</class>
	<class path="flixel.system.input.touch.FlxTouchManager" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/input/touch/FlxTouchManager.hx">
		<implements path="flixel.system.input.IFlxInput"/>
		<maxTouchPoints public="1" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* The maximum number of concurrent touch points supported by the current device.</haxe_doc>
		</maxTouchPoints>
		<toString public="1" set="method" line="300"><f a=""><c path="String"/></f></toString>
		<onFocusLost public="1" set="method" line="295"><f a=""><x path="Void"/></f></onFocusLost>
		<onFocus public="1" set="method" line="290"><f a=""><x path="Void"/></f></onFocus>
		<recycle set="method" line="278">
			<f a="X:Y:PointID">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<c path="flixel.system.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* Internal function for touch reuse
	 * @param	X			stageX touch coordinate
	 * @param	Y			stageY touch coordinate
	 * @param	PointID		id of the touch
	 * @return				recycled touch object</haxe_doc>
		</recycle>
		<add set="method" line="264">
			<f a="Touch">
				<c path="flixel.system.input.touch.FlxTouch"/>
				<c path="flixel.system.input.touch.FlxTouch"/>
			</f>
			<haxe_doc>* Internal function for adding new touches to the manager
	 * @param	Touch	A new FlxTouch object
	 * @return	The added FlxTouch object</haxe_doc>
		</add>
		<justReleased public="1" set="method" line="235">
			<f a="?TouchArray">
				<c path="Array"><c path="flixel.system.input.touch.FlxTouch"/></c>
				<c path="Array"><c path="flixel.system.input.touch.FlxTouch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just ended
	 * @param	TouchArray		optional array to fill with touch objects
	 * @return					array with touches</haxe_doc>
		</justReleased>
		<justStarted public="1" set="method" line="205">
			<f a="?TouchArray">
				<c path="Array"><c path="flixel.system.input.touch.FlxTouch"/></c>
				<c path="Array"><c path="flixel.system.input.touch.FlxTouch"/></c>
			</f>
			<haxe_doc>* Gets all touches which were just started
	 * @param	TouchArray		optional array to fill with touch objects
	 * @return					array with touches</haxe_doc>
		</justStarted>
		<handleTouchMove set="method" line="190">
			<f a="FlashEvent">
				<c path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update touches.
	 * @param	FlashEvent	A <code>TouchEvent</code> object.]]></haxe_doc>
		</handleTouchMove>
		<handleTouchEnd set="method" line="169">
			<f a="FlashEvent">
				<c path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update touches.
	 * @param	FlashEvent	A <code>TouchEvent</code> object.]]></haxe_doc>
		</handleTouchEnd>
		<handleTouchBegin set="method" line="144">
			<f a="FlashEvent">
				<c path="flash.events.TouchEvent"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Event handler so FlxGame can update touches.
	 * @param	FlashEvent	A <code>TouchEvent</code> object.]]></haxe_doc>
		</handleTouchBegin>
		<reset public="1" set="method" line="124">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Resets all touches to inactive state.</haxe_doc>
		</reset>
		<update public="1" set="method" line="95">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called by the internal game loop to update the touch position in the game world.
	 * Also updates the just pressed/just released flags.</haxe_doc>
		</update>
		<destroy public="1" set="method" line="74">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<getFirst public="1" set="method" line="59">
			<f a=""><c path="flixel.system.input.touch.FlxTouch"/></f>
			<haxe_doc>* Return the first touch if there is one, beware of null</haxe_doc>
		</getFirst>
		<_touchesCache>
			<x path="Map">
				<x path="Int"/>
				<c path="flixel.system.input.touch.FlxTouch"/>
			</x>
			<haxe_doc>* Helper storage for active touches (for faster access)</haxe_doc>
		</_touchesCache>
		<_inactiveTouches>
			<c path="Array"><c path="flixel.system.input.touch.FlxTouch"/></c>
			<haxe_doc>* Storage for inactive touches (some sort of cache for them).</haxe_doc>
		</_inactiveTouches>
		<list public="1">
			<c path="Array"><c path="flixel.system.input.touch.FlxTouch"/></c>
			<haxe_doc>* All active touches including just created, moving and just released.</haxe_doc>
		</list>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Constructor</haxe_doc>
		</new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.system.layer.DrawStackItem" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/DrawStackItem.hx">
		<dispose public="1" set="method" line="36"><f a=""><x path="Void"/></f></dispose>
		<reset public="1" get="inline" set="null" line="28"><f a=""><x path="Void"/></f></reset>
		<antialiasing public="1"><x path="Bool"/></antialiasing>
		<initialized public="1"><x path="Bool"/></initialized>
		<useAlpha public="1"><x path="Bool"/></useAlpha>
		<next public="1"><c path="flixel.system.layer.DrawStackItem"/></next>
		<position public="1"><x path="Int"/></position>
		<drawData public="1"><c path="Array"><x path="Float"/></c></drawData>
		<graphics public="1"><c path="flixel.util.loaders.CachedGraphics"/></graphics>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.layer.Region" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/Region.hx">
		<clone public="1" set="method" line="69"><f a=""><c path="flixel.system.layer.Region"/></f></clone>
		<get_numCols set="method" line="57"><f a=""><x path="Int"/></f></get_numCols>
		<numCols public="1" get="accessor" set="null"><x path="Int"/></numCols>
		<get_numRows set="method" line="43"><f a=""><x path="Int"/></f></get_numRows>
		<numRows public="1" get="accessor" set="null"><x path="Int"/></numRows>
		<get_numTiles set="method" line="36"><f a=""><x path="Int"/></f></get_numTiles>
		<numTiles public="1" get="accessor" set="null"><x path="Int"/></numTiles>
		<spacingY public="1"><x path="Int"/></spacingY>
		<spacingX public="1"><x path="Int"/></spacingX>
		<tileHeight public="1"><x path="Int"/></tileHeight>
		<tileWidth public="1"><x path="Int"/></tileWidth>
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<startY public="1"><x path="Int"/></startY>
		<startX public="1"><x path="Int"/></startX>
		<new public="1" set="method" line="19"><f a="?startX:?startY:?tileWidth:?tileHeight:?spacingX:?spacingY:?width:?height">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.TileSheetData" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/TileSheetData.hx">
		<destroyFrameBitmapDatas public="1" set="method" line="272"><f a=""><x path="Void"/></f></destroyFrameBitmapDatas>
		<addTexturePackerFrame set="method" line="239">
			<f a="frameData:?startX:?startY">
				<c path="flixel.util.loaders.TextureAtlasFrame"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Parses frame TexturePacker data object and returns it</haxe_doc>
		</addTexturePackerFrame>
		<getTexturePackerFrames public="1" set="method" line="214">
			<f a="data:?startX:?startY">
				<c path="flixel.util.loaders.TexturePackerData"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.system.layer.frames.FlxSpriteFrames"/>
			</f>
			<haxe_doc>* Parses provided TexturePackerData object and returns generated FlxSpriteFrames object</haxe_doc>
		</getTexturePackerFrames>
		<onContext public="1" set="method" line="202"><f a="bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></onContext>
		<destroy public="1" set="method" line="175"><f a=""><x path="Void"/></f></destroy>
		<addTileRect public="1" set="method" line="169"><f a="tileRect:?point">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
</f></addTileRect>
		<containsFrame public="1" set="method" line="163"><f a="key">
	<c path="String"/>
	<x path="Bool"/>
</f></containsFrame>
		<addSpriteSheetFrame public="1" set="method" line="138">
			<f a="rect:point">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</f>
			<haxe_doc>* Adds new FlxFrame to this TileSheetData object</haxe_doc>
		</addSpriteSheetFrame>
		<getSpriteSheetFrameKey public="1" set="method" line="130"><f a="rect:point">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
</f></getSpriteSheetFrameKey>
		<getKeyForSpriteSheetFrames public="1" set="method" line="125"><f a="width:height:startX:startY:endX:endY:xSpacing:ySpacing:pointX:pointY">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="String"/>
</f></getKeyForSpriteSheetFrames>
		<containsSpriteSheetFrames public="1" set="method" line="119"><f a="width:height:startX:startY:endX:endY:xSpacing:ySpacing:pointX:pointY">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></containsSpriteSheetFrames>
		<getSpriteSheetFrames public="1" set="method" line="56">
			<f a="region:?origin">
				<c path="flixel.system.layer.Region"/>
				<c path="flash.geom.Point"/>
				<c path="flixel.system.layer.frames.FlxSpriteFrames"/>
			</f>
			<haxe_doc>* Adds new ID array for FlxSprite with specific dimensions
	 * @param	width	sprite width
	 * @param	height	sprite height
	 * @return			IDs of tileRectangles for FlxSprite with given dimensions</haxe_doc>
		</getSpriteSheetFrames>
		<getFrame public="1" set="method" line="45"><f a="name">
	<c path="String"/>
	<c path="flixel.system.layer.frames.FlxFrame"/>
</f></getFrame>
		<bitmap public="1"><c path="flash.display.BitmapData"/></bitmap>
		<flxFrames>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.system.layer.frames.FlxFrame"/>
			</x>
			<haxe_doc>* Storage for all FlxFrames in this TileSheetData object.</haxe_doc>
		</flxFrames>
		<flxSpriteFrames>
			<x path="Map">
				<c path="String"/>
				<c path="flixel.system.layer.frames.FlxSpriteFrames"/>
			</x>
			<haxe_doc>* Storage for all groups of FlxFrames.</haxe_doc>
		</flxSpriteFrames>
		<tileSheet public="1"><c path="flixel.system.layer.TileSheetExt"/></tileSheet>
		<new public="1" set="method" line="35"><f a="bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Object of this class holds information about single Tilesheet</haxe_doc>
	</class>
	<class path="openfl.display.Tilesheet" params="" file="/media/psf/Home/projects/repos/public/openfl/openfl/display/Tilesheet.hx" extern="1">
		<TILE_SCALE public="1" static="1"><x path="Int"/></TILE_SCALE>
		<TILE_ROTATION public="1" static="1"><x path="Int"/></TILE_ROTATION>
		<TILE_RGB public="1" static="1"><x path="Int"/></TILE_RGB>
		<TILE_ALPHA public="1" static="1"><x path="Int"/></TILE_ALPHA>
		<TILE_TRANS_2x2 public="1" static="1"><x path="Int"/></TILE_TRANS_2x2>
		<TILE_BLEND_NORMAL public="1" static="1"><x path="Int"/></TILE_BLEND_NORMAL>
		<TILE_BLEND_ADD public="1" static="1"><x path="Int"/></TILE_BLEND_ADD>
		<drawTiles public="1" set="method">
			<f a="graphics:tileData:?smooth:?flags">
				<c path="flash.display.Graphics"/>
				<c path="Array"><x path="Float"/></c>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fast method to render a batch of tiles from the Tilesheet graphic
	 * 
	 * A standard "drawTiles" call expects a repeating set of three values: the X and Y
	 * coordinates, followed by the tileID that should be rendered. You can repeat this
	 * pattern for as many tiles you wish to render.
	 * 
	 * If you specify drawing flags, the draw list increases in size to accommodate the 
	 * additional properties needed. You may specify TILE_SCALE, TILE_ROTATION, TILE_RGB 
	 * and/or TILE_ALPHA.
	 * 
	 * This means that the draw list will increase from [ x, y, tileID ... ] to
	 * [ x, y, tileID, scale, rotation, red, green, blue, alpha ... ] depending on which
	 * flags are active.
	 * 
	 * If you use the TILE_TRANS_2x2 flag, it means you wish to use a 2x2 Matrix transform
	 * while rendering. If you use TILE_TRANS_2x2, the TILE_SCALE and TILE_ROTATION flags
	 * will be ignored. Using this flag, the draw list will expect the following order:
	 * 
	 * [ x, y, tileID, a, b, c, d, red, green, blue, alpha ... ]
	 * 
	 * ...of course, if you are not using TILE_RGB or TILE_ALPHA, then you would repeat the
	 * pattern directly following the matrix "a", "b", "c" and "d" values.
	 * 
	 * @example
	 * 
	 * var bitmapData = Assets.getBitmapData("image.png");
	 * var tilesheet = new Tilesheet(bitmapData);
	 * 
	 * tilesheet.addTileRect(new Rectangle(0, 0, 100, 100));
	 * 
	 * // x, y, tileID, scale, alpha
	 * 
	 * var drawList = [
	 * 	100, 100, 0, 2, 0.5,
	 * 	100, 200, 0, 2, 0.5
	 * ];
	 * 
	 * tilesheet.drawTiles(this, drawList, true, Tilesheet.TILE_SCALE | Tilesheet.TILE_ALPHA);
	 * 
	 * @param	graphics		The nme.display.Graphics object to use for drawing
	 * @param	tileData		An array of all position, ID and optional values for use in drawing
	 * @param	smooth		(Optional) Whether tiles should be smoothed while drawing(Default: false)
	 * @param	flags		(Optional) Flags to enable scale, rotation, RGB and/or alpha when drawing(Default: 0)</haxe_doc>
		</drawTiles>
		<addTileRect public="1" set="method">
			<f a="rectangle:?centerPoint">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Add a new tile to the Tilesheet
	 * 
	 * Beginning with 0, each tile is assigned an indentifier internally, which you
	 * can use to reference the geometry later while rendering.
	 * 
	 * For example, if you have only called "addTileRect" once on a Tilesheet, you
	 * would reference that tile using a tile ID of 0. If you have called "addTileRect"
	 * three times, the third tile would have an ID of 2.
	 * 
	 * Specify a rectangle within the bounds of the Tilesheet bitmap. This portion of the 
	 * Tilesheet will be rendered when ever you request a draw of this tile ID.
	 * 
	 * You may also (optionally) specify a center point, which is used during positioning,
	 * scale and rotation. The center point should be a coordinate within the tile
	 * rectangle.
	 * 
	 * @param	rectangle
	 * @param	centerPoint</haxe_doc>
		</addTileRect>
		<new public="1" set="method"><f a="inImage">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* In order to optimize for faster performance than individual 
 * drawing calls, the Tilesheet provides an alternative API with
 * several constraints to play nicely with hardware rendering.
 * 
 * First, every Tilesheet can only use one BitmapData as a texture.
 * This restriction provides the opportunity to copy only one texture
 * to the GPU memory before rendering.
 * 
 * Second, the Tilesheet uses pre-defined geometry. You may make as 
 * many calls as you want to "addTileRect" to add tile geometry. You
 * can reference this geometry later when you perform batch rendering,
 * using a zero-based ID for the tile.
 * 
 * When you are ready, the "drawTiles" method accepts a draw list with
 * the ID of the tile, as well as additional values needed, depending
 * on whether you are only rendering with the tile position, or if 
 * you have enabled flags for TILE_SCALE, TILE_ROTATION, TILE_RGB,
 * TILE_ALPHA or TILE_TRANS_2x2.
 * 
 * @example
 * 
 * var bitmapData = Assets.getBitmapData("image.png");
 * var tilesheet = new Tilesheet(bitmapData);
 * 
 * var tile = tilesheet.addTileRect(new Rectangle(0, 0, 100, 100));
 * tilesheet.drawTiles(this, [ tile, 100, 100 ]);
 *</haxe_doc>
	</class>
	<class path="flixel.system.layer.TileSheetExt" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/TileSheetExt.hx">
		<extends path="openfl.display.Tilesheet"/>
		<_DRAWCALLS public="1" line="11" static="1"><x path="Int"/></_DRAWCALLS>
		<destroy public="1" set="method" line="77"><f a=""><x path="Void"/></f></destroy>
		<addTileRectID public="1" set="method" line="60">
			<f a="rect:?point">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Point"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Adds new tileRect to tileSheet object
	 * @return id of added tileRect</haxe_doc>
		</addTileRectID>
		<getKey set="method" line="46"><f a="rect:?point">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
</f></getKey>
		<rebuildFromOld public="1" set="method" line="27"><f a="old">
	<c path="flixel.system.layer.TileSheetExt"/>
	<x path="Void"/>
</f></rebuildFromOld>
		<tileOrder public="1"><c path="Array"><c path="String"/></c></tileOrder>
		<tileIDs public="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.system.layer.RectPointTileID"/>
</x></tileIDs>
		<numTiles public="1"><x path="Int"/></numTiles>
		<new public="1" set="method" line="18"><f a="bitmap">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.RectPointTileID" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/TileSheetExt.hx" module="flixel.system.layer.TileSheetExt">
		<destroy public="1" set="method" line="104"><f a=""><x path="Void"/></f></destroy>
		<id public="1"><x path="Int"/></id>
		<point public="1"><c path="flash.geom.Point"/></point>
		<rect public="1"><c path="flash.geom.Rectangle"/></rect>
		<new public="1" set="method" line="97"><f a="id:rect:point">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.frames.FlxFrame" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/frames/FlxFrame.hx">
		<POINT public="1" line="14" static="1"><c path="flash.geom.Point"/></POINT>
		<MATRIX public="1" line="15" static="1"><c path="flash.geom.Matrix"/></MATRIX>
		<destroyBitmapDatas public="1" set="method" line="106"><f a=""><x path="Void"/></f></destroyBitmapDatas>
		<getReversedBitmap public="1" set="method" line="89"><f a=""><c path="flash.display.BitmapData"/></f></getReversedBitmap>
		<getBitmap public="1" set="method" line="57"><f a=""><c path="flash.display.BitmapData"/></f></getBitmap>
		<destroy public="1" set="method" line="43"><f a=""><x path="Void"/></f></destroy>
		<center public="1"><c path="flixel.util.FlxPoint"/></center>
		<_tileSheet><c path="flixel.system.layer.TileSheetData"/></_tileSheet>
		<_reversedBitmapData><c path="flash.display.BitmapData"/></_reversedBitmapData>
		<_bitmapData><c path="flash.display.BitmapData"/></_bitmapData>
		<additionalAngle public="1"><x path="Float"/></additionalAngle>
		<tileID public="1"><x path="Int"/></tileID>
		<offset public="1"><c path="flixel.util.FlxPoint"/></offset>
		<sourceSize public="1"><c path="flixel.util.FlxPoint"/></sourceSize>
		<trimmed public="1"><x path="Bool"/></trimmed>
		<rotated public="1"><x path="Bool"/></rotated>
		<frame public="1"><c path="flash.geom.Rectangle"/></frame>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="37"><f a="tileSheet">
	<c path="flixel.system.layer.TileSheetData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.layer.frames.FlxSpriteFrames" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/layer/frames/FlxSpriteFrames.hx">
		<destroy public="1" set="method" line="22"><f a=""><x path="Void"/></f></destroy>
		<addFrame public="1" set="method" line="16"><f a="frame">
	<c path="flixel.system.layer.frames.FlxFrame"/>
	<x path="Void"/>
</f></addFrame>
		<name public="1"><c path="String"/></name>
		<framesHash public="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.system.layer.frames.FlxFrame"/>
</x></framesHash>
		<frames public="1"><c path="Array"><c path="flixel.system.layer.frames.FlxFrame"/></c></frames>
		<new public="1" set="method" line="9"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.system.replay.CodeValuePair" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/replay/CodeValuePair.hx">
		<value public="1"><x path="Int"/></value>
		<code public="1"><x path="Int"/></code>
		<new public="1" set="method" line="12"><f a="?Code:?Value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.system.replay.FlxReplay" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/replay/FlxReplay.hx">
		<rewind public="1" set="method" line="234">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reset the replay back to the first frame.</haxe_doc>
		</rewind>
		<playNextFrame public="1" set="method" line="200">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Get the current frame record data and load it into the input managers.</haxe_doc>
		</playNextFrame>
		<recordFrame public="1" set="method" line="160">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Get the current input data from the input managers and store it in a new frame record.</haxe_doc>
		</recordFrame>
		<save public="1" set="method" line="142">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Save the current recording data off to a <code>String</code> object.
	 * Basically goes through and calls <code>FrameRecord.save()</code> on each frame in the replay.
	 * return	The gameplay recording in simple ASCII format.]]></haxe_doc>
		</save>
		<init set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Common initialization terms used by both <code>create()</code> and <code>load()</code> to set up the replay object.]]></haxe_doc>
		</init>
		<load public="1" set="method" line="98">
			<f a="FileContents">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Load replay data from a <code>String</code> object.
	 * Strings can come from embedded assets or external
	 * files loaded through the debugger overlay. 
	 * @param	FileContents	A <code>String</code> object containing a gameplay recording.]]></haxe_doc>
		</load>
		<create public="1" set="method" line="84">
			<f a="Seed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new gameplay recording.  Requires the current random number generator seed.
	 * 
	 * @param	Seed	The current seed from the random number generator.</haxe_doc>
		</create>
		<destroy public="1" set="method" line="65">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_marker>
			<x path="Int"/>
			<haxe_doc><![CDATA[* Internal helper variable for keeping track of where we are in <code>_frames</code> during recording or replay.]]></haxe_doc>
		</_marker>
		<_capacity>
			<x path="Int"/>
			<haxe_doc><![CDATA[* Internal tracker for max number of frames we can fit before growing the <code>_frames</code> again.]]></haxe_doc>
		</_capacity>
		<_frames>
			<c path="Array"><c path="flixel.system.replay.FrameRecord"/></c>
			<haxe_doc>* Internal container for all the frames in this replay.</haxe_doc>
		</_frames>
		<finished public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the replay has finished playing or not.</haxe_doc>
		</finished>
		<frameCount public="1">
			<x path="Int"/>
			<haxe_doc>* The number of frames in this recording.</haxe_doc>
		</frameCount>
		<frame public="1">
			<x path="Int"/>
			<haxe_doc>* The current frame for this recording.</haxe_doc>
		</frame>
		<seed public="1">
			<x path="Float"/>
			<haxe_doc>* The random number generator seed value for this recording.</haxe_doc>
		</seed>
		<new public="1" set="method" line="51">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate a new replay object.  Doesn't actually do much until you call create() or load().</haxe_doc>
		</new>
		<haxe_doc>* The replay object both records and replays game recordings,
 * as well as handle saving and loading replays to and from files.
 * Gameplay recordings are essentially a list of keyboard and mouse inputs,
 * but since Flixel is fairly deterministic, we can use these to play back
 * recordings of gameplay with a decent amount of fidelity.</haxe_doc>
	</class>
	<class path="flixel.system.replay.FrameRecord" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/replay/FrameRecord.hx">
		<load public="1" set="method" line="93">
			<f a="Data">
				<c path="String"/>
				<c path="flixel.system.replay.FrameRecord"/>
			</f>
			<haxe_doc><![CDATA[* Load the frame record data from array simple ASCII string.
	 * @param	Data	A <code>String</code> object containing the relevant frame record data.]]></haxe_doc>
		</load>
		<save public="1" set="method" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Save the frame record data to array simple ASCII string.
	 * @return	A <code>String</code> object containing the relevant frame record data.]]></haxe_doc>
		</save>
		<destroy public="1" set="method" line="50">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<create public="1" set="method" line="38">
			<f a="Frame:?Keys:?Mouse">
				<x path="Float"/>
				<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
				<c path="flixel.system.replay.MouseRecord"/>
				<c path="flixel.system.replay.FrameRecord"/>
			</f>
			<haxe_doc><![CDATA[* Load this frame record with input data from the input managers.
	 * @param Frame		What frame it is.
	 * @param Keys		Keyboard data from the keyboard manager.
	 * @param Mouse		Mouse data from the mouse manager.
	 * @return A reference to this <code>FrameRecord</code> object.]]></haxe_doc>
		</create>
		<mouse public="1">
			<c path="flixel.system.replay.MouseRecord"/>
			<haxe_doc>* A container for the 4 mouse state integers.</haxe_doc>
		</mouse>
		<keys public="1">
			<c path="Array"><c path="flixel.system.replay.CodeValuePair"/></c>
			<haxe_doc>* An array of simple integer pairs referring to what key is pressed, and what state its in.</haxe_doc>
		</keys>
		<frame public="1">
			<x path="Int"/>
			<haxe_doc>* Which frame of the game loop this record is from or for.</haxe_doc>
		</frame>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Instantiate array new frame record.</haxe_doc>
		</new>
		<haxe_doc>* Helper class for the new replay system.  Represents all the game inputs for one "frame" or "step" of the game loop.</haxe_doc>
	</class>
	<class path="flixel.system.replay.MouseRecord" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/replay/MouseRecord.hx">
		<wheel public="1">
			<x path="Int"/>
			<haxe_doc>* The state of the mouse wheel.</haxe_doc>
		</wheel>
		<button public="1">
			<x path="Int"/>
			<haxe_doc>* The state of the left mouse button.</haxe_doc>
		</button>
		<y public="1">
			<x path="Int"/>
			<haxe_doc>* The main Y value of the mouse in screen space.</haxe_doc>
		</y>
		<x public="1">
			<x path="Int"/>
			<haxe_doc>* The main X value of the mouse in screen space.</haxe_doc>
		</x>
		<new public="1" set="method" line="32">
			<f a="X:Y:Button:Wheel">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiate a new mouse input record.
	 * @param X			The main X value of the mouse in screen space.
	 * @param Y			The main Y value of the mouse in screen space.
	 * @param Button	The state of the left mouse button.
	 * @param Wheel		The state of the mouse wheel.</haxe_doc>
		</new>
		<haxe_doc>* A helper class for the frame records, part of the replay/demo/recording system.</haxe_doc>
	</class>
	<class path="flixel.system.ui.FlxFocusLostScreen" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/ui/FlxFocusLostScreen.hx">
		<extends path="flash.display.Sprite"/>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.system.ui.FlxSoundTray" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/system/ui/FlxSoundTray.hx">
		<extends path="flash.display.Sprite"/>
		<show public="1" set="method" line="121">
			<f a="?Silent">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes the little volume tray slide out.
	 * 
	 * @param	Silent	Whether or not it should beep.</haxe_doc>
		</show>
		<update public="1" set="method" line="92">
			<f a="MS">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This function just updates the soundtray object.</haxe_doc>
		</update>
		<_bars>
			<c path="Array"><c path="flash.display.Bitmap"/></c>
			<haxe_doc>* Helps display the volume bars on the sound tray.</haxe_doc>
		</_bars>
		<_timer>
			<x path="Float"/>
			<haxe_doc>* Helps us auto-hide the sound tray after a volume change.</haxe_doc>
		</_timer>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>* Because reading any data from DisplayObject is insanely expensive in hxcpp, keep track of whether we need to update it or not.</haxe_doc>
		</active>
		<new public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets up the "sound tray", the little volume meter that pops down sometimes.</haxe_doc>
		</new>
		<haxe_doc>* The flixel sound tray, the little volume meter that pops down sometimes.</haxe_doc>
	</class>
	<class path="flixel.text.pxText.PxBitmapFont" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/text/pxText/PxBitmapFont.hx">
		<_storedFonts line="21" static="1"><x path="Map">
	<c path="String"/>
	<c path="flixel.text.pxText.PxBitmapFont"/>
</x></_storedFonts>
		<ZERO_POINT line="23" static="1"><c path="flash.geom.Point"/></ZERO_POINT>
		<store public="1" set="method" line="699" static="1">
			<f a="PxHandle:PxFont">
				<c path="String"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Stores a font for global use using an identifier.
	 * 
	 * @param	PxHandle	String identifer for the font.
	 * @param	PxFont		Font to store.</haxe_doc>
		</store>
		<fetch public="1" set="method" line="710" static="1">
			<f a="PxHandle">
				<c path="String"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc>* Retrieves a font previously stored.
	 * 
	 * @param	PxHandle	Identifier of font to fetch.
	 * @return	Stored font, or null if no font was found.</haxe_doc>
		</fetch>
		<clearStorage public="1" set="method" line="717" static="1"><f a=""><x path="Void"/></f></clearStorage>
		<setCachedGraphics set="method" line="679"><f a="value">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Void"/>
</f></setCachedGraphics>
		<get_numLetters public="1" set="method" line="670"><f a=""><x path="Int"/></f></get_numLetters>
		<get_bgTileID set="method" line="664"><f a=""><x path="Int"/></f></get_bgTileID>
		<bgTileID public="1" get="accessor" set="null"><x path="Int"/></bgTileID>
		<get_pixels set="method" line="653"><f a=""><c path="flash.display.BitmapData"/></f></get_pixels>
		<pixels public="1" get="accessor" set="null"><c path="flash.display.BitmapData"/></pixels>
		<numLetters public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>* Returns number of letters available in this font.
	 * 
	 * @return Number of letters available in this font.</haxe_doc>
		</numLetters>
		<getFontHeight public="1" set="method" line="638">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns height of font in pixels.
	 * 
	 * @return Height of font in pixels.</haxe_doc>
		</getFontHeight>
		<getTextWidth public="1" set="method" line="596">
			<f a="PxText:?PxLetterSpacing:?PxFontScale">
				<c path="String"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the width of a certain test string.
	 * 
	 * @param	PxText	String to measure.
	 * @param	PxLetterSpacing	distance between letters
	 * @param	PxFontScale	"size" of the font
	 * @return	Width in pixels.</haxe_doc>
		</getTextWidth>
		<render public="1" set="method" line="522">
			<f a="DrawData:PxText:PxColor:PxSecondColor:PxAlpha:PxOffsetX:PxOffsetY:PxLetterSpacing:PxScale:?PxUseColor">
				<c path="Array"><x path="Float"/></c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Renders a string of text onto bitmap data using the font.
	 * 
	 * @param	PxBitmapData	Where to render the text.
	 * @param	PxText			Test to render.
	 * @param	PxColor			Color of text to render.
	 * @param	PxOffsetX		X position of thext output.
	 * @param	PxOffsetY		Y position of thext output.</haxe_doc>
		</render>
		<setGlyph set="method" line="491"><f a="Tiles:PxCharID:PxRect:?PxOffsetX:?PxOffsetY:?PxAdvanceX">
	<c path="flixel.system.layer.TileSheetData"/>
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setGlyph>
		<dispose public="1" set="method" line="422">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears all resources used by the font.</haxe_doc>
		</dispose>
		<prepareAngelCodeBitmapData public="1" set="method" line="312"><f a="PxBitmapData:PxXMLData:PxSymbols">
	<c path="flash.display.BitmapData"/>
	<c path="Xml"/>
	<c path="Array"><c path="flixel.text.pxText._PxBitmapFont.HelperSymbol"/></c>
	<c path="flash.display.BitmapData"/>
</f></prepareAngelCodeBitmapData>
		<preparePixelizerBitmapData public="1" set="method" line="248"><f a="PxBitmapData:PxRects">
	<c path="flash.display.BitmapData"/>
	<c path="Array"><c path="flash.geom.Rectangle"/></c>
	<c path="flash.display.BitmapData"/>
</f></preparePixelizerBitmapData>
		<reset set="method" line="231">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function. Resets current font.</haxe_doc>
		</reset>
		<updateGlyphData public="1" set="method" line="140">
			<f a="?Tiles">
				<c path="flixel.system.layer.TileSheetData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Updates and caches tile data for passed node object</haxe_doc>
		</updateGlyphData>
		<loadAngelCode public="1" set="method" line="116">
			<f a="pBitmapData:pXMLData">
				<c path="flash.display.BitmapData"/>
				<c path="Xml"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc><![CDATA[* Loads font data in AngelCode's format
	 * 
	 * @param	PxBitmapData	Font image source
	 * @param	PxXMLData		Font data in XML format
	 * @return	This <code>PxBitmapFont</code>]]></haxe_doc>
		</loadAngelCode>
		<loadPixelizer public="1" set="method" line="74">
			<f a="PxBitmapData:PxLetters">
				<c path="flash.display.BitmapData"/>
				<c path="String"/>
				<c path="flixel.text.pxText.PxBitmapFont"/>
			</f>
			<haxe_doc><![CDATA[* Loads font data in Pixelizer's format
	 * 
	 * @param	PxBitmapData	Font source image
	 * @param	PxLetters		All letters contained in this font
	 * @return	This <code>PxBitmapFont</code>]]></haxe_doc>
		</loadPixelizer>
		<_cachedGraphics><c path="flixel.util.loaders.CachedGraphics"/></_cachedGraphics>
		<_region><c path="flixel.system.layer.Region"/></_region>
		<_symbols><c path="Array"><c path="flixel.text.pxText._PxBitmapFont.HelperSymbol"/></c></_symbols>
		<_tileRects><c path="Array"><c path="flash.geom.Rectangle"/></c></_tileRects>
		<_point><c path="flash.geom.Point"/></_point>
		<_maxHeight><x path="Int"/></_maxHeight>
		<_glyphString><c path="String"/></_glyphString>
		<_bgTileID><x path="Int"/></_bgTileID>
		<_num_letters><x path="Int"/></_num_letters>
		<_glyphs><x path="Map">
	<x path="Int"/>
	<c path="flixel.text.pxText.PxFontSymbol"/>
</x></_glyphs>
		<new public="1" set="method" line="54">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new bitmap font using specified bitmap data and letter input.</haxe_doc>
		</new>
		<haxe_doc>* Holds information and bitmap glpyhs for a bitmap font.
 * @author Johan Peitz
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.text.pxText._PxBitmapFont.HelperSymbol" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/text/pxText/PxBitmapFont.hx" private="1" module="flixel.text.pxText.PxBitmapFont">
		<charCode public="1"><x path="Int"/></charCode>
		<xadvance public="1"><x path="Int"/></xadvance>
		<yoffset public="1"><x path="Int"/></yoffset>
		<xoffset public="1"><x path="Int"/></xoffset>
		<height public="1"><x path="Int"/></height>
		<width public="1"><x path="Int"/></width>
		<y public="1"><x path="Int"/></y>
		<x public="1"><x path="Int"/></x>
		<new public="1" set="method" line="739"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.text.pxText.PxFontSymbol" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/text/pxText/PxFontSymbol.hx">
		<tileID public="1">
			<x path="Int"/>
			<haxe_doc>* Tile id in tileSheet</haxe_doc>
		</tileID>
		<xadvance public="1">
			<x path="Int"/>
			<haxe_doc>* Real width of symbol</haxe_doc>
		</xadvance>
		<yoffset public="1">
			<x path="Int"/>
			<haxe_doc>* Y offset to draw symbol with</haxe_doc>
		</yoffset>
		<xoffset public="1">
			<x path="Int"/>
			<haxe_doc>* X offset to draw symbol with</haxe_doc>
		</xoffset>
		<new public="1" set="method" line="26"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTile" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tile/FlxTile.hx">
		<extends path="flixel.FlxObject"/>
		<destroy public="1" set="method" line="69" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<mapIndex public="1">
			<x path="Int"/>
			<haxe_doc>* The current map index of this tile object at this moment.
	 * You can think of tile objects as moving around the tilemap helping with collisions.
	 * This value is only reliable and useful if used from the callback function.</haxe_doc>
		</mapIndex>
		<index public="1">
			<x path="Int"/>
			<haxe_doc>* The index of this tile type in the core map data.
	 * For example, if your map only has 16 kinds of tiles in it,
	 * this number is usually between 0 and 15.</haxe_doc>
		</index>
		<tilemap public="1">
			<c path="flixel.tile.FlxTilemap"/>
			<haxe_doc>* A reference to the tilemap this tile object belongs to.</haxe_doc>
		</tilemap>
		<filter public="1">
			<x path="Class"><d/></x>
			<haxe_doc><![CDATA[* Each tile can store its own filter class for their callback functions.
	 * That is, the callback will only be triggered if an object with a class
	 * type matching the filter touched it.
	 * Defaults to null, set through <code>FlxTilemap.setTileProperties()</code>.]]></haxe_doc>
		</filter>
		<callbackFunction public="1">
			<f a=":">
				<c path="flixel.FlxObject"/>
				<c path="flixel.FlxObject"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function is called whenever an object hits a tile of this type.
	 * This function should take the form <code>myFunction(Tile:FlxTile,Object:FlxObject):void</code>.
	 * Defaults to null, set through <code>FlxTilemap.setTileProperties()</code>.]]></haxe_doc>
		</callbackFunction>
		<new public="1" set="method" line="52">
			<f a="Tilemap:Index:Width:Height:Visible:AllowCollisions">
				<c path="flixel.tile.FlxTilemap"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Instantiate this new tile object.  This is usually called from <code>FlxTilemap.loadMap()</code>.
	 * 
	 * @param 	Tilemap			A reference to the tilemap object creating the tile.
	 * @param 	Index			The actual core map data index for this tile type.
	 * @param 	Width			The width of the tile.
	 * @param 	Height			The height of the tile.
	 * @param 	Visible			Whether the tile is visible or not.
	 * @param 	AllowCollisions	The collision flags for the object.  By default this value is ANY or NONE depending on the parameters sent to loadMap().]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A simple helper object for <code>FlxTilemap</code> that helps expand collision opportunities and control.
 * You can use <code>FlxTilemap.setTileProperties()</code> to alter the collision properties and
 * callback functions and filters for this object to do things like one-way tiles or whatever.]]></haxe_doc>
	</class>
	<class path="flixel.tile.FlxTileblock" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tile/FlxTileblock.hx">
		<extends path="flixel.FlxSprite"/>
		<loadTiles public="1" set="method" line="42">
			<f a="TileGraphic:?TileWidth:?TileHeight:?Empties">
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxTileblock"/>
			</f>
			<haxe_doc>* Fills the block with a randomly arranged selection of graphics from the image provided.
	 * 
	 * @param	TileGraphic 	The graphic class that contains the tiles that should fill this block.
	 * @param	TileWidth		The width of a single tile in the graphic.
	 * @param	TileHeight		The height of a single tile in the graphic.
	 * @param	Empties			The number of "empty" tiles to add to the auto-fill algorithm (e.g. 8 tiles + 4 empties = 1/3 of block will be open holes).</haxe_doc>
		</loadTiles>
		<new public="1" set="method" line="25">
			<f a="X:Y:Width:Height">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Creates a new <code>FlxBlock</code> object with the specified position and size.
	 * 
	 * @param	X			The X position of the block.
	 * @param	Y			The Y position of the block.
	 * @param	Width		The width of the block.
	 * @param	Height		The height of the block.]]></haxe_doc>
		</new>
		<haxe_doc>* This is a basic "environment object" class, used to create simple walls and floors.
 * It can be filled with a random selection of tiles to quickly add detail.</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTilemap" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tile/FlxTilemap.hx">
		<extends path="flixel.FlxObject"/>
		<imgAuto public="1" get="inline" set="null" line="36" static="1">
			<c path="String"/>
			<haxe_doc>* A set of generic tiles you can use. Useful for protyping.</haxe_doc>
		</imgAuto>
		<imgAutoAlt public="1" get="inline" set="null" line="40" static="1">
			<c path="String"/>
			<haxe_doc>* An alternate set of generic tiles you can use. Useful for protyping.</haxe_doc>
		</imgAutoAlt>
		<OFF public="1" get="inline" set="null" line="45" static="1">
			<x path="Int"/>
			<haxe_doc>* No auto-tiling.</haxe_doc>
		</OFF>
		<AUTO public="1" get="inline" set="null" line="49" static="1">
			<x path="Int"/>
			<haxe_doc>* Good for levels with thin walls that don'tile need interior corner art.</haxe_doc>
		</AUTO>
		<ALT public="1" get="inline" set="null" line="53" static="1">
			<x path="Int"/>
			<haxe_doc>* Better for levels with thick walls that look better with interior corner art.</haxe_doc>
		</ALT>
		<arrayToCSV public="1" set="method" line="2008" static="1">
			<f a="Data:Width:?Invert">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts a one-dimensional array of tile data to a comma-separated string.
	 * 
	 * @param	Data		An array full of integer tile references.
	 * @param	Width		The number of tiles in each row.
	 * @param	Invert		Recommended only for 1-bit arrays - changes 0s to 1s and vice versa.
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.]]></haxe_doc>
		</arrayToCSV>
		<bitmapToCSV public="1" set="method" line="2075" static="1">
			<f a="Bitmap:?Invert:?Scale:?ColorMap">
				<c path="flash.display.BitmapData"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts a <code>BitmapData</code> object to a comma-separated string.
	 * Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding.
	 * Black pixels must be PURE BLACK.
	 * 
	 * @param	Bitmap		A Flash <code>BitmapData</code> object, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @param  	ColorMap  	An array of color values (uint 0xAARRGGBB) in the order they're intended to be assigned as indices
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.]]></haxe_doc>
		</bitmapToCSV>
		<imageToCSV public="1" set="method" line="2182" static="1">
			<f a="ImageFile:?Invert:?Scale">
				<d/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Converts a resource image file to a comma-separated string.
	 * Black pixels are flagged as 'solid' by default,
	 * non-black pixels are set as non-colliding.
	 * Black pixels must be PURE BLACK.
	 * 
	 * @param	ImageFile	An embedded graphic, preferably black and white.
	 * @param	Invert		Load white pixels as solid instead.
	 * @param	Scale		Default is 1.  Scale of 2 means each pixel forms a 2x2 block of tiles, and so on.
	 * @return	A comma-separated string containing the level data in a <code>FlxTilemap</code>-friendly format.]]></haxe_doc>
		</imageToCSV>
		<set_forceComplexRender set="method" line="2405" override="1"><f a="Value">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_forceComplexRender>
		<updateBuffers public="1" set="method" line="2384">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method so the tilemap buffers are updated, eg when resizing your game</haxe_doc>
		</updateBuffers>
		<tileToFlxSprite public="1" set="method" line="2327">
			<f a="X:Y:?NewTile">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc>* Change a particular tile to FlxSprite. Or just copy the graphic if you dont want any changes to mapdata itself.
	 * 
	 * @link http://forums.flixel.org/index.php/topic,5398.0.html
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @param	NewTile	New tile to the mapdata. Use -1 if you dont want any changes. Default = 0 (empty)
	 * @return	FlxSprite.</haxe_doc>
		</tileToFlxSprite>
		<updateFrameData public="1" set="method" line="2300" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method for creating tileSheet for FlxTilemap. Must be called after loadMap() method.
	 * If you forget to call it then you will not see this FlxTilemap on c++ target</haxe_doc>
		</updateFrameData>
		<updateTile set="method" line="2266">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Internal function used in setTileByIndex() and the constructor to update the map.
	 * 
	 * @param	Index		The index of the tile you want to update.</haxe_doc>
		</updateTile>
		<autoTile set="method" line="2203">
			<f a="Index">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* An internal function used by the binary auto-tilers.
	 * 
	 * @param	Index		The index of the tile you want to analyze.</haxe_doc>
		</autoTile>
		<rayHit public="1" set="method" line="1897">
			<f a="Start:End:?Resolution">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Works exactly like ray() except it explicitly returns the hit result.
	* Shoots a ray from the start point to the end point.
	* If/when it passes through a tile, it returns that point.
	* If it does not, it returns null.
	* Usage:
	* var hit:FlxPoint = tilemap.rayHit(startPoint, endPoint);
	* if (hit != null) //code ;
	*
	* @param 	Start		The world coordinates of the start of the ray.
	* @param 	End 		The world coordinates of the end of the ray.
	* @param 	Resolution 	Defaults to 1, meaning check every tile or so. Higher means more checks!
	* @return Returns null if the ray made it from Start to End without hitting anything. Returns FlxPoint if a tile was hit.</haxe_doc>
		</rayHit>
		<ray public="1" set="method" line="1783">
			<f a="Start:End:?Result:?Resolution">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Shoots a ray from the start point to the end point.
	 * If/when it passes through a tile, it stores that point and returns false.
	 * 
	 * @param	Start		The world coordinates of the start of the ray.
	 * @param	End			The world coordinates of the end of the ray.
	 * @param	Result		A <code>Point</code> object containing the first wall impact.
	 * @param	Resolution	Defaults to 1, meaning check every tile or so.  Higher means more checks!
	 * @return	Returns true if the ray made it from Start to End without hitting anything.  Returns false and fills Result if a tile was hit.]]></haxe_doc>
		</ray>
		<getBounds public="1" set="method" line="1763">
			<f a="?Bounds">
				<c path="flixel.util.FlxRect"/>
				<c path="flixel.util.FlxRect"/>
			</f>
			<haxe_doc><![CDATA[* Get the world coordinates and size of the entire tilemap as a <code>FlxRect</code>.
	 * 
	 * @param	Bounds		Optional, pass in a pre-existing <code>FlxRect</code> to prevent instantiation of a new object.
	 * @return	A <code>FlxRect</code> containing the world coordinates and size of the entire tilemap.]]></haxe_doc>
		</getBounds>
		<follow public="1" set="method" line="1747">
			<f a="?Camera:?Border:?UpdateWorld">
				<c path="flixel.FlxCamera"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Call this function to lock the automatic camera to the map's edges.
	 * 
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @param	Border			Adjusts the camera follow boundary by whatever number of tiles you specify here.  Handy for blocking off deadends that are offscreen, etc.  Use a negative number to add padding instead of hiding the edges.
	 * @param	UpdateWorld		Whether to update the collision system's world size, default value is true.</haxe_doc>
		</follow>
		<setTileProperties public="1" set="method" line="1720">
			<f a="Tile:?AllowCollisions:?Callback:?CallbackFilter:?Range">
				<x path="Int"/>
				<x path="Int"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Void"/>
				</f>
				<x path="Class"><d/></x>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Adjust collision settings and/or bind a callback function to a range of tiles.
	 * This callback function, if present, is triggered by calls to overlap() or overlapsWithCallback().
	 * 
	 * @param	Tile				The tile or tiles you want to adjust.
	 * @param	AllowCollisions		Modify the tile or tiles to only allow collisions from certain directions, use FlxObject constants NONE, ANY, LEFT, RIGHT, etc.  Default is "ANY".
	 * @param	Callback			The function to trigger, e.g. <code>lavaCallback(Tile:FlxTile, Object:FlxObject)</code>.
	 * @param	CallbackFilter		If you only want the callback to go off for certain classes or objects based on a certain class, set that class here.
	 * @param	Range				If you want this callback to work for a bunch of different tiles, input the range here.  Default value is 1.]]></haxe_doc>
		</setTileProperties>
		<setTileByIndex public="1" set="method" line="1659">
			<f a="Index:Tile:?UpdateGraphics">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * 
	 * @param	Index			The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTileByIndex>
		<setTile public="1" set="method" line="1641">
			<f a="X:Y:Tile:?UpdateGraphics">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Change the data and graphic of a tile in the tilemap.
	 * 
	 * @param	X				The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y				The Y coordinate of the tile (in tiles, not pixels).
	 * @param	Tile			The new integer data you wish to inject.
	 * @param	UpdateGraphics	Whether the graphical representation of this tile should change.
	 * @return	Whether or not the tile was actually changed.</haxe_doc>
		</setTile>
		<getTileCoords public="1" set="method" line="1599">
			<f a="Index:?Midpoint">
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc><![CDATA[* Returns a new Flash <code>Array</code> full of every coordinate of the requested tile type.
	 * 
	 * @param	Index		The requested tile type.
	 * @param	Midpoint	Whether to return the coordinates of the tile midpoint, or upper left corner. Default is true, return midpoint.
	 * @return	An <code>Array</code> with a list of all the coordinates of that tile type.]]></haxe_doc>
		</getTileCoords>
		<getTileInstances public="1" set="method" line="1569">
			<f a="Index">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc><![CDATA[* Returns a new Flash <code>Array</code> full of every map index of the requested tile type.
	 * 
	 * @param	Index	The requested tile type.
	 * @return	An <code>Array</code> with a list of all map indices of that tile type.]]></haxe_doc>
		</getTileInstances>
		<getTileCollisions public="1" set="method" line="1558">
			<f a="Index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Gets the collision flags of tile by index.
	 * 
	 * @param	Index	Tile index returned by getTile or getTileByIndex
	 * @return	The internal collision flag for the requested tile.</haxe_doc>
		</getTileCollisions>
		<getTileByIndex public="1" set="method" line="1547">
			<f a="Index">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get the value of a tile in the tilemap by index.
	 * 
	 * @param	Index	The slot in the data array (Y * widthInTiles + X) where this tile is stored.
	 * @return	A uint containing the value of the tile at this spot in the array.</haxe_doc>
		</getTileByIndex>
		<getTile public="1" set="method" line="1536">
			<f a="X:Y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Check the value of a particular tile.
	 * 
	 * @param	X		The X coordinate of the tile (in tiles, not pixels).
	 * @param	Y		The Y coordinate of the tile (in tiles, not pixels).
	 * @return	A uint containing the value of the tile at this spot in the array.</haxe_doc>
		</getTile>
		<overlapsPoint public="1" set="method" line="1510" override="1">
			<f a="WorldPoint:?InScreenSpace:?Camera">
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if a point in 2D world space overlaps this <code>FlxObject</code> object.
	 * 
	 * @param	WorldPoint		The point in world space you want to check.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the point overlaps this object.]]></haxe_doc>
		</overlapsPoint>
		<overlapsWithCallback public="1" set="method" line="1396">
			<f a="Object:?Callback:?FlipCallbackParams:?Position">
				<c path="flixel.FlxObject"/>
				<f a=":">
					<c path="flixel.FlxObject"/>
					<c path="flixel.FlxObject"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks if the Object overlaps any tiles with any collision flags set,
	 * and calls the specified callback function (if there is one).
	 * Also calls the tile's registered callback if the filter matches.
	 * 
	 * @param	Object				The <code>FlxObject</code> you are checking for overlaps against.
	 * @param	Callback			An optional function that takes the form "myCallback(Object1:FlxObject,Object2:FlxObject)", where Object1 is a FlxTile object, and Object2 is the object passed in in the first parameter of this method.
	 * @param	FlipCallbackParams	Used to preserve A-B list ordering from FlxObject.separate() - returns the FlxTile object as the second parameter instead.
	 * @param	Position			Optional, specify a custom position for the tilemap (useful for overlapsAt()-type funcitonality).
	 * @return	Whether there were overlaps, or if a callback was specified, whatever the return value of the callback was.]]></haxe_doc>
		</overlapsWithCallback>
		<overlapsAt public="1" set="method" line="1336" override="1">
			<f a="X:Y:ObjectOrGroup:?InScreenSpace:?Camera">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if this <code>FlxObject</code> were located at the given position, would it overlap the <code>FlxObject</code> or <code>FlxGroup</code>?
	 * This is distinct from overlapsPoint(), which just checks that point, rather than taking the object's size into account.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks! 
	 * 
	 * @param	X				The X position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	Y				The Y position you want to check.  Pretends this object (the caller, not the parameter) is located here.
	 * @param	ObjectOrGroup	The object or group being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.  Default is false, or "only compare in world space."
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlapsAt>
		<overlaps public="1" set="method" line="1281" override="1">
			<f a="ObjectOrGroup:?InScreenSpace:?Camera">
				<c path="flixel.FlxBasic"/>
				<x path="Bool"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* Checks to see if some <code>FlxObject</code> overlaps this <code>FlxObject</code> object in world space.
	 * If the group has a LOT of things in it, it might be faster to use <code>FlxG.overlaps()</code>.
	 * WARNING: Currently tilemaps do NOT support screen space overlap checks!
	 * 
	 * @param	Object			The object being tested.
	 * @param	InScreenSpace	Whether to take scroll factors into account when checking for overlap.
	 * @param	Camera			Specify which game camera you want.  If null getScreenXY() will just grab the first global camera.
	 * @return	Whether or not the two objects overlap.]]></haxe_doc>
		</overlaps>
		<walkPath set="method" line="1177">
			<f a="Data:Start:Points">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, recursively walks the grid and finds a shortest path back to the start.
	 * 
	 * @param	Data	A Flash <code>Array</code> of distance information.
	 * @param	Start	The tile we're on in our walk backward.
	 * @param	Points	A Flash <code>Array</code> of <code>FlxPoint</code> nodes composing the path from the start to the end, compiled in reverse order.]]></haxe_doc>
		</walkPath>
		<computePathDistance set="method" line="997">
			<f a="StartIndex:EndIndex:WideDiagonal">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, floods a grid with distance information until it finds the end point.
	 * NOTE: Currently this process does NOT use any kind of fancy heuristic! It's pretty brute.
	 * 
	 * @param	StartIndex	The starting tile's map index.
	 * @param	EndIndex	The ending tile's map index.
	 * @param   WideDiagonal Whether to require an additional tile to make diagonal movement. Default value is true.
	 * @return	A Flash <code>Array</code> of <code>FlxPoint</code> nodes.  If the end tile could not be found, then a null <code>Array</code> is returned instead.]]></haxe_doc>
		</computePathDistance>
		<raySimplifyPath set="method" line="955">
			<f a="Points">
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, strips out even more points by raycasting from one point to the next and dropping unnecessary points.
	 * 
	 * @param	Points		An array of <code>FlxPoint</code> nodes.]]></haxe_doc>
		</raySimplifyPath>
		<simplifyPath set="method" line="922">
			<f a="Points">
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Pathfinding helper function, strips out extra points on the same line.
	 * 
	 * @param	Points		An array of <code>FlxPoint</code> nodes.]]></haxe_doc>
		</simplifyPath>
		<findPath public="1" set="method" line="857">
			<f a="Start:End:?Simplify:?RaySimplify:?WideDiagonal">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="Array"><c path="flixel.util.FlxPoint"/></c>
			</f>
			<haxe_doc>* Find a path through the tilemap.  Any tile with any collision flags set is treated as impassable.
	 * If no path is discovered then a null reference is returned.
	 * 
	 * @param	Start		The start point in world coordinates.
	 * @param	End			The end point in world coordinates.
	 * @param	Simplify	Whether to run a basic simplification algorithm over the path data, removing extra points that are on the same line.  Default value is true.
	 * @param	RaySimplify	Whether to run an extra raycasting simplification algorithm over the remaining path data.  This can result in some close corners being cut, and should be used with care if at all (yet).  Default value is false.
	 * @param   WideDiagonal   Whether to require an additional tile to make diagonal movement. Default value is true;
	 * @return	An Array of FlxPoints, containing all waypoints from the start to the end.  If no path could be found, then a null reference is returned.</haxe_doc>
		</findPath>
		<setDirty public="1" set="method" line="835">
			<f a="?Dirty">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set the dirty flag on all the tilemap buffers.
	 * Basically forces a reset of the drawn tilemaps, even if it wasn'tile necessary.
	 * 
	 * @param	Dirty		Whether to flag the tilemap buffers as dirty or not.</haxe_doc>
		</setDirty>
		<getData public="1" set="method" line="808">
			<f a="?Simple">
				<x path="Bool"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Fetches the tilemap data array.
	 * 
	 * @param	Simple		If true, returns the data as copy, as a series of 1s and 0s (useful for auto-tiling stuff). Default value is false, meaning it will return the actual data array (NOT a copy).
	 * @return	An array the size of the tilemap full of integers indicating tile placement.</haxe_doc>
		</getData>
		<draw public="1" set="method" line="743" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Draws the tilemap buffers to the cameras.</haxe_doc>
		</draw>
		<drawDebugOnCamera public="1" set="method" line="622" override="1"><f a="?Camera">
	<c path="flixel.FlxCamera"/>
	<x path="Void"/>
</f></drawDebugOnCamera>
		<drawTilemap set="method" line="468">
			<f a="Buffer:Camera">
				<c path="flixel.tile.FlxTilemapBuffer"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Internal function that actually renders the tilemap to the tilemap buffer.  Called by draw().
	 * @param	Buffer		The <code>FlxTilemapBuffer</code> you are rendering to.
	 * @param	Camera		The related <code>FlxCamera</code>, mainly for scroll values.]]></haxe_doc>
		</drawTilemap>
		<update public="1" set="method" line="451" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Internal function to clean up the map loading code.
	 * Just generates a wireframe box the size of a tile with the specified color.</haxe_doc>
		</update>
		<loadMap public="1" set="method" line="266">
			<f a="MapData:TileGraphic:?TileWidth:?TileHeight:?AutoTile:?StartingIndex:?DrawIndex:?CollideIndex">
				<d/>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.tile.FlxTilemap"/>
			</f>
			<haxe_doc><![CDATA[* Load the tilemap with string data and a tile graphic.
	 * 
	 * @param	MapData      	A string of comma and line-return delineated indices indicating what order the tiles should go in, or an <code>Array of Int</code>. YOU MUST SET <code>widthInTiles</code> and <code>heightInTyles</code> manually BEFORE CALLING <code>loadMap</code> if you pass an Array!
	 * @param	TileGraphic		All the tiles you want to use, arranged in a strip corresponding to the numbers in MapData.
	 * @param	TileWidth		The width of your tiles (e.g. 8) - defaults to height of the tile graphic if unspecified.
	 * @param	TileHeight		The height of your tiles (e.g. 8) - defaults to width if unspecified.
	 * @param	AutoTile		Whether to load the map using an automatic tile placement algorithm.  Setting this to either AUTO or ALT will override any values you put for StartingIndex, DrawIndex, or CollideIndex.
	 * @param	StartingIndex	Used to sort of insert empty tiles in front of the provided graphic.  Default is 0, usually safest ot leave it at that.  Ignored if AutoTile is set.
	 * @param	DrawIndex		Initializes all tile objects equal to and after this index as visible. Default value is 1.  Ignored if AutoTile is set.
	 * @param	CollideIndex	Initializes all tile objects equal to and after this index as allowCollisions = ANY.  Default value is 1.  Ignored if AutoTile is set.  Can override and customize per-tile-type collision behavior using <code>setTileProperties()</code>.	
	 * @return	A pointer this instance of FlxTilemap, for chaining as usual :)]]></haxe_doc>
		</loadMap>
		<destroy public="1" set="method" line="203" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<_rectIDs>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Internal representation of rectangles (actually id of rectangle in tileSheet), one for each tile in the entire tilemap, used to speed up drawing.</haxe_doc>
		</_rectIDs>
		<_helperPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods. Used only in cpp</haxe_doc>
		</_helperPoint>
		<_startingIndex>
			<x path="Int"/>
			<haxe_doc>* Internal, used to sort of insert blank tiles in front of the tiles in the provided graphic.</haxe_doc>
		</_startingIndex>
		<_lastVisualDebug>
			<x path="Bool"/>
			<haxe_doc>* Internal flag for checking to see if we need to refresh
	 * the tilemap display to show or hide the bounding boxes.</haxe_doc>
		</_lastVisualDebug>
		<_tileObjects>
			<c path="Array"><c path="flixel.tile.FlxTile"/></c>
			<haxe_doc>* Internal collection of tile objects, one for each type of tile in the map (NOTE one for every single tile in the whole map).</haxe_doc>
		</_tileObjects>
		<_tileHeight>
			<x path="Int"/>
			<haxe_doc>* Internal, the height of a single tile.</haxe_doc>
		</_tileHeight>
		<_tileWidth>
			<x path="Int"/>
			<haxe_doc>* Internal representation of rectangles, one for each tile in the entire tilemap, used to speed up drawing.</haxe_doc>
		</_tileWidth>
		<_data>
			<c path="Array"><x path="Int"/></c>
			<haxe_doc>* Internal representation of the actual tile data, as a large 1D array of integers.</haxe_doc>
		</_data>
		<_buffers>
			<c path="Array"><c path="flixel.tile.FlxTilemapBuffer"/></c>
			<haxe_doc>* Internal list of buffers, one for each camera, used for drawing the tilemaps.</haxe_doc>
		</_buffers>
		<_flashRect>
			<c path="flash.geom.Rectangle"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashRect>
		<_flashPoint>
			<c path="flash.geom.Point"/>
			<haxe_doc>* Rendering helper, minimize new object instantiation on repetitive methods.</haxe_doc>
		</_flashPoint>
		<tileScaleHack public="1">
			<x path="Float"/>
			<haxe_doc>* Helper variable for non-flash targets. Adjust it's value if you'll see tilemap tearing (empty pixels between tiles). To something like 1.02 or 1.03</haxe_doc>
		</tileScaleHack>
		<totalTiles public="1">
			<x path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</totalTiles>
		<heightInTiles public="1">
			<x path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</heightInTiles>
		<widthInTiles public="1">
			<x path="Int"/>
			<haxe_doc>* Read-only variable, do NOT recommend changing after the map is loaded!</haxe_doc>
		</widthInTiles>
		<auto public="1">
			<x path="Int"/>
			<haxe_doc>* Set this flag to use one of the 16-tile binary auto-tile algorithms (OFF, AUTO, or ALT).</haxe_doc>
		</auto>
		<new public="1" set="method" line="157">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* The tilemap constructor just initializes some basic variables.</haxe_doc>
		</new>
		<haxe_doc>* This is a traditional tilemap display and collision class.
 * It takes a string of comma-separated numbers and then associates
 * those values with tiles from the sheet you pass in.
 * It also includes some handy static parsers that can convert
 * arrays or images into strings that can be loaded.</haxe_doc>
	</class>
	<class path="flixel.tile.FlxTilemapBuffer" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tile/FlxTilemapBuffer.hx">
		<destroy public="1" set="method" line="109">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clean up memory.</haxe_doc>
		</destroy>
		<forceComplexRender public="1"><x path="Bool"/></forceComplexRender>
		<columns public="1">
			<x path="Int"/>
			<haxe_doc>* How many columns of tiles fit in this buffer.</haxe_doc>
		</columns>
		<rows public="1">
			<x path="Int"/>
			<haxe_doc>* How many rows of tiles fit in this buffer.</haxe_doc>
		</rows>
		<dirty public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the buffer needs to be redrawn.</haxe_doc>
		</dirty>
		<height public="1">
			<x path="Float"/>
			<haxe_doc>* The height of the buffer (usually just a few tiles taller than the camera).</haxe_doc>
		</height>
		<width public="1">
			<x path="Float"/>
			<haxe_doc>* The width of the buffer (usually just a few tiles wider than the camera).</haxe_doc>
		</width>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The current Y position of the buffer.</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The current X position of the buffer.</haxe_doc>
		</x>
		<new public="1" set="method" line="62">
			<f a="TileWidth:TileHeight:WidthInTiles:HeightInTiles:?Camera">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Instantiates a new camera-specific buffer for storing the visual tilemap data.
	 * 
	 * @param TileWidth		The width of the tiles in this tilemap.
	 * @param TileHeight	The height of the tiles in this tilemap.
	 * @param WidthInTiles	How many tiles wide the tilemap is.
	 * @param HeightInTiles	How many tiles tall the tilemap is.
	 * @param Camera		Which camera this buffer relates to.</haxe_doc>
		</new>
		<haxe_doc>* A helper object to keep tilemap drawing performance decent across the new multi-camera system.
 * Pretty much don't even have to think about this class unless you are doing some crazy hacking.</haxe_doc>
	</class>
	<class path="flixel.tweens.FlxEase" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/FlxEase.hx">
		<quadIn public="1" set="method" line="9" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quadratic in.</haxe_doc>
		</quadIn>
		<quadOut public="1" set="method" line="15" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quadratic out.</haxe_doc>
		</quadOut>
		<quadInOut public="1" set="method" line="21" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quadratic in and out.</haxe_doc>
		</quadInOut>
		<cubeIn public="1" set="method" line="27" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Cubic in.</haxe_doc>
		</cubeIn>
		<cubeOut public="1" set="method" line="33" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Cubic out.</haxe_doc>
		</cubeOut>
		<cubeInOut public="1" set="method" line="39" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Cubic in and out.</haxe_doc>
		</cubeInOut>
		<quartIn public="1" set="method" line="45" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quart in.</haxe_doc>
		</quartIn>
		<quartOut public="1" set="method" line="51" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quart out.</haxe_doc>
		</quartOut>
		<quartInOut public="1" set="method" line="57" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quart in and out.</haxe_doc>
		</quartInOut>
		<quintIn public="1" set="method" line="63" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quint in.</haxe_doc>
		</quintIn>
		<quintOut public="1" set="method" line="69" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quint out.</haxe_doc>
		</quintOut>
		<quintInOut public="1" set="method" line="75" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Quint in and out.</haxe_doc>
		</quintInOut>
		<sineIn public="1" set="method" line="81" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sine in.</haxe_doc>
		</sineIn>
		<sineOut public="1" set="method" line="87" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sine out.</haxe_doc>
		</sineOut>
		<sineInOut public="1" set="method" line="93" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sine in and out.</haxe_doc>
		</sineInOut>
		<bounceIn public="1" set="method" line="99" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Bounce in.</haxe_doc>
		</bounceIn>
		<bounceOut public="1" set="method" line="109" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Bounce out.</haxe_doc>
		</bounceOut>
		<bounceInOut public="1" set="method" line="118" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Bounce in and out.</haxe_doc>
		</bounceInOut>
		<circIn public="1" set="method" line="136" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Circle in.</haxe_doc>
		</circIn>
		<circOut public="1" set="method" line="142" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Circle out.</haxe_doc>
		</circOut>
		<circInOut public="1" set="method" line="148" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Circle in and out.</haxe_doc>
		</circInOut>
		<expoIn public="1" set="method" line="154" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Exponential in.</haxe_doc>
		</expoIn>
		<expoOut public="1" set="method" line="160" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Exponential out.</haxe_doc>
		</expoOut>
		<expoInOut public="1" set="method" line="166" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Exponential in and out.</haxe_doc>
		</expoInOut>
		<backIn public="1" set="method" line="172" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back in.</haxe_doc>
		</backIn>
		<backOut public="1" set="method" line="178" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back out.</haxe_doc>
		</backOut>
		<backInOut public="1" set="method" line="184" static="1">
			<f a="t">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Back in and out.</haxe_doc>
		</backInOut>
		<PI line="193" static="1"><x path="Float"/></PI>
		<PI2 line="194" static="1"><x path="Float"/></PI2>
		<EL line="195" static="1"><x path="Float"/></EL>
		<B1 line="196" static="1"><x path="Float"/></B1>
		<B2 line="197" static="1"><x path="Float"/></B2>
		<B3 line="198" static="1"><x path="Float"/></B3>
		<B4 line="199" static="1"><x path="Float"/></B4>
		<B5 line="200" static="1"><x path="Float"/></B5>
		<B6 line="201" static="1"><x path="Float"/></B6>
		<haxe_doc>* Static class with useful easer functions that can be used by Tweens.</haxe_doc>
	</class>
	<typedef path="flixel.tweens.EaseFunction" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/FlxEase.hx" module="flixel.tweens.FlxEase"><f a="">
	<x path="Float"/>
	<x path="Float"/>
</f></typedef>
	<typedef path="flixel.tweens.CompleteCallback" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween"><f a="">
	<c path="flixel.tweens.FlxTween"/>
	<x path="Void"/>
</f></typedef>
	<typedef path="flixel.tweens.TweenOptions" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/FlxTween.hx" module="flixel.tweens.FlxTween"><a>
	<type>
		<t path="Null"><x path="Int"/></t>
		<meta><m n=":optional"/></meta>
	</type>
	<ease>
		<t path="Null"><t path="flixel.tweens.EaseFunction"/></t>
		<meta><m n=":optional"/></meta>
	</ease>
	<complete>
		<t path="Null"><t path="flixel.tweens.CompleteCallback"/></t>
		<meta><m n=":optional"/></meta>
	</complete>
</a></typedef>
	<class path="flixel.tweens.misc.AngleTween" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/misc/AngleTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_range><x path="Float"/></_range>
		<_start><x path="Float"/></_start>
		<update public="1" set="method" line="59" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<tween public="1" set="method" line="35">
			<f a="fromAngle:toAngle:duration:?ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.misc.AngleTween"/>
			</f>
			<haxe_doc>* Tweens the value from one angle to another.
	 * @param	fromAngle		Start angle.
	 * @param	toAngle			End angle.
	 * @param	duration		Duration of the tween.
	 * @param	ease			Optional easer function.</haxe_doc>
		</tween>
		<angle public="1">
			<x path="Float"/>
			<haxe_doc>* The current value.</haxe_doc>
		</angle>
		<new public="1" set="method" line="22">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Tweens from one angle to another.</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.ColorTween" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/misc/ColorTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_rangeB><x path="Float"/></_rangeB>
		<_rangeG><x path="Float"/></_rangeG>
		<_rangeR><x path="Float"/></_rangeR>
		<_rangeA><x path="Float"/></_rangeA>
		<_startB><x path="Float"/></_startB>
		<_startG><x path="Float"/></_startG>
		<_startR><x path="Float"/></_startR>
		<_startA><x path="Float"/></_startA>
		<blue public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Blue value of the current color, from 0 to 255.</haxe_doc>
		</blue>
		<green public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Green value of the current color, from 0 to 255.</haxe_doc>
		</green>
		<red public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* Red value of the current color, from 0 to 255.</haxe_doc>
		</red>
		<update public="1" set="method" line="65" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<tween public="1" set="method" line="42">
			<f a="duration:fromColor:toColor:?fromAlpha:?toAlpha:?ease">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.misc.ColorTween"/>
			</f>
			<haxe_doc>* Tweens the color to a new color and an alpha to a new alpha.
	 * @param	duration		Duration of the tween.
	 * @param	fromColor		Start color.
	 * @param	toColor			End color.
	 * @param	fromAlpha		Start alpha
	 * @param	toAlpha			End alpha.
	 * @param	ease			Optional easer function.</haxe_doc>
		</tween>
		<alpha public="1">
			<x path="Float"/>
			<haxe_doc>* The current alpha.</haxe_doc>
		</alpha>
		<color public="1">
			<x path="Int"/>
			<haxe_doc>* The current color.</haxe_doc>
		</color>
		<new public="1" set="method" line="27">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Tweens a color's red, green, and blue properties
 * independently. Can also tween an alpha value.</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.MultiVarTween" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/misc/MultiVarTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_range><c path="Array"><x path="Float"/></c></_range>
		<_start><c path="Array"><x path="Float"/></c></_start>
		<_vars><c path="Array"><c path="String"/></c></_vars>
		<_object><d/></_object>
		<update public="1" set="method" line="83" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Updates the Tween.</haxe_doc>
		</update>
		<tween public="1" set="method" line="39">
			<f a="object:properties:duration:?ease">
				<d/>
				<d/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.misc.MultiVarTween"/>
			</f>
			<haxe_doc>* Tweens multiple numeric public properties.
	 * @param	object		The object containing the properties.
	 * @param	properties	An object containing key/value pairs of properties and target values.
	 * @param	duration	Duration of the tween.
	 * @param	ease		Optional easer function.</haxe_doc>
		</tween>
		<destroy public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="17">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete		Optional completion callback.
	 * @param	type			Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Tweens multiple numeric public properties of an Object simultaneously.</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.NumTween" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/misc/NumTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_range><x path="Float"/></_range>
		<_start><x path="Float"/></_start>
		<update public="1" set="method" line="45" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<tween public="1" set="method" line="34">
			<f a="fromValue:toValue:duration:?ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.misc.NumTween"/>
			</f>
			<haxe_doc>* Tweens the value from one value to another.
	 * @param	fromValue		Start value.
	 * @param	toValue			End value.
	 * @param	duration		Duration of the tween.
	 * @param	ease			Optional easer function.</haxe_doc>
		</tween>
		<value public="1">
			<x path="Float"/>
			<haxe_doc>* The current value.</haxe_doc>
		</value>
		<new public="1" set="method" line="21">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Tweens a numeric value.</haxe_doc>
	</class>
	<class path="flixel.tweens.misc.VarTween" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/misc/VarTween.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_range><x path="Float"/></_range>
		<_start><x path="Float"/></_start>
		<_property><c path="String"/></_property>
		<_object><d/></_object>
		<update public="1" set="method" line="69" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<tween public="1" set="method" line="35">
			<f a="object:property:to:duration:?ease">
				<d/>
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.misc.VarTween"/>
			</f>
			<haxe_doc>* Tweens a numeric public property.
	 * @param	object		The object containing the property.
	 * @param	property	The name of the property (eg. "x").
	 * @param	to			Value to tween to.
	 * @param	duration	Duration of the tween.
	 * @param	ease		Optional easer function.</haxe_doc>
		</tween>
		<destroy public="1" set="method" line="21" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="16">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Tweens a numeric public property of an Object.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.Motion" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/Motion.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<postUpdate public="1" set="method" line="59"><f a=""><x path="Void"/></f></postUpdate>
		<update public="1" set="method" line="53" override="1"><f a=""><x path="Void"/></f></update>
		<setObject public="1" set="method" line="46"><f a="object">
	<t path="flixel.tweens.motion.Movable"/>
	<d/>
</f></setObject>
		<destroy public="1" set="method" line="40" override="1"><f a=""><x path="Void"/></f></destroy>
		<_object><t path="flixel.tweens.motion.Movable"/></_object>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* Current y position of the Tween.</haxe_doc>
		</y>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* Current x position of the Tween.</haxe_doc>
		</x>
		<new public="1" set="method" line="35">
			<f a="duration:?complete:?type:?ease">
				<x path="Float"/>
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<t path="flixel.tweens.EaseFunction"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	duration	Duration of the Tween.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.
	 * @param	ease		Optional easer function.</haxe_doc>
		</new>
		<haxe_doc>* Base class for motion Tweens.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.CircularMotion" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/CircularMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_CIRC line="87" static="1"><x path="Float"/></_CIRC>
		<_angleFinish><x path="Float"/></_angleFinish>
		<_angleStart><x path="Float"/></_angleStart>
		<_radius><x path="Float"/></_radius>
		<_centerY><x path="Float"/></_centerY>
		<_centerX><x path="Float"/></_centerX>
		<get_circumference set="method" line="79"><f a=""><x path="Float"/></f></get_circumference>
		<circumference public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The circumference of the current circle motion.</haxe_doc>
		</circumference>
		<angle public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The current position on the circle.</haxe_doc>
		</angle>
		<update public="1" set="method" line="58" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<setMotion public="1" set="method" line="35">
			<f a="CenterX:CenterY:Radius:Angle:Clockwise:DurationOrSpeed:?UseDuration:?Ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.motion.CircularMotion"/>
			</f>
			<haxe_doc>* Starts moving along a circle.
	 * @param	CenterX			X position of the circle's center.
	 * @param	CenterY			Y position of the circle's center.
	 * @param	Radius			Radius of the circle.
	 * @param	Angle			Starting position on the circle.
	 * @param	Clockwise		If the motion is clockwise.
	 * @param	DurationOrSpeed	Duration of the movement.
	 * @param	UseDuration		Duration of the movement.
	 * @param	Eease			Optional easer function.</haxe_doc>
		</setMotion>
		<new public="1" set="method" line="16">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Determines a circular motion.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.CubicMotion" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/CubicMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_tt><x path="Float"/></_tt>
		<_ttt><x path="Float"/></_ttt>
		<_bY><x path="Float"/></_bY>
		<_bX><x path="Float"/></_bX>
		<_aY><x path="Float"/></_aY>
		<_aX><x path="Float"/></_aX>
		<_toY><x path="Float"/></_toY>
		<_toX><x path="Float"/></_toX>
		<_fromY><x path="Float"/></_fromY>
		<_fromX><x path="Float"/></_fromX>
		<update public="1" set="method" line="53" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<setMotion public="1" set="method" line="36">
			<f a="fromX:fromY:aX:aY:bX:bY:toX:toY:duration:?ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.motion.CubicMotion"/>
			</f>
			<haxe_doc>* Starts moving along the curve.
	 * @param	fromX		X start.
	 * @param	fromY		Y start.
	 * @param	aX			First control x.
	 * @param	aY			First control y.
	 * @param	bX			Second control x.
	 * @param	bY			Second control y.
	 * @param	toX			X finish.
	 * @param	toY			Y finish.
	 * @param	duration	Duration of the movement.
	 * @param	ease		Optional easer function.</haxe_doc>
		</setMotion>
		<new public="1" set="method" line="16">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Determines motion along a cubic curve.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.LinearMotion" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/LinearMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_distance><x path="Float"/></_distance>
		<_moveY><x path="Float"/></_moveY>
		<_moveX><x path="Float"/></_moveX>
		<_fromY><x path="Float"/></_fromY>
		<_fromX><x path="Float"/></_fromX>
		<get_distance set="method" line="75"><f a=""><x path="Float"/></f></get_distance>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Length of the current line of movement.</haxe_doc>
		</distance>
		<update public="1" set="method" line="56" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<setMotion public="1" set="method" line="32">
			<f a="FromX:FromY:ToX:ToY:DurationOrSpeed:?UseDuration:?Ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.motion.LinearMotion"/>
			</f>
			<haxe_doc>* Starts moving along a line.
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Whether to use the previous param as duration or speed.
	 * @param	Ease			Optional easer function.</haxe_doc>
		</setMotion>
		<new public="1" set="method" line="15">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Determines motion along a line, from one point to another.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.LinearPath" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/LinearPath.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_nextPoint><c path="flixel.util.FlxPoint"/></_nextPoint>
		<_prevPoint><c path="flixel.util.FlxPoint"/></_prevPoint>
		<_last><c path="flixel.util.FlxPoint"/></_last>
		<_index><x path="Int"/></_index>
		<_speed><x path="Float"/></_speed>
		<_pointT><c path="Array"><x path="Float"/></c></_pointT>
		<_pointD><c path="Array"><x path="Float"/></c></_pointD>
		<_points><c path="Array"><c path="flixel.util.FlxPoint"/></c></_points>
		<get_pointCount set="method" line="189"><f a=""><x path="Float"/></f></get_pointCount>
		<pointCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* How many points are on the path.</haxe_doc>
		</pointCount>
		<distance public="1" set="null">
			<x path="Float"/>
			<haxe_doc>* The full length of the path.</haxe_doc>
		</distance>
		<updatePath set="method" line="168">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the path, preparing it for motion.</haxe_doc>
		</updatePath>
		<update public="1" set="method" line="113" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<start public="1" set="method" line="97" override="1">
			<f a=""><d/></f>
			<haxe_doc>@private Starts the Tween.</haxe_doc>
		</start>
		<getPoint public="1" set="method" line="87">
			<f a="?index">
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Gets a point on the path.
	 * @param	index		Index of the point.
	 * @return	The Point object.</haxe_doc>
		</getPoint>
		<addPoint public="1" set="method" line="71">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<haxe_doc>* Adds the point to the path.
	 * @param	x		X position.
	 * @param	y		Y position.</haxe_doc>
		</addPoint>
		<setMotion public="1" set="method" line="46">
			<f a="DurationOrSpeed:?UseDuration:?Ease">
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.motion.LinearPath"/>
			</f>
			<haxe_doc>* Starts moving along the path.
	 * @param	DurationOrSpeed		Duration or speed of the movement.
	 * @param	UseDuration			Whether to use the previous param as duration or speed.
	 * @param	Ease				Optional easer function.</haxe_doc>
		</setMotion>
		<destroy public="1" set="method" line="29" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="17">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Determines linear motion along a set of points.</haxe_doc>
	</class>
	<typedef path="flixel.tweens.motion.Movable" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/Motion.hx" module="flixel.tweens.motion.Motion"><a>
	<setPosition set="method"><f a="X:Y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPosition>
	<immovable><x path="Bool"/></immovable>
</a></typedef>
	<enum path="flixel.tweens.motion.MotionType" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/MotionType.hx">
		<LINEAR/>
		<CIRCULAR/>
		<QUAD/>
		<CUBIC/>
		<haxe_doc>* Types of motion tweens</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="flixel.tweens.motion.PathType" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/PathType.hx">
		<LINEAR/>
		<QUAD/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="flixel.tweens.motion.QuadMotion" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/QuadMotion.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<point public="1" line="13" static="1"><c path="flixel.util.FlxPoint"/></point>
		<point2 public="1" line="14" static="1"><c path="flixel.util.FlxPoint"/></point2>
		<_controlY><x path="Float"/></_controlY>
		<_controlX><x path="Float"/></_controlX>
		<_toY><x path="Float"/></_toY>
		<_toX><x path="Float"/></_toX>
		<_fromY><x path="Float"/></_fromY>
		<_fromX><x path="Float"/></_fromX>
		<_distance><x path="Float"/></_distance>
		<get_distance set="method" line="82"><f a=""><x path="Float"/></f></get_distance>
		<distance public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* The distance of the entire curve.</haxe_doc>
		</distance>
		<update public="1" set="method" line="67" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<setMotion public="1" set="method" line="41">
			<f a="FromX:FromY:ControlX:ControlY:ToX:ToY:DurationOrSpeed:?UseDuration:?Ease">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.motion.QuadMotion"/>
			</f>
			<haxe_doc>* Starts moving along the curve.
	 * @param	FromX			X start.
	 * @param	FromY			Y start.
	 * @param	ControlX		X control, used to determine the curve.
	 * @param	ControlY		Y control, used to determine the curve.
	 * @param	ToX				X finish.
	 * @param	ToY				Y finish.
	 * @param	DurationOrSpeed	Duration or speed of the movement.
	 * @param	UseDuration		Duration of the movement.
	 * @param	Ease			Optional easer function.</haxe_doc>
		</setMotion>
		<new public="1" set="method" line="21">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Determines motion along a quadratic curve.</haxe_doc>
	</class>
	<class path="flixel.tweens.motion.QuadPath" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/motion/QuadPath.hx">
		<extends path="flixel.tweens.motion.Motion"/>
		<_Point line="271" static="1"><c path="flixel.util.FlxPoint"/></_Point>
		<_Point2 line="272" static="1"><c path="flixel.util.FlxPoint"/></_Point2>
		<_c><c path="flixel.util.FlxPoint"/></_c>
		<_b><c path="flixel.util.FlxPoint"/></_b>
		<_a><c path="flixel.util.FlxPoint"/></_a>
		<_curveD><c path="Array"><x path="Float"/></c></_curveD>
		<_curveT><c path="Array"><x path="Float"/></c></_curveT>
		<_curve><c path="Array"><c path="flixel.util.FlxPoint"/></c></_curve>
		<_updateCurve><x path="Bool"/></_updateCurve>
		<_index><x path="Int"/></_index>
		<_speed><x path="Float"/></_speed>
		<_distance><x path="Float"/></_distance>
		<_points><c path="Array"><c path="flixel.util.FlxPoint"/></c></_points>
		<curveLength set="method" line="235">
			<f a="start:control:finish">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>@private Calculates the lenght of the curve.</haxe_doc>
		</curveLength>
		<get_pointCount set="method" line="232"><f a=""><x path="Float"/></f></get_pointCount>
		<pointCount public="1" get="accessor" set="null">
			<x path="Float"/>
			<haxe_doc>* Amount of points on the path.</haxe_doc>
		</pointCount>
		<updatePath set="method" line="172">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the path, preparing the curve.</haxe_doc>
		</updatePath>
		<update public="1" set="method" line="114" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<start public="1" set="method" line="98" override="1">
			<f a=""><d/></f>
			<haxe_doc>@private Starts the Tween.</haxe_doc>
		</start>
		<getPoint public="1" set="method" line="88">
			<f a="?index">
				<x path="Int"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc>* Gets the point on the path.
	 * @param	index		Index of the point.
	 * @return	The Point object.</haxe_doc>
		</getPoint>
		<addPoint public="1" set="method" line="75">
			<f a="?x:?y">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<haxe_doc>* Adds the point to the path.
	 * @param	x		X position.
	 * @param	y		Y position.</haxe_doc>
		</addPoint>
		<setMotion public="1" set="method" line="50">
			<f a="DurationOrSpeed:?UseDuration:?Ease">
				<x path="Float"/>
				<x path="Bool"/>
				<t path="flixel.tweens.EaseFunction"/>
				<c path="flixel.tweens.motion.QuadPath"/>
			</f>
			<haxe_doc>* Starts moving along the path.
	 * @param	DurationOrSpeed		Duration or speed of the movement.
	 * @param	UseDuration			Whether to use the previous param as duration or speed.
	 * @param	Ease				Optional easer function.</haxe_doc>
		</setMotion>
		<destroy public="1" set="method" line="32" override="1"><f a=""><x path="Void"/></f></destroy>
		<new public="1" set="method" line="19">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* A series of points which will determine a path from the
 * beginning point to the end poing using quadratic curves.</haxe_doc>
	</class>
	<class path="flixel.tweens.sound.Fader" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/tweens/sound/Fader.hx">
		<extends path="flixel.tweens.FlxTween"/>
		<_range><x path="Float"/></_range>
		<_start><x path="Float"/></_start>
		<update public="1" set="method" line="39" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>@private Updates the Tween.</haxe_doc>
		</update>
		<fadeTo public="1" set="method" line="28">
			<f a="volume:duration:?ease">
				<x path="Float"/>
				<x path="Float"/>
				<t path="flixel.tweens.EaseFunction"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Fades FlxG.volume to the target volume.
	 * @param	volume		The volume to fade to.
	 * @param	duration	Duration of the fade.
	 * @param	ease		Optional easer function.</haxe_doc>
		</fadeTo>
		<new public="1" set="method" line="17">
			<f a="?complete:?type">
				<t path="flixel.tweens.CompleteCallback"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor.
	 * @param	complete	Optional completion callback.
	 * @param	type		Tween type.</haxe_doc>
		</new>
		<haxe_doc>* Global volume fader.</haxe_doc>
	</class>
	<class path="flixel.util.FlxAngle" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxAngle.hx">
		<cosTable public="1" line="15" static="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc><![CDATA[* Use this to access the cos-table generated via <code>sinCosGenerator()</code>.]]></haxe_doc>
		</cosTable>
		<sinTable public="1" line="19" static="1">
			<c path="Array"><x path="Float"/></c>
			<haxe_doc><![CDATA[* Use this to access the sin-table generated via <code>sinCosGenerator()</code>.]]></haxe_doc>
		</sinTable>
		<TO_DEG public="1" line="23" static="1">
			<x path="Float"/>
			<haxe_doc>* Convert radions to degrees by multiplying it with this value.</haxe_doc>
		</TO_DEG>
		<TO_RAD public="1" line="27" static="1">
			<x path="Float"/>
			<haxe_doc>* Convert degrees to radians by multiplying it with this value.</haxe_doc>
		</TO_RAD>
		<rotatePoint public="1" get="inline" set="null" line="39" static="1">
			<f a="X:Y:PivotX:PivotY:Angle:?point">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
			</f>
			<haxe_doc><![CDATA[* Rotates a point in 2D space around another point by the given angle.
	 * @param	X		The X coordinate of the point you want to rotate.
	 * @param	Y		The Y coordinate of the point you want to rotate.
	 * @param	PivotX	The X coordinate of the point you want to rotate around.
	 * @param	PivotY	The Y coordinate of the point you want to rotate around.
	 * @param	Angle	Rotate the point by this many degrees.
	 * @param	Point	Optional <code>FlxPoint</code> to store the results in.
	 * @return	A <code>FlxPoint</code> containing the coordinates of the rotated point.]]></haxe_doc>
		</rotatePoint>
		<getAngle public="1" get="inline" set="null" line="127" static="1">
			<f a="Point1:Point2">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Calculates the angle between two points.  0 degrees points straight up.
	 * @param	Point1		The X coordinate of the point.
	 * @param	Point2		The Y coordinate of the point.
	 * @return	The angle in degrees, between -180 and 180.</haxe_doc>
		</getAngle>
		<sinCosGenerator public="1" set="method" line="173" static="1">
			<f a="length:?sinAmplitude:?cosAmplitude:?frequency">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Generate a sine and cosine table simultaneously and extremely quickly. Based on research by Franky of scene.at
	 * 
	 * The parameters allow you to specify the length, amplitude and frequency of the wave. Once you have called this function
	 * you should get the results via <code>sinTable</code> and <code>cosTable</code>. This generator is fast enough to be used in real-time.
	 * 
	 * @param length 		The length of the wave
	 * @param sinAmplitude 	The amplitude to apply to the sine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
	 * @param cosAmplitude 	The amplitude to apply to the cosine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
	 * @param frequency 	The frequency of the sine and cosine table data
	 * @return	Returns the sine table
	 * @see getSinTable
	 * @see getCosTable]]></haxe_doc>
		</sinCosGenerator>
		<wrapAngle public="1" set="method" line="200" static="1">
			<f a="angle">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Keeps an angle value between -180 and +180
	 * Should be called whenever the angle is updated on a FlxSprite to stop it from going insane.
	 * 
	 * @param	angle	The angle value to check
	 * 
	 * @return	The new angle value, returns the same as the input angle if it was within bounds</haxe_doc>
		</wrapAngle>
		<angleLimit public="1" set="method" line="225" static="1">
			<f a="angle:min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Keeps an angle value between the given min and max values
	 * 
	 * @param	angle	The angle value to check. Must be between -180 and +180
	 * @param	min		The minimum angle that is allowed (must be -180 or greater)
	 * @param	max		The maximum angle that is allowed (must be 180 or less)
	 * 
	 * @return	The new angle value, returns the same as the input angle if it was within bounds</haxe_doc>
		</angleLimit>
		<asDegrees public="1" get="inline" set="null" line="248" static="1">
			<f a="radians">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts a Radian value into a Degree
	 * Converts the radians value into degrees and returns
	 * 
	 * @param 	radians 	The value in radians
	 * @return	Degrees</haxe_doc>
		</asDegrees>
		<asRadians public="1" get="inline" set="null" line="260" static="1">
			<f a="degrees">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Converts a Degrees value into a Radian
	 * Converts the degrees value into radians and returns
	 * 
	 * @param 	degrees The value in degrees
	 * @return	Radians</haxe_doc>
		</asRadians>
		<angleBetween public="1" get="inline" set="null" line="274" static="1">
			<f a="SpriteA:SpriteB:?AsDegrees">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between the two FlxSprite, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	SpriteA		The FlxSprite to test from
	 * @param	SpriteB		The FlxSprite to test to
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless asDegrees is true)</haxe_doc>
		</angleBetween>
		<angleBetweenPoint public="1" set="method" line="294" static="1">
			<f a="Sprite:Target:?AsDegrees">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and an FlxPoint. The source sprite takes its x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Sprite		The FlxSprite to test from
	 * @param	Target		The FlxPoint to angle the FlxSprite towards
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenPoint>
		<angleBetweenMouse public="1" set="method" line="314" static="1">
			<f a="Object:?AsDegrees">
				<c path="flixel.FlxObject"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and the mouse, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Object		The FlxObject to test from
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenMouse>
		<angleBetweenTouch public="1" get="inline" set="null" line="342" static="1">
			<f a="Object:Touch:?AsDegrees">
				<c path="flixel.FlxObject"/>
				<c path="flixel.system.input.touch.FlxTouch"/>
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Find the angle (in radians) between an FlxSprite and a FlxTouch, taking their x/y and origin into account.
	 * The angle is calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)
	 * 
	 * @param	Object		The FlxObject to test from
	 * @param	Touch		The FlxTouch to test to
	 * @param	AsDegrees	If you need the value in degrees instead of radians, set to true
	 * @return	The angle (in radians unless AsDegrees is true)</haxe_doc>
		</angleBetweenTouch>
		<haxe_doc>* A set of functions related to angle calculations.</haxe_doc>
	</class>
	<class path="flixel.util.FlxArrayUtil" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxArrayUtil.hx">
		<indexOf public="1" get="inline" set="null" line="17" static="1">
			<f a="array:whatToFind:?fromIndex">
				<c path="Array"><d/></c>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Function to search for a specified element in an array. This is faster than <code>Lambda.indexOf()</code>
	 * on the flash target because it uses the the native array <code>indexOf()</code> method.
	 * 
	 * @param	array		The array.
	 * @param	whatToFind	The element you're looking for.
	 * @param 	fromIndex	The index to start the search from (optional, for optimization).
	 * @return	The index of the element within the array. -1 if it wasn't found.]]></haxe_doc>
		</indexOf>
		<setLength public="1" set="method" line="42" static="1">
			<f a="array:newLength">
				<c path="Array"><d/></c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the length of an array.
	 * 
	 * @param	array		The array.
	 * @param	newLength	The length you want the array to have.</haxe_doc>
		</setLength>
		<shuffle public="1" get="inline" set="null" line="69" static="1">
			<f a="Objects:HowManyTimes">
				<c path="Array"><d/></c>
				<x path="Int"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc><![CDATA[* Shuffles the entries in an array into a new random order.
	 * Deterministic and safe for use with replays/recordings.
	 * 
	 * @param	A				A Flash <code>Array</code> object containing...stuff.
	 * @param	HowManyTimes	How many swaps to perform during the shuffle operation.  Good rule of thumb is 2-4 times as many objects are in the list.
	 * @return	The same Flash <code>Array</code> object that you passed in in the first place.]]></haxe_doc>
		</shuffle>
		<getRandom public="1" set="method" line="98" static="1">
			<f a="Objects:?StartIndex:?Length">
				<c path="Array"><d/></c>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>* Fetch a random entry from the given array.
	 * Will return null if random selection is missing, or array has no entries.
	 * Deterministic and safe for use with replays/recordings.
	 * 
	 * @param	Objects		A Flash array of objects.
	 * @param	StartIndex	Optional offset off the front of the array. Default value is 0, or the beginning of the array.
	 * @param	Length		Optional restriction on the number of values you want to randomly select from.
	 * @return	The random object that was selected.</haxe_doc>
		</getRandom>
		<haxe_doc>* A set of functions for array manipulation.</haxe_doc>
	</class>
	<class path="flixel.util.FlxBitmapUtil" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxBitmapUtil.hx"><compare public="1" set="method" line="7" static="1"><f a="Bitmap1:Bitmap2">
	<c path="flash.display.BitmapData"/>
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare></class>
	<class path="flixel.util.FlxCollision" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxCollision.hx">
		<CAMERA_WALL_OUTSIDE public="1" get="inline" set="null" line="23" static="1"><x path="Int"/></CAMERA_WALL_OUTSIDE>
		<CAMERA_WALL_INSIDE public="1" get="inline" set="null" line="24" static="1"><x path="Int"/></CAMERA_WALL_INSIDE>
		<debug public="1" line="26" static="1"><c path="flash.display.BitmapData"/></debug>
		<pixelPerfectCheck public="1" set="method" line="41" static="1">
			<f a="Contact:Target:?AlphaTolerance:?Camera">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<c path="flixel.FlxCamera"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* A Pixel Perfect Collision check between two FlxSprites.
	 * It will do a bounds check first, and if that passes it will run a pixel perfect match on the intersecting area.
	 * Works with rotated and animated sprites.
	 * It's extremly slow on cpp targets, so I don't recommend you to use it on them.
	 * Not working on neko target and awfully slows app down
	 * 
	 * @param	Contact			The first FlxSprite to test against
	 * @param	Target			The second FlxSprite to test again, sprite order is irrelevant
	 * @param	AlphaTolerance	The tolerance value above which alpha pixels are included. Default to 255 (must be fully opaque for collision).
	 * @param	Camera			If the collision is taking place in a camera other than FlxG.camera (the default/current) then pass it here
	 * @return	Boolean True if the sprites collide, false if not</haxe_doc>
		</pixelPerfectCheck>
		<pixelPerfectPointCheck public="1" set="method" line="215" static="1">
			<f a="PointX:PointY:Target:?AlphaTolerance">
				<x path="Int"/>
				<x path="Int"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[* A Pixel Perfect Collision check between a given x/y coordinate and an FlxSprite<br>
	 * 
	 * @param	PointX			The x coordinate of the point given in local space (relative to the FlxSprite, not game world coordinates)
	 * @param	PointY			The y coordinate of the point given in local space (relative to the FlxSprite, not game world coordinates)
	 * @param	Target			The FlxSprite to check the point against
	 * @param	AlphaTolerance	The alpha tolerance level above which pixels are counted as colliding. Default to 255 (must be fully transparent for collision)
	 * @return	Boolean True if the x/y point collides with the FlxSprite, false if not]]></haxe_doc>
		</pixelPerfectPointCheck>
		<createCameraWall public="1" set="method" line="257" static="1">
			<f a="Camera:Placement:Thickness:?AdjustWorldBounds">
				<c path="flixel.FlxCamera"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="flixel.group.FlxGroup"/>
			</f>
			<haxe_doc>* Creates a "wall" around the given camera which can be used for FlxSprite collision
	 * 
	 * @param	Camera				The FlxCamera to use for the wall bounds (can be FlxG.camera for the current one)
	 * @param	Placement			CAMERA_WALL_OUTSIDE or CAMERA_WALL_INSIDE
	 * @param	Thickness			The thickness of the wall in pixels
	 * @param	AdjustWorldBounds	Adjust the FlxG.worldBounds based on the wall (true) or leave alone (false)
	 * @return	FlxGroup The 4 FlxTileblocks that are created are placed into this FlxGroup which should be added to your State</haxe_doc>
		</createCameraWall>
		<haxe_doc>* FlxCollision
 *
 * @link http://www.photonstorm.com
 * @author Richard Davey / Photon Storm</haxe_doc>
	</class>
	<class path="flixel.util.FlxColor" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColor.hx">
		<RED public="1" get="inline" set="null" line="11" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xffff0012</haxe_doc>
		</RED>
		<YELLOW public="1" get="inline" set="null" line="16" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xffffff00</haxe_doc>
		</YELLOW>
		<GREEN public="1" get="inline" set="null" line="21" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff00f225</haxe_doc>
		</GREEN>
		<BLUE public="1" get="inline" set="null" line="26" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff0090e9</haxe_doc>
		</BLUE>
		<PINK public="1" get="inline" set="null" line="31" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xfff01eff</haxe_doc>
		</PINK>
		<PURPLE public="1" get="inline" set="null" line="36" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff800080</haxe_doc>
		</PURPLE>
		<WHITE public="1" get="inline" set="null" line="41" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xffffffff</haxe_doc>
		</WHITE>
		<BLACK public="1" get="inline" set="null" line="46" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff000000</haxe_doc>
		</BLACK>
		<GRAY public="1" get="inline" set="null" line="51" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff808080</haxe_doc>
		</GRAY>
		<BROWN public="1" get="inline" set="null" line="56" static="1">
			<x path="Int"/>
			<haxe_doc>* 0xff964B00</haxe_doc>
		</BROWN>
		<TRANSPARENT public="1" get="inline" set="null" line="61" static="1">
			<x path="Int"/>
			<haxe_doc>* 0x00000000</haxe_doc>
		</TRANSPARENT>
		<IVORY public="1" get="inline" set="null" line="66" static="1">
			<x path="Int"/>
			<haxe_doc>* Ivory is an off-white color that resembles ivory. 0xfffffff0</haxe_doc>
		</IVORY>
		<BEIGE public="1" get="inline" set="null" line="71" static="1">
			<x path="Int"/>
			<haxe_doc>* Beige is a very pale brown. 0xfff5f5dc</haxe_doc>
		</BEIGE>
		<WHEAT public="1" get="inline" set="null" line="76" static="1">
			<x path="Int"/>
			<haxe_doc>* Wheat is a color that resembles wheat. 0xfff5deb3</haxe_doc>
		</WHEAT>
		<TAN public="1" get="inline" set="null" line="81" static="1">
			<x path="Int"/>
			<haxe_doc>* Tan is a pale tone of brown. 0xffd2b48c</haxe_doc>
		</TAN>
		<KHAKI public="1" get="inline" set="null" line="86" static="1">
			<x path="Int"/>
			<haxe_doc>* Khaki is a light shade of yellow-brown similar to tan or beige. 0xffc3b091</haxe_doc>
		</KHAKI>
		<SILVER public="1" get="inline" set="null" line="91" static="1">
			<x path="Int"/>
			<haxe_doc>* Silver is a metallic color tone resembling gray that is a representation of the color of polished silver. 0xffc0c0c0</haxe_doc>
		</SILVER>
		<CHARCOAL public="1" get="inline" set="null" line="96" static="1">
			<x path="Int"/>
			<haxe_doc>* Charcoal is a representation of the dark gray color of burned wood. 0xff464646</haxe_doc>
		</CHARCOAL>
		<NAVY_BLUE public="1" get="inline" set="null" line="101" static="1">
			<x path="Int"/>
			<haxe_doc>* Navy blue is a dark shade of the color blue. 0xff000080</haxe_doc>
		</NAVY_BLUE>
		<ROYAL_BLUE public="1" get="inline" set="null" line="106" static="1">
			<x path="Int"/>
			<haxe_doc>* Royal blue is a dark shade of the color blue. 0xff084c9e</haxe_doc>
		</ROYAL_BLUE>
		<MEDIUM_BLUE public="1" get="inline" set="null" line="111" static="1">
			<x path="Int"/>
			<haxe_doc>* A medium blue tone. 0xff0000cd</haxe_doc>
		</MEDIUM_BLUE>
		<AZURE public="1" get="inline" set="null" line="116" static="1">
			<x path="Int"/>
			<haxe_doc>* Azure is a color that is commonly compared to the color of the sky on a clear summer's day. 0xff007fff</haxe_doc>
		</AZURE>
		<CYAN public="1" get="inline" set="null" line="121" static="1">
			<x path="Int"/>
			<haxe_doc>* Cyan is a color between blue and green. 0xff00ffff</haxe_doc>
		</CYAN>
		<AQUAMARINE public="1" get="inline" set="null" line="126" static="1">
			<x path="Int"/>
			<haxe_doc>* Aquamarine is a color that is a bluish tint of cerulean toned toward cyan. 0xff7fffd4</haxe_doc>
		</AQUAMARINE>
		<TEAL public="1" get="inline" set="null" line="131" static="1">
			<x path="Int"/>
			<haxe_doc>* Teal is a low-saturated color, a bluish-green to dark medium. 0xff008080</haxe_doc>
		</TEAL>
		<FOREST_GREEN public="1" get="inline" set="null" line="136" static="1">
			<x path="Int"/>
			<haxe_doc>* Forest green is a green color resembling trees and other plants in a forest. 0xff228b22</haxe_doc>
		</FOREST_GREEN>
		<OLIVE public="1" get="inline" set="null" line="141" static="1">
			<x path="Int"/>
			<haxe_doc>* Olive is a dark yellowish green or greyish-green color like that of unripe or green olives. 0xff808000</haxe_doc>
		</OLIVE>
		<CHARTREUSE public="1" get="inline" set="null" line="146" static="1">
			<x path="Int"/>
			<haxe_doc>* Chartreuse is a color halfway between yellow and green. 0xff7fff00</haxe_doc>
		</CHARTREUSE>
		<LIME public="1" get="inline" set="null" line="151" static="1">
			<x path="Int"/>
			<haxe_doc>* Lime is a color three-quarters of the way between yellow and green. 0xffbfff00</haxe_doc>
		</LIME>
		<GOLDEN public="1" get="inline" set="null" line="156" static="1">
			<x path="Int"/>
			<haxe_doc>* Golden is one of a variety of yellow-brown color blends used to give the impression of the color of the element gold. 0xffffd700</haxe_doc>
		</GOLDEN>
		<GOLDENROD public="1" get="inline" set="null" line="161" static="1">
			<x path="Int"/>
			<haxe_doc>* Goldenrod is a color that resembles the goldenrod plant. 0xffdaa520</haxe_doc>
		</GOLDENROD>
		<CORAL public="1" get="inline" set="null" line="166" static="1">
			<x path="Int"/>
			<haxe_doc>* Coral is a pinkish-orange color. 0xffff7f50</haxe_doc>
		</CORAL>
		<SALMON public="1" get="inline" set="null" line="171" static="1">
			<x path="Int"/>
			<haxe_doc>* Salmon is a pale pinkish-orange to light pink color, named after the color of salmon flesh. 0xfffa8072</haxe_doc>
		</SALMON>
		<HOT_PINK public="1" get="inline" set="null" line="176" static="1">
			<x path="Int"/>
			<haxe_doc>* Hot Pink is a more saturated version of the color pink. 0xfffc0fc0</haxe_doc>
		</HOT_PINK>
		<FUCHSIA public="1" get="inline" set="null" line="181" static="1">
			<x path="Int"/>
			<haxe_doc>* Fuchsia is a vivid reddish or pink color named after the flower of the fuchsia plant. 0xffff77ff</haxe_doc>
		</FUCHSIA>
		<PUCE public="1" get="inline" set="null" line="186" static="1">
			<x path="Int"/>
			<haxe_doc>* Puce is a brownish-purple color. 0xffcc8899</haxe_doc>
		</PUCE>
		<MAUVE public="1" get="inline" set="null" line="191" static="1">
			<x path="Int"/>
			<haxe_doc>* Mauve is a pale lavender-lilac color. 0xffe0b0ff</haxe_doc>
		</MAUVE>
		<LAVENDER public="1" get="inline" set="null" line="196" static="1">
			<x path="Int"/>
			<haxe_doc>* Lavender is a pale tint of violet. 0xffb57edc</haxe_doc>
		</LAVENDER>
		<PLUM public="1" get="inline" set="null" line="201" static="1">
			<x path="Int"/>
			<haxe_doc>* Plum is a deep purple color. 0xff843179</haxe_doc>
		</PLUM>
		<INDIGO public="1" get="inline" set="null" line="206" static="1">
			<x path="Int"/>
			<haxe_doc>* Indigo is a deep and bright shade of blue. 0xff4b0082</haxe_doc>
		</INDIGO>
		<MAROON public="1" get="inline" set="null" line="211" static="1">
			<x path="Int"/>
			<haxe_doc>* Maroon is a dark brownish-red color. 0xff800000</haxe_doc>
		</MAROON>
		<CRIMSON public="1" get="inline" set="null" line="216" static="1">
			<x path="Int"/>
			<haxe_doc>* Crimson is a strong, bright, deep red color. 0xffdc143c</haxe_doc>
		</CRIMSON>
		<haxe_doc>* Class containing a set of useful color constants.</haxe_doc>
	</class>
	<class path="flixel.util.FlxColorUtil" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColorUtil.hx">
		<makeFromRGBA public="1" get="inline" set="null" line="17" static="1">
			<f a="Red:Green:Blue:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Generate a Flash <code>uint</code> color from RGBA components.
	 * 
	 * @param   Red     The red component, between 0 and 255.
	 * @param   Green   The green component, between 0 and 255.
	 * @param   Blue    The blue component, between 0 and 255.
	 * @param   Alpha   How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return  The color as a <code>uint</code>.]]></haxe_doc>
		</makeFromRGBA>
		<makeFromHSBA public="1" get="inline" set="null" line="31" static="1">
			<f a="Hue:Saturation:Brightness:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Generate a Flash <code>uint</code> color from HSBA components.
	 * 
	 * @param	Hue			A number between 0 and 360, indicating position on a color strip or wheel.
	 * @param	Saturation	A number between 0 and 1, indicating how colorful or gray the color should be.  0 is gray, 1 is vibrant.
	 * @param	Brightness	A number between 0 and 1, indicating how bright the color should be.  0 is black, 1 is full bright.
	 * @param   Alpha   	How opaque the color should be, either between 0 and 1 or 0 and 255.
	 * @return	The color as a <code>uint</code>.]]></haxe_doc>
		</makeFromHSBA>
		<getRGBA public="1" get="inline" set="null" line="100" static="1">
			<f a="Color:?Results">
				<x path="Int"/>
				<t path="flixel.util.RGBA"/>
				<t path="flixel.util.RGBA"/>
			</f>
			<haxe_doc><![CDATA[* Loads an array with the RGBA values of a Flash <code>uint</code> color.
	 * RGB values are stored 0-255.  Alpha is stored as a floating point number between 0 and 1 rounded to 4 decimals.
	 * 
	 * @param	Color	The color you want to break into components.
	 * @param	Results	An optional parameter, allows you to use an RGBA that already exists in memory to store the result.
	 * @return	An RGBA object containing the Red, Green, Blue and Alpha values of the given color.]]></haxe_doc>
		</getRGBA>
		<getHSBA public="1" get="inline" set="null" line="122" static="1">
			<f a="Color:?Results">
				<x path="Int"/>
				<t path="flixel.util.HSBA"/>
				<t path="flixel.util.HSBA"/>
			</f>
			<haxe_doc><![CDATA[* Loads an array with the HSB values of a Flash <code>uint</code> color.
	 * Hue is a value between 0 and 360. Saturation, Brightness and Alpha
	 * are as floating point numbers between 0 and 1 rounded to 4 decimals.
	 * 
	 * @param	Color	The color you want to break into components.
	 * @param	Results	An optional parameter, allows you to use an array that already exists in memory to store the result.
	 * @return	An <code>HSBA</code> object containing the Red, Green, Blue and Alpha values of the given color.]]></haxe_doc>
		</getHSBA>
		<getAlpha public="1" get="inline" set="null" line="181" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Alpha component of the color, will be between 0 and 255 (0 being no Alpha, 255 full Alpha)</haxe_doc>
		</getAlpha>
		<getAlphaFloat public="1" get="inline" set="null" line="192" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Alpha component as a value between 0 and 1
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Alpha component of the color, will be between 0 and 1 (0 being no Alpha (opaque), 1 full Alpha (transparent))</haxe_doc>
		</getAlphaFloat>
		<getRed public="1" get="inline" set="null" line="204" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Red component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Red component of the color, will be between 0 and 255 (0 being no color, 255 full Red)</haxe_doc>
		</getRed>
		<getGreen public="1" get="inline" set="null" line="215" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Green component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Green component of the color, will be between 0 and 255 (0 being no color, 255 full Green)</haxe_doc>
		</getGreen>
		<getBlue public="1" get="inline" set="null" line="226" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given a native color value (in the format 0xAARRGGBB) this will return the Blue component, as a value between 0 and 255
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @return	The Blue component of the color, will be between 0 and 255 (0 being no color, 255 full Blue)</haxe_doc>
		</getBlue>
		<getRandomColor public="1" set="method" line="241" static="1">
			<f a="?Min:?Max:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns a random color value between black and white
	 * Set the min value to start each channel from the given offset.
	 * Set the max value to restrict the maximum color used per channel
	 * 
	 * @param	Min		The lowest value to use for the color
	 * @param	Max 	The highest value to use for the color
	 * @param	Alpha	The alpha value of the returning color (default 255 = fully opaque)
	 * @return	32-bit color value with alpha</haxe_doc>
		</getRandomColor>
		<getColor32 public="1" get="inline" set="null" line="272" static="1">
			<f a="Alpha:Red:Green:Blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given an alpha and 3 color values this will return an integer representation of it
	 * 
	 * @param	Alpha	The Alpha value (between 0 and 255)
	 * @param	Red		The Red channel value (between 0 and 255)
	 * @param	Green	The Green channel value (between 0 and 255)
	 * @param	Blue	The Blue channel value (between 0 and 255)
	 * @return	A native color value integer (format: 0xAARRGGBB)</haxe_doc>
		</getColor32>
		<getColor24 public="1" get="inline" set="null" line="285" static="1">
			<f a="Red:Green:Blue">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Given 3 color values this will return an integer representation of it
	 * 
	 * @param	Red		The Red channel value (between 0 and 255)
	 * @param	Green	The Green channel value (between 0 and 255)
	 * @param	Blue	The Blue channel value (between 0 and 255)
	 * @return	A native color value integer (format: 0xRRGGBB)</haxe_doc>
		</getColor24>
		<getHSVColorWheel public="1" set="method" line="296" static="1">
			<f a="?Alpha">
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<haxe_doc>* Get HSV color wheel values in an array which will be 360 elements in size
	 * 
	 * @param	Alpha	Alpha value for each color of the color wheel, between 0 (transparent) and 255 (opaque)
	 * @return	HSV color wheel as Array of Ints</haxe_doc>
		</getHSVColorWheel>
		<getComplementHarmony public="1" get="inline" set="null" line="316" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns a Complementary Color Harmony for the given color.
	 * A complementary hue is one directly opposite the color given on the color wheel
	 * Value returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	Color	The color to base the harmony on
	 * @return	0xAARRGGBB format color value</haxe_doc>
		</getComplementHarmony>
		<getAnalogousHarmony public="1" set="method" line="334" static="1">
			<f a="Color:?Threshold">
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.Harmony"/>
			</f>
			<haxe_doc>* Returns an Analogous Color Harmony for the given color.
	 * An Analogous harmony are hues adjacent to each other on the color wheel
	 * Values returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	color The color to base the harmony on
	 * @param	threshold Control how adjacent the colors will be (default +- 30 degrees)
	 * @return 	Object containing 3 properties: color1 (the original color), color2 (the warmer analogous color) and color3 (the colder analogous color)</haxe_doc>
		</getAnalogousHarmony>
		<getSplitComplementHarmony public="1" set="method" line="358" static="1">
			<f a="Color:?Threshold">
				<x path="Int"/>
				<x path="Int"/>
				<t path="flixel.util.Harmony"/>
			</f>
			<haxe_doc>* Returns an Split Complement Color Harmony for the given color.
	 * A Split Complement harmony are the two hues on either side of the color's Complement
	 * Values returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	Color 		The color to base the harmony on
	 * @param	Threshold 	Control how adjacent the colors will be to the Complement (default +- 30 degrees)
	 * @return 	Object containing 3 properties: color1 (the original color), color2 (the warmer analogous color) and color3 (the colder analogous color)</haxe_doc>
		</getSplitComplementHarmony>
		<getTriadicHarmony public="1" get="inline" set="null" line="385" static="1">
			<f a="Color">
				<x path="Int"/>
				<t path="flixel.util.TriadicHarmony"/>
			</f>
			<haxe_doc>* Returns a Triadic Color Harmony for the given color.
	 * A Triadic harmony are 3 hues equidistant from each other on the color wheel
	 * Values returned in 0xAARRGGBB format with Alpha set to 255.
	 * 
	 * @param	Color 	The color to base the harmony on
	 * @return 	Object containing 3 properties: color1 (the original color), color2 and color3 (the equidistant colors)</haxe_doc>
		</getTriadicHarmony>
		<getColorInfo public="1" get="inline" set="null" line="402" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a String containing handy information about the given color including String hex value,
	 * RGB format information and HSL information. Each section starts on a newline, 3 lines in total.
	 * 
	 * @param	Color 	A color value in the format 0xAARRGGBB
	 * @return	String containing the 3 lines of information</haxe_doc>
		</getColorInfo>
		<RGBAtoHexString public="1" get="inline" set="null" line="425" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format 0xAARRGGBB
	 * 
	 * @param	Color 	The color to get the String representation for
	 * @return	A string of length 10 characters in the format 0xAARRGGBB</haxe_doc>
		</RGBAtoHexString>
		<RGBAtoWebString public="1" get="inline" set="null" line="438" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String representation of the color in the format #RRGGBB
	 * 
	 * @param	Color 	The color to get the String representation for
	 * @return	A string of length 10 characters in the format 0xAARRGGBB</haxe_doc>
		</RGBAtoWebString>
		<colorToHexString public="1" get="inline" set="null" line="451" static="1">
			<f a="Color">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Return a String containing a hex representation of the given color
	 * 
	 * @param	Color	The color channel to get the hex value for, must be a value between 0 and 255)
	 * @return	A string of length 2 characters, i.e. 255 = FF, 0 = 00</haxe_doc>
		</colorToHexString>
		<HSVtoRGBA public="1" set="method" line="470" static="1">
			<f a="H:S:V:?Alpha">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Convert a HSV (hue, saturation, lightness) color space value to an RGB color
	 * 
	 * @param	H 		Hue degree, between 0 and 359
	 * @param	S 		Saturation, between 0.0 (grey) and 1.0
	 * @param	V 		Value, between 0.0 (black) and 1.0
	 * @param	Alpha	Alpha value to set per color (between 0 and 255)
	 * @return	32-bit RGBA color value (0xAARRGGBB)</haxe_doc>
		</HSVtoRGBA>
		<RGBtoHSV public="1" set="method" line="514" static="1">
			<f a="Color">
				<x path="Int"/>
				<t path="flixel.util.HSV"/>
			</f>
			<haxe_doc>* Convert an RGB color value to an object containing the HSV color space values: Hue, Saturation and Lightness
	 * 
	 * @param	Color 	The color in format 0xRRGGBB
	 * @return 	Object with the properties hue (from 0 to 360), saturation (from 0 to 1.0) and lightness (from 0 to 1.0, also available under .value)</haxe_doc>
		</RGBtoHSV>
		<RGBAtoRGB public="1" get="inline" set="null" line="588" static="1">
			<f a="Color">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Turn a color with alpha and rgb values into a color without the alpha comoponent.
	 * Example: 0x55ff0000 becomes 0xff0000
	 * 
	 * @param	Color	The Color to convert
	 * @return	The color without its alpha component</haxe_doc>
		</RGBAtoRGB>
		<interpolateColor public="1" get="inline" set="null" line="603" static="1">
			<f a="Color1:Color2:Steps:CurrentStep:?Alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get an interpolated color based on two different colors.
	 * 
	 * @param 	Color1			The first color
	 * @param 	Color2			The second color
	 * @param 	Steps			The amount of total steps
	 * @param 	CurrentStep		The step the interpolated color should be on
	 * @param	Alpha			The alpha value you want the interpolated color to have
	 * @return	The interpolated color</haxe_doc>
		</interpolateColor>
		<interpolateColorWithRGB public="1" get="inline" set="null" line="627" static="1">
			<f a="Color:R2:G2:B2:Steps:CurrentStep">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get an interpolated color based on a color and the RGB value of a second color.
	 * 
	 * @param 	Color			The first color
	 * @param 	R2				The red value of the second color
	 * @param 	G2				The green value of the second color
	 * @param 	B2				The blue value of the second color
	 * @param 	Steps			The amount of total steps
	 * @param 	CurrentStep		The step the interpolated color should be on
	 * @param	Alpha			The alpha value you want the interpolated color to have
	 * @return	The interpolated color</haxe_doc>
		</interpolateColorWithRGB>
		<interpolateRGB public="1" get="inline" set="null" line="652" static="1">
			<f a="R1:G1:B1:R2:G2:B2:Steps:CurrentStep">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Get an interpolated color based on the RGB values of two different colors.
	 * 
	 * @param 	R1				The red value of the first color
	 * @param 	G1				The green value of the first color
	 * @param 	B1				The blue value of the first color
	 * @param 	R2				The red value of the second color
	 * @param 	G2				The green value of the second color
	 * @param 	B2				The blue value of the second color
	 * @param 	Steps			The amount of total steps
	 * @param 	CurrentStep		The step the interpolated color should be on
	 * @param	Alpha			The alpha value you want the interpolated color to have
	 * @return	The interpolated color</haxe_doc>
		</interpolateRGB>
		<darken public="1" get="inline" set="null" line="668" static="1">
			<f a="Color:?Factor">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Darken an RGBA color.
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @param	Factor	The higher, the darker! Number from 0 to 1.0.
	 * @return 	The darkened color</haxe_doc>
		</darken>
		<brighten public="1" get="inline" set="null" line="693" static="1">
			<f a="Color:?Factor">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Lighten an RGBA color.
	 * 
	 * @param	Color	In the format 0xAARRGGBB
	 * @param	Factor	The higher, the lighter! Number from 0 to 1.0.
	 * @return 	The lightened color</haxe_doc>
		</brighten>
		<haxe_doc>* Class containing a set of functions for color manipulation and color harmony.</haxe_doc>
	</class>
	<typedef path="flixel.util.RGBA" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<red><x path="Int"/></red>
	<green><x path="Int"/></green>
	<blue><x path="Int"/></blue>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<typedef path="flixel.util.HSBA" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<saturation><x path="Float"/></saturation>
	<hue><x path="Int"/></hue>
	<brightness><x path="Float"/></brightness>
	<alpha><x path="Float"/></alpha>
</a></typedef>
	<typedef path="flixel.util.HSV" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<value><x path="Float"/></value>
	<saturation><x path="Float"/></saturation>
	<lightness><x path="Float"/></lightness>
	<hue><x path="Float"/></hue>
</a></typedef>
	<typedef path="flixel.util.Harmony" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<hue3><x path="Int"/></hue3>
	<hue2><x path="Int"/></hue2>
	<hue1><x path="Int"/></hue1>
	<color3><x path="Int"/></color3>
	<color2><x path="Int"/></color2>
	<color1><x path="Int"/></color1>
</a></typedef>
	<typedef path="flixel.util.TriadicHarmony" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxColorUtil.hx" module="flixel.util.FlxColorUtil"><a>
	<color3><x path="Int"/></color3>
	<color2><x path="Int"/></color2>
	<color1><x path="Int"/></color1>
</a></typedef>
	<class path="flixel.util.FlxMath" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxMath.hx">
		<roundDecimal public="1" get="inline" set="null" line="21" static="1">
			<f a="Value:Precision">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Round a decimal number to have reduced precision (less decimal numbers).
	 * Ex: roundDecimal(1.2485, 2) -> 1.25
	 * 
	 * @param	Value		Any number.
	 * @param	Precision	Number of decimal points to leave in float.
	 * @return	The rounded value of that number.]]></haxe_doc>
		</roundDecimal>
		<bound public="1" get="inline" set="null" line="36" static="1">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Bound a number by a minimum and maximum.
	 * Ensures that this number is no smaller than the minimum,
	 * and no larger than the maximum.
	 * @param	Value	Any number.
	 * @param	Min		Any number.
	 * @param	Max		Any number.
	 * @return	The bounded value of the number.</haxe_doc>
		</bound>
		<lerp public="1" get="inline" set="null" line="50" static="1">
			<f a="Min:Max:Ratio">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns linear interpolated value between Max and Min numbers
	 *
	 * @param Min 		Lower bound.
	 * @param Max	 	Higher bound.
	 * @param Ratio 	Defines which number is closer to desired value.
	 * @return 			Interpolated number.</haxe_doc>
		</lerp>
		<inBounds public="1" get="inline" set="null" line="63" static="1">
			<f a="Value:Min:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Checks if number is in defined range.
	 *
	 * @param Value		Number to check.
	 * @param Min		Lower bound of range.
	 * @param Max 		Higher bound of range.
	 * @return Returns true if Value is in range.</haxe_doc>
		</inBounds>
		<computeVelocity public="1" get="inline" set="null" line="77" static="1">
			<f a="Velocity:Acceleration:Drag:Max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* A tween-like function that takes a starting velocity
	 * and some other factors and returns an altered velocity.
	 * @param	Velocity		Any component of velocity (e.g. 20).
	 * @param	Acceleration	Rate at which the velocity is changing.
	 * @param	Drag			Really kind of a deceleration, this is how much the velocity changes if Acceleration is not set.
	 * @param	Max				An absolute value cap for the velocity (0 for no cap).
	 * @return	The altered Velocity value.</haxe_doc>
		</computeVelocity>
		<isOdd public="1" get="inline" set="null" line="120" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the number given is odd.
	 * 
	 * @param	n	The number to check
	 * 
	 * @return	True if the given number is odd. False if the given number is even.</haxe_doc>
		</isOdd>
		<isEven public="1" get="inline" set="null" line="139" static="1">
			<f a="n">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the number given is even.
	 * 
	 * @param	n	The number to check
	 * 
	 * @return	True if the given number is even. False if the given number is odd.</haxe_doc>
		</isEven>
		<numericComparison public="1" set="method" line="159" static="1">
			<f a="num1:num2">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Compare two numbers.
	 * 
	 * @param	num1	The first number
	 * @param	num2	The second number
	 * 
	 * @return	-1 if num1 is smaller, 1 if num2 is bigger, 0 if they are equal</haxe_doc>
		</numericComparison>
		<pointInCoordinates public="1" set="method" line="184" static="1">
			<f a="pointX:pointY:rectX:rectY:rectWidth:rectHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rectX		The X value of the region to test within
	 * @param	rectY		The Y value of the region to test within
	 * @param	rectWidth	The width of the region to test within
	 * @param	rectHeight	The height of the region to test within
	 * 
	 * @return	true if pointX/pointY is within the region, otherwise false</haxe_doc>
		</pointInCoordinates>
		<pointInFlxRect public="1" set="method" line="205" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the given rectangular block
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The FlxRect to test within
	 * @return	true if pointX/pointY is within the FlxRect, otherwise false</haxe_doc>
		</pointInFlxRect>
		<mouseInFlxRect public="1" set="method" line="224" static="1">
			<f a="useWorldCoords:rect">
				<x path="Bool"/>
				<c path="flixel.util.FlxRect"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the mouse world x/y coordinate are within the given rectangular block
	 * 
	 * @param	useWorldCoords	If true the world x/y coordinates of the mouse will be used, otherwise screen x/y
	 * @param	rect			The FlxRect to test within. If this is null for any reason this function always returns true.
	 * 
	 * @return	true if mouse is within the FlxRect, otherwise false</haxe_doc>
		</mouseInFlxRect>
		<pointInRectangle public="1" set="method" line="250" static="1">
			<f a="pointX:pointY:rect">
				<x path="Float"/>
				<x path="Float"/>
				<c path="flash.geom.Rectangle"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns true if the given x/y coordinate is within the Rectangle
	 * 
	 * @param	pointX		The X value to test
	 * @param	pointY		The Y value to test
	 * @param	rect		The Rectangle to test within
	 * @return	true if pointX/pointY is within the Rectangle, otherwise false</haxe_doc>
		</pointInRectangle>
		<maxAdd public="1" get="inline" set="null" line="270" static="1">
			<f a="value:amount:max:?min">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Adds the given amount to the value, but never lets the value
	 * go over the specified maximum or under the specified minimum.
	 * 
	 * @param 	value 	The value to add the amount to
	 * @param 	amount 	The amount to add to the value
	 * @param 	max 	The maximum the value is allowed to be
	 * @param 	min 	The minimum the value is allowed to be
	 * @return The new value</haxe_doc>
		</maxAdd>
		<wrapValue public="1" set="method" line="295" static="1">
			<f a="value:amount:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Adds value to amount and ensures that the result always stays between 0 and max, by wrapping the value around.
	 * Values must be positive integers, and are passed through <code>Math.abs</code>
	 * 
	 * @param 	value 	The value to add the amount to
	 * @param 	amount 	The amount to add to the value
	 * @param 	max 	The maximum the value is allowed to be
	 * @return The wrapped value]]></haxe_doc>
		</wrapValue>
		<dotProduct public="1" get="inline" set="null" line="318" static="1">
			<f a="ax:ay:bx:by">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the dot product value of two vectors
	 * 
	 * @param	ax		Vector X
	 * @param	ay		Vector Y
	 * @param	bx		Vector X
	 * @param	by		Vector Y
	 * 
	 * @return	Result of the dot product</haxe_doc>
		</dotProduct>
		<vectorLength public="1" get="inline" set="null" line="331" static="1">
			<f a="dx:dy">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Finds the length of the given vector
	 * 
	 * @param	dx
	 * @param	dy
	 * 
	 * @return The length</haxe_doc>
		</vectorLength>
		<getDistance public="1" get="inline" set="null" line="343" static="1">
			<f a="Point1:Point2">
				<c path="flixel.util.FlxPoint"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Calculate the distance between two points.
	 * 
	 * @param 	Point1		A <code>FlxPoint</code> object referring to the first location.
	 * @param 	Point2		A <code>FlxPoint</code> object referring to the second location.
	 * @return	The distance between the two points as a floating point <code>Number</code> object.]]></haxe_doc>
		</getDistance>
		<distanceBetween public="1" get="inline" set="null" line="357" static="1">
			<f a="SpriteA:SpriteB">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) between two FlxSprites, taking their origin into account
	 * 
	 * @param	SpriteA		The first FlxSprite
	 * @param	SpriteB		The second FlxSprite
	 * @return	Distance between the sprites in pixels</haxe_doc>
		</distanceBetween>
		<distanceToPoint public="1" get="inline" set="null" line="373" static="1">
			<f a="Sprite:Target">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Find the distance (in pixels, rounded) from an <code>FlxSprite</code>
	 * to the given <code>FlxPoint</code>, taking the source origin into account.
	 * 
	 * @param	Sprite	The FlxSprite
	 * @param	Target	The FlxPoint
	 * @return	Distance in pixels]]></haxe_doc>
		</distanceToPoint>
		<distanceToMouse public="1" get="inline" set="null" line="388" static="1">
			<f a="Sprite">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from the object x/y and the mouse x/y
	 * 
	 * @param	Sprite	The FlxSprite to test against
	 * @return	The distance between the given sprite and the mouse coordinates</haxe_doc>
		</distanceToMouse>
		<distanceToTouch public="1" get="inline" set="null" line="405" static="1">
			<f a="Sprite:Touch">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.system.input.touch.FlxTouch"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Find the distance (in pixels, rounded) from the object x/y and the FlxPoint screen x/y
	 * 
	 * @param	Sprite	The FlxSprite to test against
	 * @param	Touch	The FlxTouch to test against
	 * @return	The distance between the given sprite and the mouse coordinates</haxe_doc>
		</distanceToTouch>
		<getDecimals public="1" get="inline" set="null" line="420" static="1">
			<f a="Number">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Returns the amount of decimals a Float has
	 * 
	 * @param	Number	The floating point number
	 * @return	Amount of decimals</haxe_doc>
		</getDecimals>
		<equal public="1" get="inline" set="null" line="433" static="1"><f a="aValueA:aValueB:?aDiff">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></equal>
		<MIN_VALUE public="1" get="inline" set="null" line="442" static="1">
			<x path="Float"/>
			<haxe_doc>* Minimum value of a floating point number.</haxe_doc>
		</MIN_VALUE>
		<MAX_VALUE public="1" get="inline" set="null" line="452" static="1">
			<x path="Float"/>
			<haxe_doc>* Maximum value of a floating point number.</haxe_doc>
		</MAX_VALUE>
		<haxe_doc>* A class containing a set of math-related functions.</haxe_doc>
	</class>
	<class path="flixel.util.FlxPool" params="T" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxPool.hx">
		<get_length get="inline" set="null" line="51"><f a=""><x path="Int"/></f></get_length>
		<clear public="1" get="inline" set="null" line="44"><f a=""><c path="Array"><c path="flixel.util.FlxPool.T"/></c></f></clear>
		<putUnsafe public="1" get="inline" set="null" line="35"><f a="obj">
	<c path="flixel.util.FlxPool.T"/>
	<x path="Void"/>
</f></putUnsafe>
		<put public="1" set="method" line="25"><f a="obj">
	<c path="flixel.util.FlxPool.T"/>
	<x path="Void"/>
</f></put>
		<get public="1" get="inline" set="null" line="18"><f a=""><c path="flixel.util.FlxPool.T"/></f></get>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<_pool><c path="Array"><c path="flixel.util.FlxPool.T"/></c></_pool>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* ...
 * @author Zaphod</haxe_doc>
		<meta><m n=":generic"/></meta>
	</class>
	<class path="flixel.util.FlxPool_flixel_util_helpers_FlickerData" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxPool.hx">
		<get_length get="inline" set="null" line="51"><f a=""><x path="Int"/></f></get_length>
		<clear public="1" get="inline" set="null" line="44"><f a=""><c path="Array"><c path="flixel.util.helpers.FlickerData"/></c></f></clear>
		<putUnsafe public="1" get="inline" set="null" line="35"><f a="obj">
	<c path="flixel.util.helpers.FlickerData"/>
	<x path="Void"/>
</f></putUnsafe>
		<put public="1" set="method" line="25"><f a="obj">
	<c path="flixel.util.helpers.FlickerData"/>
	<x path="Void"/>
</f></put>
		<get public="1" get="inline" set="null" line="18"><f a=""><c path="flixel.util.helpers.FlickerData"/></f></get>
		<length public="1" get="accessor" set="null"><x path="Int"/></length>
		<_pool><c path="Array"><c path="flixel.util.helpers.FlickerData"/></c></_pool>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.FlxRandom" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxRandom.hx">
		<globalSeed public="1" static="1">
			<x path="Float"/>
			<haxe_doc>* The global random number generator seed (for deterministic behavior in recordings and saves).</haxe_doc>
		</globalSeed>
		<intHelper line="16" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Internal helper for <code>FlxRandom.int()</code>]]></haxe_doc>
		</intHelper>
		<MAX_RANGE public="1" get="inline" set="null" line="20" static="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* Maximum value returned by <code>FlxRandom.intRanged</code> and <code>FlxRandom.floatRanged</code> by default.]]></haxe_doc>
		</MAX_RANGE>
		<int public="1" set="method" line="30" static="1">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Generates a small random number between 0 and 65535 very quickly
	 * 
	 * Generates a small random number between 0 and 65535 using an extremely fast cyclical generator, 
	 * with an even spread of numbers. After the 65536th call to this function the value resets.
	 * 
	 * @return A pseudo random value between 0 and 65536 inclusive.</haxe_doc>
		</int>
		<intRanged public="1" set="method" line="61" static="1">
			<f a="?Min:?Max:?Excludes">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>* Generate a random integer
	 * 
	 * If called without the optional min, max arguments rand() returns a peudo-random integer between 0 and MAX_RANGE.
	 * If you want a random number between 5 and 15, for example, (inclusive) use rand(5, 15)
	 * Parameter order is insignificant, the return will always be between the lowest and highest value.
	 * 
	 * @param 	Min 		The lowest value to return (default: 0)
	 * @param 	Max 		The highest value to return (default: MAX_RANGE)
	 * @param 	Excludes 	An Array of integers that will NOT be returned (default: null)
	 * @return A pseudo-random value between min (or 0) and max (or MAX_RANGE, inclusive)</haxe_doc>
		</intRanged>
		<float public="1" get="inline" set="null" line="118" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[* Generates a random number.  Deterministic, meaning safe
	 * to use if you want to record replays in random environments.
	 * @return	A <code>Number</code> between 0 and 1.]]></haxe_doc>
		</float>
		<floatRanged public="1" set="method" line="136" static="1">
			<f a="?min:?max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Generate a random float (number)
	 * 
	 * If called without the optional min, max arguments rand() returns a peudo-random float between 0 and MAX_RANGE().
	 * If you want a random number between 5 and 15, for example, (inclusive) use rand(5, 15)
	 * Parameter order is insignificant, the return will always be between the lowest and highest value.
	 * 
	 * @param 	min 	The lowest value to return (default: 0)
	 * @param 	max 	The highest value to return (default: MAX_RANGE)
	 * @return A pseudo random value between min (or 0) and max (or MAX_RANGE, inclusive)</haxe_doc>
		</floatRanged>
		<srand public="1" get="inline" set="null" line="167" static="1">
			<f a="Seed">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Generates a random number based on the seed provided.
	 * @param	Seed	A number between 0 and 1, used to generate a predictable random number (very optional).
	 * @return	A <code>Number</code> between 0 and 1.]]></haxe_doc>
		</srand>
		<chanceRoll public="1" set="method" line="181" static="1">
			<f a="?chance">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Generate a random boolean result based on the chance value
	 * 
	 * Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance
	 * of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.
	 * 
	 * @param 	chance 	The chance of receiving the value. Should be given as a uint between 0 and 100 (effectively 0% to 100%)
	 * @return true if the roll passed, or false</haxe_doc>
		</chanceRoll>
		<sign public="1" get="inline" set="null" line="209" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Randomly returns either a 1 or -1
	 * 
	 * @return	1 or -1</haxe_doc>
		</sign>
		<color public="1" get="inline" set="null" line="225" static="1">
			<f a="?min:?max:?alpha">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[* Returns a random color value between black and white
	 * <p>Set the min value to start each channel from the given offset.</p>
	 * <p>Set the max value to restrict the maximum color used per channel</p>
	 * 
	 * @param	min		The lowest value to use for the color
	 * @param	max 	The highest value to use for the color
	 * @param	alpha	The alpha value of the returning color (default 255 = fully opaque)
	 * 
	 * @return 32-bit color value with alpha]]></haxe_doc>
		</color>
		<haxe_doc>* A class containing a set of functions for randomnly 
 * generating numbers or other random things.</haxe_doc>
	</class>
	<class path="flixel.util.FlxSpriteUtil" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxSpriteUtil.hx">
		<flashGfxSprite public="1" set="null" line="30" static="1">
			<c path="flash.display.Sprite"/>
			<haxe_doc>* Useful helper objects for doing Flash-specific rendering.
	 * Primarily used for "debug visuals" like drawing bounding boxes directly to the screen buffer.</haxe_doc>
		</flashGfxSprite>
		<flashGfx public="1" set="null" line="31" static="1"><c path="flash.display.Graphics"/></flashGfx>
		<alphaMask public="1" set="method" line="45" static="1">
			<f a="source:mask:output">
				<d/>
				<d/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc><![CDATA[* Takes two source images (typically from Embedded bitmaps) and puts the resulting image into the output FlxSprite.<br>
	 * Note: It assumes the source and mask are the same size. Different sizes may result in undesired results.<br>
	 * It works by copying the source image (your picture) into the output sprite. Then it removes all areas of it that do not<br>
	 * have an alpha color value in the mask image. So if you draw a big black circle in your mask with a transparent edge, you'll<br>
	 * get a circular image appear. Look at the mask PNG files in the assets/pics folder for examples.
	 * 
	 * @param	source		The source image. Typically the one with the image / picture / texture in it.
	 * @param	mask		The mask to apply. Remember the non-alpha zero areas are the parts that will display.
	 * @param	output		The FlxSprite you wish the resulting image to be placed in (will adjust width/height of image)
	 * @return	The output FlxSprite for those that like chaining]]></haxe_doc>
		</alphaMask>
		<alphaMaskFlxSprite public="1" set="method" line="101" static="1">
			<f a="sprite:mask:output">
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc><![CDATA[* Takes the image data from two FlxSprites and puts the resulting image into the output FlxSprite.<br>
	 * Note: It assumes the source and mask are the same size. Different sizes may result in undesired results.<br>
	 * It works by copying the source image (your picture) into the output sprite. Then it removes all areas of it that do not<br>
	 * have an alpha color value in the mask image. So if you draw a big black circle in your mask with a transparent edge, you'll<br>
	 * get a circular image appear. Look at the mask PNG files in the assets/pics folder for examples.
	 * 
	 * @param	Sprite		The source <code>FlxSprite</code>. Typically the one with the image / picture / texture in it.
	 * @param	mask		The FlxSprite containing the mask to apply. Remember the non-alpha zero areas are the parts that will display.
	 * @param	output		The FlxSprite you wish the resulting image to be placed in (will adjust width/height of image)
	 * @return	The output FlxSprite for those that like chaining]]></haxe_doc>
		</alphaMaskFlxSprite>
		<screenWrap public="1" set="method" line="121" static="1">
			<f a="sprite:?Left:?Right:?Top:?Bottom">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Checks the x/y coordinates of the source FlxSprite and keeps them within the area of 0, 0, FlxG.width, FlxG.height (i.e. wraps it around the screen)
	 * 
	 * @param	Sprite		The <code>FlxSprite</code> to keep within the screen
	 * @param	Left		Whether to activate screen wrapping on the left side of the screen
	 * @param	Right		Whether to activate screen wrapping on the right side of the screen
	 * @param	Top			Whether to activate screen wrapping on the top of the screen
	 * @param	Bottom		Whether to activate screen wrapping on the bottom of the screen]]></haxe_doc>
		</screenWrap>
		<space public="1" set="method" line="152" static="1">
			<f a="sprites:startX:startY:?horizontalSpacing:?verticalSpacing:?spaceFromBounds">
				<c path="Array"><c path="flixel.FlxSprite"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Aligns a set of FlxSprites so there is equal spacing between them
	 * 
	 * @param	sprites				An Array of FlxSprites
	 * @param	startX				The base X coordinate to start the spacing from
	 * @param	startY				The base Y coordinate to start the spacing from
	 * @param	horizontalSpacing	The amount of pixels between each sprite horizontally (default 0)
	 * @param	verticalSpacing		The amount of pixels between each sprite vertically (default 0)
	 * @param	spaceFromBounds		If set to true the h/v spacing values will be added to the width/height of the sprite, if false it will ignore this</haxe_doc>
		</space>
		<screenCenter public="1" set="method" line="182" static="1">
			<f a="sprite:?xAxis:?yAxis">
				<c path="flixel.FlxSprite"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="flixel.FlxSprite"/>
			</f>
			<haxe_doc><![CDATA[* Centers the given FlxSprite on the screen, either by the X axis, Y axis, or both
	 * 
	 * @param	Sprite			The <code>FlxSprite<code> to center
	 * @param	Horizontally	Boolean true if you want it centered horizontally
	 * @param	Vertically		Boolean	true if you want it centered vertically
	 * @return	The FlxSprite for chaining]]></haxe_doc>
		</screenCenter>
		<drawLine public="1" set="method" line="209" static="1">
			<f a="sprite:StartX:StartY:EndX:EndY:Color:?Thickness">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws a line on a sprite from position X1,Y1
	 * to position X2,Y2 with the specified color.
	 * 
	 * @param	Sprite		The <code>FlxSprite</code> to manipulate
	 * @param	StartX		X coordinate of the line's start point.
	 * @param	StartY		Y coordinate of the line's start point.
	 * @param	EndX		X coordinate of the line's end point.
	 * @param	EndY		Y coordinate of the line's end point.
	 * @param	Color		The line's color.
	 * @param	Thickness	How thick the line is in pixels (default value is 1).]]></haxe_doc>
		</drawLine>
		<drawRect public="1" set="method" line="238" static="1">
			<f a="sprite:X:Y:Width:Height:Color">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws a rectangle on a sprite.
	 * 
	 * @param	Sprite		The <code>FlxSprite</code> to manipulate
	 * @param	X			X coordinate of the rectangle's start point.
	 * @param	Y			Y coordinate of the rectangle's start point.
	 * @param	Width		Width of the rectangle
	 * @param	Height		Height of the rectangle
	 * @param	Color		The rectangle's color.]]></haxe_doc>
		</drawRect>
		<drawRoundRect public="1" set="method" line="260" static="1">
			<f a="sprite:X:Y:Width:Height:EllipseWidth:EllipseHeight:Color">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws a rounded rectangle on a sprite.
	 * 
	 * @param	Sprite			The <code>FlxSprite</code> to manipulate
	 * @param	X				X coordinate of the rectangle's start point.
	 * @param	Y				Y coordinate of the rectangle's start point.
	 * @param	Width			Width of the rectangle
	 * @param	Height			Height of the rectangle
	 * @param	EllipseWidth	The width of the ellipse used to draw the rounded corners
	 * @param	EllipseHeight	The height of the ellipse used to draw the rounded corners
	 * @param	Color			The rectangle's color.]]></haxe_doc>
		</drawRoundRect>
		<drawCircle public="1" set="method" line="307" static="1">
			<f a="sprite:X:Y:Radius:Color">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws a circle on this sprite at position X,Y
	 * with the specified color.
	 * 
	 * @param	Sprite	The <code>FlxSprite</code> to manipulate
	 * @param 	X 		X coordinate of the circle's center
	 * @param 	Y 		Y coordinate of the circle's center
	 * @param 	Radius 	Radius of the circle
	 * @param 	Color 	Color of the circle]]></haxe_doc>
		</drawCircle>
		<drawEllipse public="1" set="method" line="327" static="1">
			<f a="sprite:X:Y:Width:Height:Color">
				<c path="flixel.FlxSprite"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* This function draws an ellipse on a sprite.
	 * 
	 * @param	Sprite		The <code>FlxSprite</code> to manipulate
	 * @param	X			X coordinate of the ellipse's start point.
	 * @param	Y			Y coordinate of the ellipse's start point.
	 * @param	Width		Width of the ellipse
	 * @param	Height		Height of the ellipse
	 * @param	Color		The ellipse's color.]]></haxe_doc>
		</drawEllipse>
		<updateSpriteGraphic public="1" set="method" line="343" static="1">
			<f a="sprite">
				<c path="flixel.FlxSprite"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Just a helper function that is called at the end of the draw functions
	 * to handle a few things related to updating a sprite's graphic.
	 * 
	 * @param	Sprite	The <code>FlxSprite</code> to manipulate]]></haxe_doc>
		</updateSpriteGraphic>
		<fill public="1" set="method" line="356" static="1">
			<f a="sprite:Color">
				<c path="flixel.FlxSprite"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* Fills this sprite's graphic with a specific color.
	 * 
	 * @param	Sprite	The <code>FlxSprite</code> to manipulate
	 * @param	Color	The color with which to fill the graphic, format 0xAARRGGBB.]]></haxe_doc>
		</fill>
		<flicker public="1" get="inline" set="null" line="375" static="1">
			<f a="object:?Duration:?Interval">
				<c path="flixel.FlxObject"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[* A simple flicker effect for sprites using a ping-pong tween by toggling visibility.
	 * 
	 * @param	object		The sprite.
	 * @param	Duration	How long to flicker for.
	 * @param	Interval	In what intervall to toggle visibility. Set to <code>FlxG.elapsed</code> if <= 0!]]></haxe_doc>
		</flicker>
		<flickerProgress get="inline" set="null" line="389" static="1">
			<f a="Timer">
				<c path="flixel.util.FlxTimer"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Just a helper function for flicker() to update object's visibility.</haxe_doc>
		</flickerProgress>
		<haxe_doc><![CDATA[* Some handy functions for <code>FlxSprite</code>s manipulation.]]></haxe_doc>
	</class>
	<class path="flixel.util.FlxStringUtil" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/FlxStringUtil.hx">
		<formatTicks public="1" get="inline" set="null" line="18" static="1">
			<f a="StartTicks:EndTicks">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Takes two "ticks" timestamps and formats them into the number of seconds that passed as a String.
	 * Useful for logging, debugging, the watch window, or whatever else.
	 * @param	StartTicks	The first timestamp from the system.
	 * @param	EndTicks	The second timestamp from the system.
	 * @return	A <code>String</code> containing the formatted time elapsed information.]]></haxe_doc>
		</formatTicks>
		<formatTime public="1" get="inline" set="null" line="29" static="1">
			<f a="Seconds:?ShowMS">
				<x path="Float"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Format seconds as minutes with a colon, an optionally with milliseconds too.
	 * @param	Seconds		The number of seconds (for example, time remaining, time spent, etc).
	 * @param	ShowMS		Whether to show milliseconds after a "." as well.  Default value is false.
	 * @return	A nicely formatted <code>String</code>, like "1:03".]]></haxe_doc>
		</formatTime>
		<formatArray public="1" get="inline" set="null" line="58" static="1">
			<f a="AnyArray">
				<c path="Array"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Generate a comma-separated string from an array.
	 * Especially useful for tracing or other debug output.
	 * @param	AnyArray	Any <code>Array</code> object.
	 * @return	A comma-separated <code>String</code> containing the <code>.toString()</code> output of each element in the array.]]></haxe_doc>
		</formatArray>
		<formatFlxPoint public="1" get="inline" set="null" line="80" static="1">
			<f a="Point:Precision">
				<c path="flixel.util.FlxPoint"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Generate a string representation of a FlxPoint.
	 * @param  Point    A <code>FlxPoint</code> object.
	 * @param  Precison  To how many decimals x and y should be rounded.
	 * @return  A <code>String</code> formatted like this: <code>x: Point.x | y: Point.y</code>]]></haxe_doc>
		</formatFlxPoint>
		<formatStringMap public="1" get="inline" set="null" line="99" static="1">
			<f a="AnyMap">
				<x path="Map">
					<c path="String"/>
					<d/>
				</x>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Generate a comma-seperated string representation of the keys of a <code>StringMap</code>.
	 * @param  AnyMap    A <code>StringMap</code> object.
	 * @return  A <code>String</code> formatted like this: <code>key1, key2, ..., keyX</code>]]></haxe_doc>
		</formatStringMap>
		<formatMoney public="1" get="inline" set="null" line="120" static="1">
			<f a="Amount:?ShowDecimal:?EnglishStyle">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[* Automatically commas and decimals in the right places for displaying money amounts.
	 * Does not include a dollar sign or anything, so doesn't really do much
	 * if you call say <code>var results:String = FlxString.formatMoney(10,false);</code>
	 * However, very handy for displaying large sums or decimal money values.
	 * @param	Amount			How much moneys (in dollars, or the equivalent "main" currency - i.e. not cents).
	 * @param	ShowDecimal		Whether to show the decimals/cents component. Default value is true.
	 * @param	EnglishStyle	Major quantities (thousands, millions, etc) separated by commas, and decimal by a period.  Default value is true.
	 * @return	A nicely formatted <code>String</code>.  Does not include a dollar sign or anything!]]></haxe_doc>
		</formatMoney>
		<haxe_doc>* A class primarily containing functions related 
 * to formatting different data types to strings.</haxe_doc>
	</class>
	<class path="flixel.util.helpers.FlickerData" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/helpers/FlickerData.hx">
		<_pool line="8" static="1"><c path="flixel.util.FlxPool_flixel_util_helpers_FlickerData"/></_pool>
		<recycle public="1" set="method" line="10" static="1"><f a="object">
	<c path="flixel.FlxObject"/>
	<c path="flixel.util.helpers.FlickerData"/>
</f></recycle>
		<put public="1" set="method" line="17" static="1"><f a="data">
	<c path="flixel.util.helpers.FlickerData"/>
	<x path="Void"/>
</f></put>
		<reset public="1" set="method" line="32"><f a="object">
	<c path="flixel.FlxObject"/>
	<x path="Void"/>
</f></reset>
		<destroy public="1" set="method" line="27"><f a=""><x path="Void"/></f></destroy>
		<startVisibility public="1"><x path="Bool"/></startVisibility>
		<object public="1"><c path="flixel.FlxObject"/></object>
		<new set="method" line="25"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.loaders.CachedGraphics" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/loaders/CachedGraphics.hx">
		<set_useCount set="method" line="204"><f a="Value">
	<x path="Int"/>
	<x path="Int"/>
</f></set_useCount>
		<get_useCount set="method" line="199"><f a=""><x path="Int"/></f></get_useCount>
		<get_canBeDumped set="method" line="194"><f a=""><x path="Bool"/></f></get_canBeDumped>
		<destroy public="1" set="method" line="171"><f a=""><x path="Void"/></f></destroy>
		<getRegionForFrame public="1" set="method" line="156"><f a="frameName">
	<c path="String"/>
	<c path="flixel.util.loaders.TextureRegion"/>
</f></getRegionForFrame>
		<getBitmapFromSystem set="method" line="141"><f a=""><c path="flash.display.BitmapData"/></f></getBitmapFromSystem>
		<get_tilesheet set="method" line="128"><f a=""><c path="flixel.system.layer.TileSheetData"/></f></get_tilesheet>
		<onContext public="1" set="method" line="116">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Use this method to restore cached bitmapdata (it it's possible).
	 * It's called automatically when RESIZE event occurs.</haxe_doc>
		</onContext>
		<undump public="1" set="method" line="90">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Undumps bits of bitmapdata - regenerates it and regenerate tilesheet data for this object</haxe_doc>
		</undump>
		<dump public="1" set="method" line="74">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dumps bits of bitmapdata = less memory, but you can't read / write pixels on it anymore 
	 * (but you can call onContext() method which will restore it again)</haxe_doc>
		</dump>
		<destroyOnNoUse public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether we should destroy this CachedGraphics object when useCount become zero.
	 * Default if false.</haxe_doc>
		</destroyOnNoUse>
		<_useCount><x path="Int"/></_useCount>
		<useCount public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>* Usage counter for this CachedGraphics object.</haxe_doc>
		</useCount>
		<tilesheet public="1" get="accessor" set="null"><c path="flixel.system.layer.TileSheetData"/></tilesheet>
		<canBeDumped public="1" get="accessor" set="null">
			<x path="Bool"/>
			<haxe_doc>* Says if bitmapdata of this Cache object can be dumped for less memory usage</haxe_doc>
		</canBeDumped>
		<isDumped public="1" set="null">
			<x path="Bool"/>
			<haxe_doc>* Says if bitmapdata of this Cache object has been dumped or not</haxe_doc>
		</isDumped>
		<assetsClass public="1">
			<x path="Class"><c path="flash.display.BitmapData"/></x>
			<haxe_doc>* Class name for bitmapdata</haxe_doc>
		</assetsClass>
		<assetsKey public="1">
			<c path="String"/>
			<haxe_doc>* Asset name from openfl.Assets</haxe_doc>
		</assetsKey>
		<persist public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether this Cached object should stay in cache after state change or not.</haxe_doc>
		</persist>
		<_tilesheet><c path="flixel.system.layer.TileSheetData"/></_tilesheet>
		<data public="1">
			<c path="flixel.util.loaders.TexturePackerData"/>
			<haxe_doc>* TexturePackerData associated with bitmapdata</haxe_doc>
		</data>
		<bitmap public="1">
			<c path="flash.display.BitmapData"/>
			<haxe_doc>* Cached BitmapData object</haxe_doc>
		</bitmap>
		<key public="1">
			<c path="String"/>
			<haxe_doc>* Key in BitmapFrontEnd cache</haxe_doc>
		</key>
		<new public="1" set="method" line="63"><f a="key:bitmap:?persist">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flixel.util.loaders.TextureAtlasFrame" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/loaders/TextureAtlasFrame.hx">
		<destroy public="1" set="method" line="18"><f a=""><x path="Void"/></f></destroy>
		<offset public="1"><c path="flixel.util.FlxPoint"/></offset>
		<sourceSize public="1"><c path="flixel.util.FlxPoint"/></sourceSize>
		<trimmed public="1"><x path="Bool"/></trimmed>
		<rotated public="1"><x path="Bool"/></rotated>
		<frame public="1"><c path="flash.geom.Rectangle"/></frame>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flixel.util.loaders.TexturePackerData" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/loaders/TexturePackerData.hx">
		<destroy public="1" set="method" line="80">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Memory cleaning method</haxe_doc>
		</destroy>
		<parseData public="1" set="method" line="43">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Data parsing method.
	 * Override it in subclasses if you want to implement support for new atlas formats</haxe_doc>
		</parseData>
		<asset public="1"><c path="flash.display.BitmapData"/></asset>
		<description public="1"><c path="String"/></description>
		<assetName public="1"><c path="String"/></assetName>
		<frames public="1"><c path="Array"><c path="flixel.util.loaders.TextureAtlasFrame"/></c></frames>
		<new public="1" set="method" line="29">
			<f a="description:assetName">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Constructor
	 * 
	 * @param	description		name of data file with atlas description
	 * @param	assetName		name of atlas image file</haxe_doc>
		</new>
	</class>
	<class path="flixel.util.loaders.TextureRegion" params="" file="/media/psf/Home/projects/repos/public/flixel/flixel/util/loaders/TextureRegion.hx">
		<destroy public="1" set="method" line="22"><f a=""><x path="Void"/></f></destroy>
		<clone public="1" set="method" line="17"><f a=""><c path="flixel.util.loaders.TextureRegion"/></f></clone>
		<region public="1"><c path="flixel.system.layer.Region"/></region>
		<data public="1"><c path="flixel.util.loaders.CachedGraphics"/></data>
		<new public="1" set="method" line="11"><f a="data:?startX:?startY:?tileWidth:?tileHeight:?spacingX:?spacingY:?width:?height">
	<c path="flixel.util.loaders.CachedGraphics"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Json" params="" file="/usr/lib/haxe/std/haxe/Json.hx">
		<parse public="1" set="method" line="398" static="1"><f a="text">
	<c path="String"/>
	<d/>
</f></parse>
		<parseNumber get="inline" set="null" line="358"><f a="c">
	<x path="Int"/>
	<x path="Float"/>
</f></parseNumber>
		<invalidNumber set="method" line="354"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<parseString set="method" line="293"><f a=""><c path="String"/></f></parseString>
		<parseRec set="method" line="211"><f a=""><d/></f></parseRec>
		<invalidChar set="method" line="202"><f a=""><x path="Void"/></f></invalidChar>
		<doParse set="method" line="196"><f a="str">
	<c path="String"/>
	<unknown/>
</f></doParse>
		<pos><x path="Int"/></pos>
		<str><c path="String"/></str>
		<new set="method" line="39"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Crossplatform JSON API : it will automatically use the optimized native API if available.
	Use -D haxeJSON to force usage of the Haxe implementation even if a native API is found : this will provide
	extra encoding features such as enums (replaced by their index), Hashs and Iterable.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="/usr/lib/haxe/std/js/_std/haxe/ds/IntMap.hx">
		<implements path="IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<remove public="1" set="method" line="44">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<exists public="1" set="method" line="40">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" set="method" line="36">
			<f a="key">
				<x path="Int"/>
				<t path="Null"><c path="haxe.ds.IntMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<h><d/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/js/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<iterator public="1" set="method" line="62">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="51">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<remove public="1" set="method" line="44">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<exists public="1" set="method" line="40">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<get public="1" set="method" line="36">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="haxe.ds.StringMap.T"/></t>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<set public="1" set="method" line="32">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<h><d/></h>
		<new public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.xml._Parser.S" params="" file="/usr/lib/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" extern="1">
		<IGNORE_SPACES public="1" get="inline" set="null" line="28" static="1"><x path="Int"/></IGNORE_SPACES>
		<BEGIN public="1" get="inline" set="null" line="29" static="1"><x path="Int"/></BEGIN>
		<BEGIN_NODE public="1" get="inline" set="null" line="30" static="1"><x path="Int"/></BEGIN_NODE>
		<TAG_NAME public="1" get="inline" set="null" line="31" static="1"><x path="Int"/></TAG_NAME>
		<BODY public="1" get="inline" set="null" line="32" static="1"><x path="Int"/></BODY>
		<ATTRIB_NAME public="1" get="inline" set="null" line="33" static="1"><x path="Int"/></ATTRIB_NAME>
		<EQUALS public="1" get="inline" set="null" line="34" static="1"><x path="Int"/></EQUALS>
		<ATTVAL_BEGIN public="1" get="inline" set="null" line="35" static="1"><x path="Int"/></ATTVAL_BEGIN>
		<ATTRIB_VAL public="1" get="inline" set="null" line="36" static="1"><x path="Int"/></ATTRIB_VAL>
		<CHILDS public="1" get="inline" set="null" line="37" static="1"><x path="Int"/></CHILDS>
		<CLOSE public="1" get="inline" set="null" line="38" static="1"><x path="Int"/></CLOSE>
		<WAIT_END public="1" get="inline" set="null" line="39" static="1"><x path="Int"/></WAIT_END>
		<WAIT_END_RET public="1" get="inline" set="null" line="40" static="1"><x path="Int"/></WAIT_END_RET>
		<PCDATA public="1" get="inline" set="null" line="41" static="1"><x path="Int"/></PCDATA>
		<HEADER public="1" get="inline" set="null" line="42" static="1"><x path="Int"/></HEADER>
		<COMMENT public="1" get="inline" set="null" line="43" static="1"><x path="Int"/></COMMENT>
		<DOCTYPE public="1" get="inline" set="null" line="44" static="1"><x path="Int"/></DOCTYPE>
		<CDATA public="1" get="inline" set="null" line="45" static="1"><x path="Int"/></CDATA>
		<ESCAPE public="1" get="inline" set="null" line="46" static="1"><x path="Int"/></ESCAPE>
	</class>
	<class path="js.Boot" params="" file="/usr/lib/haxe/std/js/Boot.hx">
		<__unhtml set="method" line="26" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unhtml>
		<__trace set="method" line="30" static="1"><f a="v:i">
	<a>
		<toString set="null"><f a=""><c path="String"/></f></toString>
		<length set="null"><x path="Int"/></length>
		<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
		<__enum__ set="null"><x path="Bool"/></__enum__>
	</a>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec set="method" line="75" static="1">
			<f a="o:s">
				<a>
					<toString set="null"><f a=""><c path="String"/></f></toString>
					<length set="null"><x path="Int"/></length>
					<hasOwnProperty set="null"><f a="">
	<c path="String"/>
	<x path="Bool"/>
</f></hasOwnProperty>
					<__enum__ set="null"><x path="Bool"/></__enum__>
				</a>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":ifFeature"><e>"has_enum"</e></m></meta>
		</__string_rec>
		<__interfLoop set="method" line="147" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="162" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_catch"</e></m></meta>
		</__instanceof>
		<__cast set="method" line="198" static="1">
			<f a="o:t">
				<d/>
				<d/>
				<unknown/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_cast"</e></m></meta>
		</__cast>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="openfl.Assets" params="" file="/media/psf/Home/projects/repos/public/openfl/openfl/Assets.hx">
		<cachedBitmapData public="1" line="50" static="1"><x path="Map">
	<c path="String"/>
	<c path="flash.display.BitmapData"/>
</x></cachedBitmapData>
		<id public="1" get="accessor" set="null" static="1"><c path="Array"><c path="String"/></c></id>
		<library public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<e path="openfl.LibraryType"/>
</x></library>
		<path public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></path>
		<type public="1" get="accessor" set="null" static="1"><x path="Map">
	<c path="String"/>
	<e path="openfl.AssetType"/>
</x></type>
		<initialized line="59" static="1"><x path="Bool"/></initialized>
		<initialize set="method" line="62" static="1"><f a=""><x path="Void"/></f></initialize>
		<getBitmapData public="1" set="method" line="86" static="1">
			<f a="id:?useCache">
				<c path="String"/>
				<x path="Bool"/>
				<c path="flash.display.BitmapData"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded bitmap
	 * @usage		var bitmap = new Bitmap(Assets.getBitmapData("image.jpg"));
	 * @param	id		The ID or asset path for the bitmap
	 * @param	useCache		(Optional) Whether to use BitmapData from the cache(Default: true)
	 * @return		A new BItmapData object</haxe_doc>
		</getBitmapData>
		<getBytes public="1" set="method" line="180" static="1">
			<f a="id">
				<c path="String"/>
				<c path="flash.utils.ByteArray"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded binary asset
	 * @usage		var bytes = Assets.getBytes("file.zip");
	 * @param	id		The ID or asset path for the file
	 * @return		A new ByteArray object</haxe_doc>
		</getBytes>
		<getFont public="1" set="method" line="237" static="1">
			<f a="id">
				<c path="String"/>
				<c path="flash.text.Font"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded font
	 * @usage		var fontName = Assets.getFont("font.ttf").fontName;
	 * @param	id		The ID or asset path for the font
	 * @return		A new Font object</haxe_doc>
		</getFont>
		<getSound public="1" set="method" line="330" static="1">
			<f a="id">
				<c path="String"/>
				<c path="flash.media.Sound"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded sound
	 * @usage		var sound = Assets.getSound("sound.wav");
	 * @param	id		The ID or asset path for the sound
	 * @return		A new Sound object</haxe_doc>
		</getSound>
		<getText public="1" set="method" line="407" static="1">
			<f a="id">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Gets an instance of an embedded text asset
	 * @usage		var text = Assets.getText("text.txt");
	 * @param	id		The ID or asset path for the file
	 * @return		A new String object</haxe_doc>
		</getText>
		<resolveClass set="method" line="457" static="1"><f a="name">
	<c path="String"/>
	<x path="Class"><d/></x>
</f></resolveClass>
		<resolveEnum set="method" line="466" static="1"><f a="name">
	<c path="String"/>
	<x path="Enum"><d/></x>
</f></resolveEnum>
		<get_id set="method" line="491" static="1"><f a=""><c path="Array"><c path="String"/></c></f></get_id>
		<get_library set="method" line="512" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<e path="openfl.LibraryType"/>
</x></f></get_library>
		<get_path set="method" line="529" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<c path="String"/>
</x></f></get_path>
		<get_type set="method" line="546" static="1"><f a=""><x path="Map">
	<c path="String"/>
	<e path="openfl.AssetType"/>
</x></f></get_type>
		<haxe_doc><![CDATA[* <p>The Assets class provides a cross-platform interface to access 
 * embedded images, fonts, sounds and other resource files.</p>
 * 
 * <p>The contents are populated automatically when an application
 * is compiled using the NME command-line tools, based on the
 * contents of the *.nmml project file.</p>
 * 
 * <p>For most platforms, the assets are included in the same directory
 * or package as the application, and the paths are handled
 * automatically. For web content, the assets are preloaded before
 * the start of the rest of the application. You can customize the 
 * preloader by extending the <code>NMEPreloader</code> class,
 * and specifying a custom preloader using <window preloader="" />
 * in the project file.</p>]]></haxe_doc>
	</class>
	<enum path="openfl.AssetType" params="" file="/media/psf/Home/projects/repos/public/openfl/openfl/Assets.hx" module="openfl.Assets">
		<BINARY/>
		<FONT/>
		<IMAGE/>
		<MUSIC/>
		<SOUND/>
		<TEXT/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="openfl.LibraryType" params="" file="/media/psf/Home/projects/repos/public/openfl/openfl/Assets.hx" module="openfl.Assets">
		<SWF/>
		<SWF_LITE/>
		<XFL/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
</haxe>